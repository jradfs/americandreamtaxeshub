# Code Analysis Snapshot

## Project Overview

### Goals

- Build a scalable tax management platform
- Implement modern tech stack (Next.js, TypeScript, Supabase)
- Focus on type safety and maintainability

### Tech Stack

- Next.js 13+
- TypeScript
- Supabase
- Tailwind CSS
- shadcn/ui components

## Directory Structure

```
src/
  ‚îú‚îÄ‚îÄ app/           # Next.js 13+ app directory
  ‚îú‚îÄ‚îÄ components/    # React components
  ‚îú‚îÄ‚îÄ hooks/         # Custom React hooks
  ‚îú‚îÄ‚îÄ lib/           # Utility functions and services
  ‚îú‚îÄ‚îÄ types/         # TypeScript type definitions
  ‚îî‚îÄ‚îÄ styles/        # Global styles and CSS modules
```

## Core Configuration

### next.config.js

```js
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  typescript: {
    ignoreBuildErrors: false,
    tsconfigPath: "./tsconfig.json",
  },
  transpilePackages: ["@supabase/ssr", "@tanstack/react-table", "lucide-react"],
  webpack: (config, { isServer }) => {
    config.resolve = {
      ...config.resolve,
      alias: {
        ...config.resolve?.alias,
        "@": "./src",
      },
      extensions: [".ts", ".tsx", ".js", ".jsx", ".json"],
    };
    if (!isServer) {
      config.resolve.fallback = {
        ...config.resolve.fallback,
        punycode: false,
      };
    }
    return config;
  },
  poweredByHeader: false,
  generateEtags: false,
  eslint: {
    ignoreDuringBuilds: false,
  },
  experimental: {
    optimizePackageImports: [
      "@radix-ui/react-icons",
      "@supabase/ssr",
      "@tanstack/react-table",
    ],
    serverActions: {
      bodySizeLimit: "2mb",
      allowedOrigins: ["localhost:3000", "localhost:3001"],
    },
  },
  compiler: {
    removeConsole: process.env.NODE_ENV === "production",
  },
  productionBrowserSourceMaps: false,
};

module.exports = nextConfig;
```

### package.json

```json
{
  "type": "commonjs",
  "name": "american-dream-taxes-hub",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "test": "vitest",
    "test:unit": "vitest run src/__tests__/components",
    "test:integration": "vitest run src/__tests__/integration",
    "test:security": "vitest run src/__tests__/security",
    "test:performance": "vitest run src/__tests__/performance",
    "test:coverage": "vitest run --coverage",
    "test:watch": "vitest watch",
    "test:clean": "rimraf coverage .vitest",
    "test:clients": "vitest run src/__tests__/clients",
    "test:documents": "vitest run src/__tests__/documents",
    "test:tasks": "vitest run src/__tests__/tasks",
    "test:e2e": "playwright test",
    "test:e2e:ui": "playwright test --ui",
    "clean": "rimraf .next"
  },
  "dependencies": {
    "@hello-pangea/dnd": "^17.0.0",
    "@hookform/resolvers": "^3.10.0",
    "@nivo/network": "^0.88.0",
    "@radix-ui/react-accordion": "^1.2.2",
    "@radix-ui/react-alert-dialog": "^1.1.4",
    "@radix-ui/react-aspect-ratio": "^1.1.1",
    "@radix-ui/react-avatar": "^1.1.2",
    "@radix-ui/react-checkbox": "^1.1.3",
    "@radix-ui/react-context-menu": "^2.2.4",
    "@radix-ui/react-dialog": "^1.0.5",
    "@radix-ui/react-dropdown-menu": "^2.1.4",
    "@radix-ui/react-hover-card": "^1.1.4",
    "@radix-ui/react-label": "^2.1.1",
    "@radix-ui/react-menubar": "^1.1.4",
    "@radix-ui/react-popover": "^1.1.4",
    "@radix-ui/react-progress": "^1.1.1",
    "@radix-ui/react-radio-group": "^1.2.2",
    "@radix-ui/react-scroll-area": "^1.2.2",
    "@radix-ui/react-select": "^2.1.4",
    "@radix-ui/react-separator": "^1.1.1",
    "@radix-ui/react-slider": "^1.2.2",
    "@radix-ui/react-slot": "^1.0.2",
    "@radix-ui/react-switch": "^1.1.2",
    "@radix-ui/react-tabs": "^1.1.2",
    "@radix-ui/react-toast": "^1.2.4",
    "@radix-ui/react-toggle": "^1.1.1",
    "@radix-ui/react-tooltip": "^1.1.6",
    "@supabase/ssr": "^0.5.2",
    "@supabase/supabase-js": "^2.47.12",
    "@tailwindcss/forms": "^0.5.10",
    "@tailwindcss/typography": "^0.5.16",
    "@tanstack/react-query-devtools": "^5.63.0",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cmdk": "^1.0.4",
    "date-fns": "^2.30.0",
    "embla-carousel-react": "^8.5.1",
    "geist": "^1.3.1",
    "lucide-react": "^0.292.0",
    "next": "^14.2.22",
    "next-themes": "^0.2.1",
    "openai": "^4.77.3",
    "react": "^18.3.1",
    "react-day-picker": "^8.10.1",
    "react-dom": "^18.3.1",
    "react-hook-form": "^7.54.2",
    "reactflow": "^11.11.4",
    "recharts": "^2.15.0",
    "sonner": "^1.7.1",
    "tailwind-merge": "^2.6.0",
    "tailwindcss-animate": "^1.0.7",
    "zod": "^3.24.1"
  },
  "devDependencies": {
    "@testing-library/jest-dom": "^6.6.3",
    "@testing-library/react": "^14.3.1",
    "@testing-library/user-event": "^14.5.2",
    "@types/jest": "^29.5.14",
    "@types/jest-axe": "^3.5.9",
    "@types/node": "^20.17.12",
    "@types/react": "^18.3.18",
    "@types/react-dom": "^18.3.5",
    "@types/uuid": "^10.0.0",
    "@vitejs/plugin-react": "^4.3.4",
    "autoprefixer": "^10.4.20",
    "dotenv-cli": "^8.0.0",
    "eslint": "^8.57.1",
    "eslint-config-next": "^14.2.22",
    "jest": "^29.7.0",
    "jest-axe": "^9.0.0",
    "jest-environment-jsdom": "^29.7.0",
    "jsdom": "^25.0.1",
    "msw": "^2.7.0",
    "node-mocks-http": "^1.16.2",
    "postcss": "^8.4.49",
    "rimraf": "^6.0.1",
    "supabase": "^2.2.1",
    "tailwindcss": "^3.4.17",
    "typescript": "^5.7.2",
    "vite-tsconfig-paths": "^5.1.4",
    "vitest": "^2.1.8"
  }
}
```

## Documentation

### AI Architecture

#### AI_AGENT_PROMPT.md

# AI Agent Implementation Guide

## Role and Context

You are an AI development agent working on the American Dream Taxes Hub, a Next.js application for tax practice automation. Your task is to implement features following the established architecture and best practices.

## Project Overview

- **Project**: American Dream Taxes Hub
- **Stack**: Next.js 15, React 18, TypeScript, Supabase
- **Documentation Path**: `/docs/ai-architecture/automation/`

## Implementation Guidelines

### 1. Before Starting

```typescript
// Always:
1. Review the feature requirements thoroughly
2. Check existing components and utilities
3. Follow TypeScript strict mode
4. Use React Server Components by default
5. Implement proper error handling
6. Add tests for new features
```

### 2. Code Standards

```typescript
// Follow these patterns:
1. Use TypeScript strict mode
2. Implement proper error boundaries
3. Add loading states
4. Include proper types
5. Add JSDoc comments
```

### 3. Component Structure

```typescript
// Example component structure
import { type FC } from "react";
import { type ComponentProps } from "@/types";

interface Props extends ComponentProps {
  // Define specific props
}

export const Component: FC<Props> = ({ prop1, prop2 }) => {
  // Implementation
};
```

### 4. Error Handling

```typescript
try {
  // Implementation
} catch (error) {
  // 1. Log error
  console.error("Error in component:", error);
  // 2. Show user-friendly message
  toast.error("An error occurred");
  // 3. Retry if appropriate
  retry();
}
```

### 5. Testing Requirements

```typescript
// Add tests for:
1. Component rendering
2. User interactions
3. Error states
4. Loading states
5. Edge cases
```

## Step-by-Step Implementation

1. **Review Documentation**

   - Check relevant guide in `/docs/ai-architecture/automation/`
   - Review specifications
   - Understand requirements

2. **Implementation**

   - Follow TypeScript patterns
   - Add proper error handling
   - Include loading states
   - Add comprehensive tests

3. **Testing**

   - Write unit tests
   - Add integration tests
   - Test error cases
   - Verify performance

4. **Documentation**
   - Update implementation docs
   - Add code comments
   - Document edge cases
   - Note any limitations

## Common Tasks

### 1. Adding New Components

```typescript
// 1. Create component file
// src/components/tax/TaxReturnForm.tsx
'use client'

import { useState } from 'react'
import { type FormProps } from '@/types'

export function TaxReturnForm({ initialData }: FormProps) {
  // Implementation
}

// 2. Add tests
// src/__tests__/components/TaxReturnForm.test.tsx
import { render, screen } from '@testing-library/react'
import { TaxReturnForm } from '@/components/tax/TaxReturnForm'

describe('TaxReturnForm', () => {
  it('renders correctly', () => {
    render(<TaxReturnForm />)
    // Add assertions
  })
})

// 3. Add to exports
// src/components/index.ts
export * from './tax/TaxReturnForm'
```

### 2. Adding New Features

```typescript
// 1. Review requirements
// 2. Create implementation plan
// 3. Follow documentation guides
// 4. Add tests
// 5. Update documentation
```

## Communication Guidelines

1. **When Stuck**

   - Review relevant documentation
   - Check existing implementations
   - Ask for clarification
   - Explain what you've tried

2. **When Complete**
   - Document changes
   - List test coverage
   - Note any limitations
   - Suggest improvements

## Checklist Before Submitting

```typescript
// Verify:
1. TypeScript strict mode passes
2. All tests pass
3. Error handling implemented
4. Loading states added
5. Documentation updated
6. Performance checked
```

## Example Implementation

```typescript
// Example feature implementation
import { useState } from "react";
import { useQuery } from "@tanstack/react-query";
import { toast } from "sonner";

interface TaxReturnData {
  id: string;
  year: number;
  status: string;
}

export function useTaxReturns(clientId: string) {
  // 1. Proper typing
  const { data, error, isLoading } = useQuery<TaxReturnData[]>({
    queryKey: ["taxReturns", clientId],
    queryFn: async () => {
      try {
        const response = await fetch(`/api/tax-returns/${clientId}`);
        if (!response.ok) throw new Error("Failed to fetch");
        return response.json();
      } catch (error) {
        // 2. Error handling
        console.error("Error fetching tax returns:", error);
        toast.error("Failed to load tax returns");
        throw error;
      }
    },
  });

  // 3. Return loading state
  return { data, error, isLoading };
}
```

Remember:

1. Follow the documentation structure
2. Maintain code quality
3. Add proper tests
4. Update documentation
5. Consider edge cases

#### FULL_ACCESS_POLICY.md

# Full Access Policy Guide

## Overview

This document outlines our "Full Access" policy for all authenticated users. This is a deliberate architectural decision to maximize team collaboration and development speed.

## Core Principles

1. **Authentication Only**

   - Only check if a user is authenticated
   - No role-based restrictions
   - No complex permissions

2. **Full CRUD Access**

   - All authenticated users can Create, Read, Update, and Delete
   - Access to all tables
   - No table-specific restrictions

3. **Simple Implementation**
   - Minimal authentication checks
   - No permission logic needed
   - Focus on feature development

## Implementation Examples

### Authentication Check

```typescript
// ‚úÖ CORRECT - Simple authentication check
const { user } = useSupabase();
if (!user) {
  throw new Error("Authentication required");
}

// ‚ùå INCORRECT - Don't check roles or permissions
if (user.role !== "admin") {
  throw new Error("Admin access required");
}
```

### Database Queries

```typescript
// ‚úÖ CORRECT - Direct table access
const { data } = await supabase.from("tax_returns").select("*");

// ‚ùå INCORRECT - Don't filter by user role/access
const { data } = await supabase
  .from("tax_returns")
  .select("*")
  .eq("assigned_to", user.id);
```

### UI Components

```typescript
// ‚úÖ CORRECT - Show all features
return (
  <div>
    <EditButton />
    <DeleteButton />
    <AssignButton />
  </div>
)

// ‚ùå INCORRECT - Don't hide features based on role
if (user.role === 'admin') {
  return <AdminPanel />
} else {
  return <UserPanel />
}
```

## Database Tables

All authenticated users have full access to:

- `clients`
- `tax_returns`
- `users`
- `projects`
- All future tables

## Error Handling

Only handle these cases:

1. User not authenticated
2. Operation failed (e.g., network error)
3. Invalid data format

Don't handle:

- Permission denied errors (shouldn't occur)
- Role-based restrictions (don't exist)
- Access level violations (not applicable)

## Benefits

1. **Faster Development**

   - No complex permission logic
   - Simpler testing
   - Faster feature iteration

2. **Better Collaboration**

   - No access barriers
   - Team members can help each other
   - Simplified workflow

3. **Reduced Complexity**
   - Simpler codebase
   - Fewer edge cases
   - Easier maintenance

## Remember

- Authentication is the only gate
- All authenticated users are trusted
- Focus on building features, not restrictions
- Keep it simple and collaborative

#### IMPLEMENTATION.md

# AI Document Analysis System Implementation Guide

## Directory Structure Creation

```bash
mkdir -p src/lib/ai/{config,processors,types,error,utils}
mkdir -p src/components/DocumentUpload
mkdir -p tests/lib/ai
mkdir -p supabase/migrations
```

## File Creation Sequence

1. Create configuration files:

```bash
touch src/lib/ai/config/index.ts
touch src/lib/ai/types/index.ts
touch src/lib/ai/error/index.ts
```

2. Create core processing files:

```bash
touch src/lib/ai/processors/documentProcessor.ts
touch src/lib/ai/processors/textExtractor.ts
touch src/lib/ai/processors/validationEngine.ts
```

3. Create frontend components:

```bash
touch src/components/DocumentUpload/AIProcessor.tsx
touch src/components/DocumentUpload/ProcessingStatus.tsx
touch src/components/DocumentUpload/ValidationDisplay.tsx
```

4. Create test files:

```bash
touch tests/lib/ai/documentProcessor.test.ts
touch tests/lib/ai/validationEngine.test.ts
touch tests/lib/ai/integration.test.ts
```

5. Create database migration:

```bash
touch supabase/migrations/00001_ai_document_processing.sql
```

## Implementation Order

1. **Core Infrastructure**

   - Implement config/index.ts
   - Implement types/index.ts
   - Implement error/index.ts
   - Create database tables

2. **Processing Pipeline**

   - Implement documentProcessor.ts
   - Implement textExtractor.ts
   - Implement validationEngine.ts

3. **Frontend Components**

   - Implement AIProcessor.tsx
   - Implement ProcessingStatus.tsx
   - Implement ValidationDisplay.tsx

4. **Testing**
   - Add unit tests
   - Add integration tests
   - Add E2E tests

## Code Review Checklist

- [ ] Type safety throughout the codebase
- [ ] Error handling for all async operations
- [ ] Input validation
- [ ] Security measures
- [ ] Performance considerations
- [ ] Test coverage
- [ ] Documentation

## Deployment Steps

1. Run database migrations:

```bash
pnpm supabase migration up
```

2. Update environment variables:

```bash
AI_MODEL_VERSION=
AI_MAX_TOKENS=
AI_TEMPERATURE=
```

3. Build and deploy:

```bash
pnpm build
pnpm deploy
```

## Monitoring Setup

1. Add logging for:

   - Document processing attempts
   - Processing successes/failures
   - Validation results
   - Performance metrics

2. Create alerts for:
   - High error rates
   - Processing delays
   - Resource utilization

## Testing Requirements

1. Unit Tests:

   - Document type detection
   - Data extraction
   - Validation rules
   - Error handling

2. Integration Tests:

   - Full processing pipeline
   - Database operations
   - API endpoints

3. E2E Tests:
   - Document upload flow
   - Processing status updates
   - Error handling UI
   - Validation display

## Performance Metrics

Monitor and optimize:

- Document processing time
- Memory usage
- API response times
- Database query performance

#### README.md

# AI Architecture Documentation

## Directory Structure

```
ai-architecture/
‚îú‚îÄ‚îÄ automation/               # Implementation guides
‚îÇ   ‚îú‚îÄ‚îÄ 00-MAIN.md          # Main overview and getting started
‚îÇ   ‚îú‚îÄ‚îÄ 01-AUTH.md          # Authentication implementation
‚îÇ   ‚îú‚îÄ‚îÄ 02-DATA.md          # Data layer implementation
‚îÇ   ‚îú‚îÄ‚îÄ 03-UI.md            # UI components implementation
‚îÇ   ‚îú‚îÄ‚îÄ 04-TESTING.md       # Testing strategy
‚îÇ   ‚îî‚îÄ‚îÄ 05-DEPLOYMENT.md    # Deployment guide
‚îî‚îÄ‚îÄ specifications/          # Technical specifications
```

## Getting Started

1. Begin with `automation/00-MAIN.md` for an overview
2. Follow the numbered guides in sequence
3. Each guide contains:
   - Overview
   - Implementation steps
   - Code examples
   - Testing requirements
   - Next steps

## Implementation Order

1. **Authentication System**

   - Follow `01-AUTH.md`
   - Implement security features
   - Set up role-based access

2. **Data Layer**

   - Follow `02-DATA.md`
   - Set up database
   - Implement data fetching

3. **UI Components**

   - Follow `03-UI.md`
   - Build core components
   - Implement forms

4. **Testing**

   - Follow `04-TESTING.md`
   - Add test coverage
   - Set up CI/CD

5. **Deployment**
   - Follow `05-DEPLOYMENT.md`
   - Configure infrastructure
   - Set up monitoring

## Development Workflow

1. **Review Documentation**

   - Start with relevant guide
   - Understand requirements
   - Check dependencies

2. **Implementation**

   - Follow step-by-step guides
   - Use provided code examples
   - Run tests frequently

3. **Testing**

   - Unit tests
   - Integration tests
   - E2E testing

4. **Deployment**
   - Build process
   - Deployment steps
   - Monitoring setup

## Maintenance

- Regular updates to documentation
- Keep code examples current
- Update dependencies
- Monitor performance

Below is a concise, plain-language overview of your application, its intended functionality, and how end users (both staff and clients) will interact with it. I‚Äôve also included examples of typical use-cases, plus a brief status update on how close we are to Phase 1 deployment.

1. What the App Is and Its Purpose
   Your application is a unified platform built specifically for an accounting and tax preparation firm. It combines:

CRM (Client Relationship Management) ‚Äì to manage new and existing clients, track communication, and centralize contact info.
Tax Preparation Workflow ‚Äì to handle the steps involved in preparing tax returns, from initial data gathering to final submission.
Project Management (PM) ‚Äì to track tasks, deadlines, document management, and team collaboration all in one place.
AI-Powered Automation ‚Äì to enhance everyday operations, such as quickly reviewing client data, generating suggestions, or automating parts of the document review process. 2. App Vision: End-to-End Accounting & Tax Workflow
2.1 Client Onboarding
Scenario: A new client signs up on your firm‚Äôs website or is referred by an existing client.
App Behavior:
The system triggers an onboarding workflow: prompts for basic client details, contact info, and relevant tax or accounting documents.
Once submitted, the data is automatically verified against the firm‚Äôs Supabase database (for correct formatting, required fields, etc.).
A project entry (or ticket) is then generated for the newly onboarded client, visible to the tax/accounting staff.
2.2 Document Management
Scenario: The client needs to upload financial statements, receipts, or tax forms (e.g., W-2, 1099).
App Behavior:
Clients upload documents securely through the portal or staff manually attach them on behalf of clients.
An AI-driven feature can automatically categorize documents, read partial data (like totals or dates), and store it in the database.
The status of each document (e.g., ‚Äúin review,‚Äù ‚Äúapproved,‚Äù ‚Äúneeds correction‚Äù) is tracked in real-time.
Staff can add internal notes or request additional data from the client directly within the system.
2.3 Tax Return Workflow
Scenario: It‚Äôs tax season, and staff are handling multiple returns at once.
App Behavior:
The system centralizes each client‚Äôs documents, enabling staff to see exactly what‚Äôs missing or pending.
Automated checks ensure the required documents are attached before finalizing the return.
AI Suggestions may surface potential deductions or data inconsistencies, flagging them for a quick manual review.
Once a return is prepared, staff or the client can approve it, triggering a final ‚Äúquality control‚Äù step before submission.
2.4 CRM & Project Management
Scenario: Tracking ongoing tasks, upcoming deadlines, or client follow-ups.
App Behavior:
Each staff member sees a task dashboard listing daily or weekly tasks.
Automated Reminders (via email or Slack) keep staff up to date on outstanding items.
Clients receive notifications when it‚Äôs time to provide new info, sign documents, or schedule a consultation.
A built-in collaboration feature allows staff to leave comments, share quick instructions, or escalate complex issues to senior staff.
2.5 AI Integration Examples
Document Analysis: AI can read the content of PDF invoices or tax forms to extract important data automatically.
Tax Advice: The system may offer ‚Äúsuggested improvements‚Äù to a client‚Äôs filing based on prior returns or common deductions.
Error Checking: AI flags potential errors, like mismatched totals or missing schedules, prompting staff to take a second look. 3. How End Users Interact with the System
Staff Users (accountants, tax preparers, project managers, etc.):

Login with secure credentials and land on a personal dashboard.
See an overview of pending tasks, upcoming deadlines, and alerts about client documents or queries.
Click into a client record to review uploaded documents, post comments, and finalize tax returns.
Use collaboration tools (comments, Slack integrations) to clarify tasks with colleagues.
Finalize returns or other deliverables, marking them as ‚Äúcomplete‚Äù or ‚Äúin QC.‚Äù
Clients:

Sign in or follow a secure link to review requests for documents or data.
Upload documents directly to their profile.
Receive AI-generated suggestions or checklists to ensure they‚Äôve provided all necessary info.
Track the status of their return or engagement with real-time updates. 4. Example User Journeys
Example A: New Client Setup
Client is referred by a friend and visits the firm‚Äôs website.
Onboarding form is completed.
Staff sees a new ‚ÄúOnboarding‚Äù ticket in the system.
AI runs a quick check: ensures the client has a valid ID, pulls in standard forms.
Staff is notified (via Slack or email) and steps in to schedule a consultation.
Example B: Document Request
Staff requests a missing document (e.g., payroll info) from the client.
Client receives a notification with a direct link.
Client uploads the document; the system auto-tags it and updates the ‚ÄúIn Progress‚Äù status.
Staff reviews the document in the system and changes status to ‚ÄúApproved,‚Äù moving the project forward.
Example C: Finalizing a Tax Return
Staff compiles the tax data, with the system automatically completing certain fields.
AI notices a mismatch in reported income vs. summarized documents‚Äîflags it for review.
Staff double-checks, corrects any errors, and marks the return as ‚ÄúQC Complete.‚Äù
Client reviews a summary, signs off digitally.
The system logs a final submission record and stores it in the client‚Äôs archive. 5. Phase 1 Deployment Readiness
Based on the recent code reviews and PROGRESS.md updates:

Core Features:

Client Onboarding: ~95% ready (just needs final validation checks).
Document Management: ~85% ready (some field naming mismatches resolved; good to go after final testing).
Tax Return Workflow: ~80% ready (functional end-to-end but requires a ‚ÄúQC pass/fail‚Äù step in the code).
CRM & Collaboration: ~90% ready (notifications, Slack integration, user dashboards mostly stable).
AI Automation: ~80% ready (core logic works, but fallback/error handling is being finalized).
Overall Phase 1 Completion: Roughly 85%-90% complete.

Key Remaining Steps:

Final bug fixes and validations for the onboarding flow.
Minor code refactors to ensure consistent AI fallback logic.
Adding or updating a QC/approval step in tax return workflows.
Final round of integration testing to confirm everything works well in tandem.
Expected Timeline
If the team focuses on the critical fixes (client validation, AI fallback, QC step) and runs a final integration test cycle, you could be ready to deploy Phase 1 in a matter of 1-2 sprints (assuming each sprint is ~2 weeks).

6. How This App Benefits Your Firm
   Consolidation: All client data, documents, tasks, and communications reside in a single, secure platform.
   Efficiency: Automated workflows and AI suggestions cut down on repetitive tasks, letting staff focus on more complex client needs.
   Collaboration: Built-in chat or Slack integration speeds up internal communication.
   Transparency: Clients can see their progress and know exactly what‚Äôs pending or approved‚Äîleading to higher satisfaction.
   Scalability: The system can handle more clients and more complex tax scenarios without exponentially increasing staff overhead.
   Final Takeaway
   You‚Äôre close to rolling out Phase 1 of a powerful platform that merges CRM, project management, and AI-driven accounting workflows in one place. Staff will gain an intuitive tool for handling client onboarding, document tracking, and tax return prep. Clients benefit from a transparent, guided experience. With a few more code refinements and final tests, you‚Äôll be ready to deploy an initial version that already offers significant benefits‚Äîand can be built upon for future enhancements.

#### 00-MAIN.md

# AI-Driven Tax Practice Automation Guide

## Overview

This guide provides a structured approach to implementing AI-driven automation in the American Dream Taxes Hub application.

## Implementation Steps

1. [Authentication & Security](./01-AUTH.md)

   - Enhanced authentication system
   - Role-based access control
   - Security implementations

2. [Data Layer & Management](./02-DATA.md)

   - Database structure
   - Data fetching hooks
   - Real-time updates

3. [UI Components](./03-UI.md)

   - Core components
   - Form handling
   - Data visualization

4. [Testing & Quality](./04-TESTING.md)

   - Unit testing
   - Integration testing
   - Performance testing

5. [Deployment & Monitoring](./05-DEPLOYMENT.md)
   - Build configuration
   - Deployment procedures
   - Monitoring setup

## Quick Start

1. Begin with the authentication system in `01-AUTH.md`
2. Implement data layer following `02-DATA.md`
3. Build UI components using `03-UI.md`
4. Add tests following `04-TESTING.md`
5. Deploy using `05-DEPLOYMENT.md`

## Current Status

‚úÖ Project structure ready
‚úÖ Basic authentication complete
‚úÖ Data layer core implementation complete
‚úÖ Basic UI components implemented
‚è≥ Advanced features in progress
üî≤ Testing pending
üî≤ Deployment pending

For detailed progress, see `/docs/implementation/PROGRESS.md`

#### 01-AUTH.md

# Authentication & Security Implementation

## Overview

This document outlines the authentication and security implementation for the tax practice automation system.

## Prerequisites

```bash
npm install @supabase/ssr@0.5.2 sonner@1.7.1
```

## Core Files Structure

```
src/
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îî‚îÄ‚îÄ supabase/
‚îÇ       ‚îú‚îÄ‚îÄ server.ts      # Server-side Supabase client
‚îÇ       ‚îî‚îÄ‚îÄ browser.ts     # Browser-side Supabase client
‚îú‚îÄ‚îÄ hooks/
‚îÇ   ‚îî‚îÄ‚îÄ use-auth.ts        # Authentication hook
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ auth/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ login-form.tsx # Login form component
‚îÇ   ‚îî‚îÄ‚îÄ role-guard.tsx     # Role-based access control
‚îî‚îÄ‚îÄ middleware.ts          # Authentication middleware
```

## Security Requirements

- Role-based access control (RBAC)
- Secure session management
- Row Level Security (RLS)
- API route protection
- Environment variable protection

## Implementation Steps

### 1. Server Client Setup

```typescript
// src/lib/supabase/server.ts
import { createServerClient } from "@supabase/ssr";
import { cookies } from "next/headers";

export function createClient() {
  const cookieStore = cookies();
  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
      },
    },
  );
}
```

### 2. Browser Client Setup

```typescript
// src/lib/supabase/browser.ts
import { createBrowserClient } from "@supabase/ssr";

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
  );
}
```

### 3. Authentication Hook

```typescript
// src/hooks/use-auth.ts
"use client";

import { createBrowserClient } from "@supabase/ssr";
import { useRouter } from "next/navigation";
import { useEffect, useState } from "react";
import type { User } from "@supabase/supabase-js";

export function useAuth() {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const router = useRouter();

  // ... rest of implementation
}
```

### 4. Role Guard Component

```typescript
// src/components/role-guard.tsx
"use client";

import { useAuth } from "@/hooks/use-auth";
import { ReactNode } from "react";

export function RoleGuard({
  children,
  allowedRoles,
  fallback = null,
}: {
  children: ReactNode;
  allowedRoles: string[];
  fallback?: ReactNode;
}) {
  // ... implementation
}
```

## Database Security

### Row Level Security Policies

```sql
-- Enable RLS
ALTER TABLE clients ENABLE ROW LEVEL SECURITY;
ALTER TABLE projects ENABLE ROW LEVEL SECURITY;
ALTER TABLE tasks ENABLE ROW LEVEL SECURITY;

-- Create policies
CREATE POLICY "Users can view assigned clients"
  ON clients FOR SELECT
  USING (auth.uid() IN (
    SELECT user_id FROM client_assignments WHERE client_id = id
  ));
```

## Testing

### Unit Tests

```typescript
// src/__tests__/hooks/use-auth.test.tsx
import { renderHook } from "@testing-library/react";
import { useAuth } from "@/hooks/use-auth";

describe("useAuth", () => {
  // ... test cases
});
```

### Security Tests

- Session management
- Role-based access
- API route protection
- SQL injection prevention
- XSS protection

## Validation Steps

1. Verify authentication flow
2. Test role-based access
3. Check error handling
4. Run test suite
5. Verify security headers
6. Test API route protection

## Rollback Procedure

1. Revert to previous implementation
2. Remove new dependencies
3. Restore original configuration
4. Verify security policies

## Common Issues

1. Module not found errors
   - Check import paths
   - Verify dependencies installed
2. Configuration warnings
   - Review Next.js version compatibility
   - Update experimental features
3. Authentication errors
   - Check environment variables
   - Verify Supabase project setup

## Security Best Practices

1. Always use HTTPS
2. Implement proper CORS policies
3. Use secure session cookies
4. Implement rate limiting
5. Regular security audits
6. Keep dependencies updated

#### 02-DATA.md

# Data Layer Implementation

## Overview

Implementation guide for the data layer, focusing on tax practice management and automation.

## Database Schema

### Core Tables

```sql
-- Clients
CREATE TABLE clients (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  tax_id TEXT,
  contact_info JSONB,
  status TEXT DEFAULT 'active',
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Tax Returns
CREATE TABLE tax_returns (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  client_id UUID REFERENCES clients(id),
  tax_year INTEGER NOT NULL,
  status TEXT DEFAULT 'draft',
  assigned_to UUID REFERENCES auth.users(id),
  due_date TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Documents
CREATE TABLE documents (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  tax_return_id UUID REFERENCES tax_returns(id),
  name TEXT NOT NULL,
  status TEXT DEFAULT 'pending',
  processed_by_ai BOOLEAN DEFAULT false,
  content_extracted JSONB,
  created_at TIMESTAMPTZ DEFAULT NOW()
);
```

## Data Fetching Hooks

### Client Management

```typescript
// src/hooks/useClients.ts
export function useClients() {
  const queryClient = useQueryClient();

  return useQuery({
    queryKey: ["clients"],
    queryFn: async () => {
      const { data, error } = await supabase.from("clients").select("*");
      if (error) throw error;
      return data;
    },
  });
}
```

### Tax Return Management

```typescript
// src/hooks/useTaxReturns.ts
export function useTaxReturns(clientId: string) {
  return useQuery({
    queryKey: ["taxReturns", clientId],
    queryFn: async () => {
      const { data, error } = await supabase
        .from("tax_returns")
        .select(
          `
          *,
          client:clients(name),
          assigned:profiles(name)
        `,
        )
        .eq("client_id", clientId);
      if (error) throw error;
      return data;
    },
  });
}
```

## AI Integration

```typescript
// src/lib/ai/document-processing.ts
export async function processDocument(document: File, taxReturnId: string) {
  // Document processing implementation
  // 1. Upload document
  // 2. Extract information
  // 3. Update database
}
```

## Files to Create/Update

1. Database:

   - `supabase/migrations/[timestamp]_initial_schema.sql`
   - `supabase/migrations/[timestamp]_add_ai_processing.sql`

2. Hooks:

   - `src/hooks/useClients.ts`
   - `src/hooks/useTaxReturns.ts`
   - `src/hooks/useDocuments.ts`

3. AI Processing:
   - `src/lib/ai/document-processing.ts`
   - `src/lib/ai/tax-analysis.ts`

## Testing

```typescript
// src/__tests__/hooks/useTaxReturns.test.ts
describe("useTaxReturns", () => {
  it("fetches tax returns for client", async () => {
    // Test implementation
  });
});
```

## Next Steps

After implementing the data layer:

1. Move to [UI Component Implementation](./03-UI.md)
2. Set up real-time updates
3. Add data validation

#### 03-UI.md

# UI Components Implementation

## Overview

Implementation guide for the UI components of the tax practice automation system.

## Component Structure

```typescript
src/components/
‚îú‚îÄ‚îÄ tax/                 # Tax-specific components
‚îÇ   ‚îú‚îÄ‚îÄ TaxReturnList
‚îÇ   ‚îú‚îÄ‚îÄ DocumentUpload
‚îÇ   ‚îî‚îÄ‚îÄ ClientOverview
‚îú‚îÄ‚îÄ shared/              # Shared components
‚îÇ   ‚îú‚îÄ‚îÄ DataGrid
‚îÇ   ‚îú‚îÄ‚îÄ Forms
‚îÇ   ‚îî‚îÄ‚îÄ Navigation
‚îî‚îÄ‚îÄ ai/                  # AI-specific components
    ‚îú‚îÄ‚îÄ ProcessingStatus
    ‚îî‚îÄ‚îÄ AnalysisResults
```

## Core Components

### Tax Return List

```typescript
// src/components/tax/TaxReturnList.tsx
export function TaxReturnList({ clientId }: { clientId: string }) {
  const { data, isLoading } = useTaxReturns(clientId)

  return (
    <DataGrid
      data={data}
      columns={[
        { field: 'tax_year', header: 'Year' },
        { field: 'status', header: 'Status' },
        { field: 'due_date', header: 'Due Date' },
        {
          field: 'actions',
          header: 'Actions',
          render: (row) => (
            <ActionButtons taxReturn={row} />
          )
        }
      ]}
    />
  )
}
```

### Document Upload

```typescript
// src/components/tax/DocumentUpload.tsx
export function DocumentUpload({
  taxReturnId
}: {
  taxReturnId: string
}) {
  const handleUpload = async (files: FileList) => {
    // Implementation
  }

  return (
    <DropZone onDrop={handleUpload}>
      <UploadInstructions />
      <ProcessingStatus />
    </DropZone>
  )
}
```

### AI Processing Status

```typescript
// src/components/ai/ProcessingStatus.tsx
export function ProcessingStatus({
  documentId
}: {
  documentId: string
}) {
  const { status, progress } = useProcessingStatus(documentId)

  return (
    <div>
      <ProgressBar value={progress} />
      <StatusMessage status={status} />
    </div>
  )
}
```

## Form Components

### Tax Return Form

```typescript
// src/components/tax/TaxReturnForm.tsx
export function TaxReturnForm({
  clientId
}: {
  clientId: string
}) {
  const form = useForm({
    defaultValues: {
      tax_year: new Date().getFullYear(),
      status: 'draft',
      client_id: clientId
    }
  })

  return (
    <Form {...form}>
      <FormField
        name="tax_year"
        label="Tax Year"
        component={Select}
        options={getTaxYears()}
      />
      {/* Other fields */}
    </Form>
  )
}
```

## Layout Components

### Dashboard Layout

```typescript
// src/components/layouts/DashboardLayout.tsx
export function DashboardLayout({
  children
}: {
  children: React.ReactNode
}) {
  return (
    <div className="flex min-h-screen">
      <Sidebar />
      <main className="flex-1 p-6">
        {children}
      </main>
    </div>
  )
}
```

## Integration with AI Features

### Analysis Results

```typescript
// src/components/ai/AnalysisResults.tsx
export function AnalysisResults({
  documentId
}: {
  documentId: string
}) {
  const { data } = useDocumentAnalysis(documentId)

  return (
    <div>
      <SummaryCard data={data.summary} />
      <DetailsList items={data.details} />
      <ActionButtons actions={data.recommendations} />
    </div>
  )
}
```

## Files to Create/Update

1. Core Components:

   - `src/components/tax/TaxReturnList.tsx`
   - `src/components/tax/DocumentUpload.tsx`
   - `src/components/ai/ProcessingStatus.tsx`

2. Forms:

   - `src/components/tax/TaxReturnForm.tsx`
   - `src/components/client/ClientForm.tsx`

3. Layouts:
   - `src/components/layouts/DashboardLayout.tsx`
   - `src/components/layouts/AuthLayout.tsx`

## Testing

```typescript
// src/__tests__/components/TaxReturnList.test.tsx
describe("TaxReturnList", () => {
  it("renders tax returns correctly", () => {
    // Test implementation
  });

  it("handles actions properly", () => {
    // Test implementation
  });
});
```

## Next Steps

After implementing UI components:

1. Move to [Testing Implementation](./04-TESTING.md)
2. Add error boundaries
3. Implement loading states

#### 04-TESTING.md

# Testing Implementation Guide

## Overview

Comprehensive testing strategy for the tax practice automation system.

## Test Structure

```typescript
tests/
‚îú‚îÄ‚îÄ unit/                 # Unit tests
‚îÇ   ‚îú‚îÄ‚îÄ hooks/
‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îî‚îÄ‚îÄ utils/
‚îú‚îÄ‚îÄ integration/          # Integration tests
‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îú‚îÄ‚îÄ workflows/
‚îÇ   ‚îî‚îÄ‚îÄ ai/
‚îî‚îÄ‚îÄ e2e/                 # End-to-end tests
    ‚îú‚îÄ‚îÄ auth/
    ‚îú‚îÄ‚îÄ tax-returns/
    ‚îî‚îÄ‚îÄ documents/
```

## Unit Tests

### Hook Testing

```typescript
// tests/unit/hooks/useTaxReturns.test.ts
import { renderHook } from "@testing-library/react";
import { useTaxReturns } from "@/hooks/useTaxReturns";

describe("useTaxReturns", () => {
  it("fetches tax returns for client", async () => {
    const { result } = renderHook(() => useTaxReturns("client-id"));

    await waitFor(() => {
      expect(result.current.data).toBeDefined();
    });
  });

  it("handles errors correctly", async () => {
    // Mock error state
    server.use(
      rest.get("/api/tax-returns", (req, res, ctx) => {
        return res(ctx.status(500));
      }),
    );

    const { result } = renderHook(() => useTaxReturns("client-id"));

    await waitFor(() => {
      expect(result.current.error).toBeDefined();
    });
  });
});
```

### Component Testing

```typescript
// tests/unit/components/TaxReturnList.test.tsx
import { render, screen } from '@testing-library/react'
import { TaxReturnList } from '@/components/tax/TaxReturnList'

describe('TaxReturnList', () => {
  const mockData = [
    { id: 1, year: 2023, status: 'pending' },
    { id: 2, year: 2022, status: 'completed' }
  ]

  it('renders tax returns correctly', () => {
    render(<TaxReturnList data={mockData} />)
    expect(screen.getByText('2023')).toBeInTheDocument()
    expect(screen.getByText('2022')).toBeInTheDocument()
  })

  it('handles empty state', () => {
    render(<TaxReturnList data={[]} />)
    expect(screen.getByText(/no tax returns/i)).toBeInTheDocument()
  })
})
```

## Integration Tests

### API Testing

```typescript
// tests/integration/api/tax-returns.test.ts
import { createServer } from "@/test-utils/server";

describe("Tax Returns API", () => {
  let server: any;

  beforeAll(() => {
    server = createServer();
  });

  afterAll(() => {
    server.close();
  });

  it("creates tax return successfully", async () => {
    const response = await fetch("/api/tax-returns", {
      method: "POST",
      body: JSON.stringify({
        clientId: "test-client",
        year: 2023,
      }),
    });

    expect(response.status).toBe(201);
    const data = await response.json();
    expect(data.year).toBe(2023);
  });
});
```

### Workflow Testing

```typescript
// tests/integration/workflows/tax-return-workflow.test.ts
describe("Tax Return Workflow", () => {
  it("completes full tax return process", async () => {
    // 1. Create client
    const client = await createTestClient();

    // 2. Create tax return
    const taxReturn = await createTaxReturn(client.id);

    // 3. Upload documents
    const docs = await uploadDocuments(taxReturn.id);

    // 4. Process documents with AI
    await processDocuments(docs);

    // 5. Review and submit
    const submission = await submitTaxReturn(taxReturn.id);

    expect(submission.status).toBe("completed");
  });
});
```

## E2E Testing

### Playwright Tests

```typescript
// tests/e2e/tax-returns/create-tax-return.spec.ts
import { test, expect } from "@playwright/test";

test("create new tax return", async ({ page }) => {
  // 1. Login
  await loginUser(page);

  // 2. Navigate to create tax return
  await page.click("text=New Tax Return");

  // 3. Fill form
  await page.fill('[name="year"]', "2023");
  await page.selectOption('[name="type"]', "individual");

  // 4. Submit
  await page.click('button:text("Create")');

  // 5. Verify
  await expect(page.locator(".status")).toHaveText("Draft");
});
```

## Performance Testing

### Load Testing

```typescript
// tests/performance/api-load.test.ts
import { check } from "k6";
import http from "k6/http";

export const options = {
  vus: 10,
  duration: "30s",
};

export default function () {
  const res = http.get("http://localhost:3000/api/tax-returns");
  check(res, {
    "status is 200": (r) => r.status === 200,
    "response time < 200ms": (r) => r.timings.duration < 200,
  });
}
```

## Security Testing

### Auth Tests

```typescript
// tests/security/auth.test.ts
describe("Authentication Security", () => {
  it("prevents unauthorized access", async () => {
    const res = await fetch("/api/protected");
    expect(res.status).toBe(401);
  });

  it("validates JWT tokens", async () => {
    const invalidToken = "invalid.token.here";
    const res = await fetch("/api/protected", {
      headers: {
        Authorization: `Bearer ${invalidToken}`,
      },
    });
    expect(res.status).toBe(401);
  });
});
```

## Test Scripts

Add to package.json:

```json
{
  "scripts": {
    "test": "vitest",
    "test:unit": "vitest run src/__tests__/components",
    "test:integration": "vitest run src/__tests__/integration",
    "test:e2e": "playwright test",
    "test:coverage": "vitest run --coverage",
    "test:security": "vitest run src/__tests__/security",
    "test:performance": "k6 run tests/performance/**/*.ts"
  }
}
```

## Next Steps

After implementing testing:

1. Move to [Deployment Implementation](./05-DEPLOYMENT.md)
2. Set up CI/CD pipelines
3. Configure monitoring and alerts

#### 05-DEPLOYMENT.md

# Deployment and Infrastructure Guide

## Overview

Comprehensive deployment and infrastructure setup for the tax practice automation system.

## Infrastructure Setup

### Docker Configuration

```dockerfile
# Dockerfile
FROM node:20-alpine AS base

# Install dependencies
FROM base AS deps
RUN apk add --no-cache libc6-compat
WORKDIR /app
COPY package.json package-lock.json ./
RUN npm ci

# Build application
FROM base AS builder
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .
RUN npm run build

# Production image
FROM base AS runner
WORKDIR /app
ENV NODE_ENV production
COPY --from=builder /app/public ./public
COPY --from=builder /app/.next/standalone ./
COPY --from=builder /app/.next/static ./.next/static

USER nextjs
EXPOSE 3000
CMD ["node", "server.js"]
```

### Docker Compose

```yaml
# docker-compose.yml
version: "3.8"
services:
  web:
    build: .
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - NEXT_PUBLIC_SUPABASE_URL=${NEXT_PUBLIC_SUPABASE_URL}
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/health"]
      interval: 30s
      timeout: 10s
      retries: 3

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
      - ./ssl:/etc/nginx/ssl:ro
```

## CI/CD Pipeline

### GitHub Actions

```yaml
# .github/workflows/main.yml
name: CI/CD Pipeline

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: "20"

      - name: Install dependencies
        run: npm ci

      - name: Run tests
        run: npm test

  deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Build and push Docker image
        run: |
          docker build -t tax-practice-app .
          docker push ${{ secrets.ECR_REGISTRY }}/tax-practice-app:latest
```

## Infrastructure as Code

### Terraform Configuration

```hcl
# main.tf
provider "aws" {
  region = "us-east-1"
}

module "vpc" {
  source = "terraform-aws-modules/vpc/aws"
  name   = "tax-practice-vpc"
  cidr   = "10.0.0.0/16"

  azs             = ["us-east-1a", "us-east-1b"]
  private_subnets = ["10.0.1.0/24", "10.0.2.0/24"]
  public_subnets  = ["10.0.101.0/24", "10.0.102.0/24"]
}

module "ecs" {
  source = "terraform-aws-modules/ecs/aws"

  cluster_name = "tax-practice-cluster"

  fargate_capacity_providers = {
    FARGATE = {
      default_capacity_provider_strategy = {
        weight = 100
      }
    }
  }
}
```

## Monitoring Setup

### Application Monitoring

```typescript
// src/lib/monitoring.ts
import { init as initApm } from "@elastic/apm-rum";

export function setupMonitoring() {
  if (process.env.NODE_ENV === "production") {
    initApm({
      serviceName: "tax-practice-app",
      serverUrl: process.env.APM_SERVER_URL,
      environment: process.env.NODE_ENV,
    });
  }
}
```

### Health Checks

```typescript
// src/app/api/health/route.ts
import { NextResponse } from "next/server";
import { createClient } from "@/lib/supabase-server";

export async function GET() {
  try {
    const supabase = createClient();
    const { data, error } = await supabase.from("health_check").select("*");

    if (error) throw error;

    return NextResponse.json({
      status: "healthy",
      timestamp: new Date().toISOString(),
    });
  } catch (error) {
    return NextResponse.json(
      { status: "unhealthy", error: error.message },
      { status: 500 },
    );
  }
}
```

## Security Configuration

### Security Headers

```typescript
// next.config.js
module.exports = {
  async headers() {
    return [
      {
        source: "/:path*",
        headers: [
          {
            key: "Content-Security-Policy",
            value: "default-src 'self'",
          },
          {
            key: "X-Frame-Options",
            value: "DENY",
          },
        ],
      },
    ];
  },
};
```

## Environment Variables

### Production Environment

```bash
# .env.production
NODE_ENV=production
NEXT_PUBLIC_SUPABASE_URL=your_production_url
NEXT_PUBLIC_SUPABASE_ANON_KEY=your_production_key
APM_SERVER_URL=your_apm_url
```

## Backup Strategy

### Database Backups

```bash
#!/bin/bash
# scripts/backup-db.sh

TODAY=$(date +"%Y%m%d")
BACKUP_DIR="/backups/database"

# Create backup
pg_dump $DATABASE_URL > "$BACKUP_DIR/backup-$TODAY.sql"

# Cleanup old backups (keep last 7 days)
find $BACKUP_DIR -type f -mtime +7 -delete
```

## Deployment Steps

1. Prepare Environment

```bash
# Install dependencies
npm ci

# Build application
npm run build
```

2. Run Database Migrations

```bash
# Apply migrations
supabase db push

# Verify migrations
supabase db verify
```

3. Deploy Infrastructure

```bash
# Initialize Terraform
terraform init

# Apply infrastructure changes
terraform apply
```

4. Deploy Application

```bash
# Build and push Docker image
docker build -t tax-practice-app .
docker push your-registry/tax-practice-app:latest

# Deploy to ECS
aws ecs update-service --cluster tax-practice --service web --force-new-deployment
```

## Post-Deployment Verification

1. Health Check

```bash
curl https://your-domain.com/api/health
```

2. Monitor Logs

```bash
# View application logs
aws logs get-log-events \
  --log-group-name /aws/ecs/tax-practice \
  --log-stream-name web
```

3. Performance Verification

```bash
# Run performance tests
npm run test:performance
```

## Rollback Procedure

1. Identify Issue

```bash
# Check logs for errors
aws logs get-log-events \
  --log-group-name /aws/ecs/tax-practice \
  --log-stream-name web
```

2. Rollback Deployment

```bash
# Rollback to previous version
aws ecs update-service \
  --cluster tax-practice \
  --service web \
  --task-definition tax-practice:previous
```

3. Verify Rollback

```bash
# Check health endpoint
curl https://your-domain.com/api/health
```

## Next Steps

1. Set up monitoring alerts
2. Configure automatic scaling
3. Implement disaster recovery plan

#### PART-A-TECHNICAL.md

# Part A: Technical Implementation Guide

## Overview

This guide covers the technical implementation of the American Dream Taxes Hub, focusing on the core architecture and components needed to support the firm's SOPs.

## Table of Contents

1. [Core Architecture](#core-architecture)
2. [Database Implementation](#database-implementation)
3. [Component Structure](#component-structure)
4. [API Routes](#api-routes)
5. [Testing Framework](#testing-framework)

## Core Architecture

### Project Structure

```bash
src/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ (auth)/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ login/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ register/
‚îÇ   ‚îú‚îÄ‚îÄ (dashboard)/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ clients/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ documents/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ projects/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ tax-returns/
‚îÇ   ‚îî‚îÄ‚îÄ api/
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ clients/
‚îÇ   ‚îú‚îÄ‚îÄ documents/
‚îÇ   ‚îú‚îÄ‚îÄ projects/
‚îÇ   ‚îú‚îÄ‚îÄ tax-returns/
‚îÇ   ‚îî‚îÄ‚îÄ ui/
‚îú‚îÄ‚îÄ hooks/
‚îú‚îÄ‚îÄ lib/
‚îî‚îÄ‚îÄ types/
```

### Key Technologies

- Next.js 14 with App Router
- Supabase (Database & Auth)
- TanStack Query for data fetching
- Zod for validation
- Tailwind CSS for styling
- Jest & Testing Library for testing

## Component Implementation

### 1. Client Management

#### Client Dashboard Component

```typescript
// src/app/(dashboard)/clients/page.tsx
import { Suspense } from 'react'
import { ClientList } from '@/components/clients/client-list'
import { ClientFilters } from '@/components/clients/client-filters'
import { ClientStats } from '@/components/clients/client-stats'
import { LoadingSpinner } from '@/components/ui/loading'

export default function ClientsPage() {
  return (
    <div className="space-y-6">
      <ClientStats />
      <ClientFilters />
      <Suspense fallback={<LoadingSpinner />}>
        <ClientList />
      </Suspense>
    </div>
  )
}
```

#### Client List with Real-time Updates

```typescript
// src/components/clients/client-list.tsx
'use client'

import { useQuery } from '@tanstack/react-query'
import { useSupabase } from '@/hooks/use-supabase'
import { ClientCard } from './client-card'
import type { Client } from '@/types/database.types'

export function ClientList() {
  const { supabase } = useSupabase()

  const { data: clients } = useQuery({
    queryKey: ['clients'],
    queryFn: async () => {
      const { data, error } = await supabase
        .from('clients')
        .select(`
          *,
          tax_returns(count),
          documents(count)
        `)
        .order('created_at', { ascending: false })

      if (error) throw error
      return data as Client[]
    }
  })

  return (
    <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
      {clients?.map((client) => (
        <ClientCard key={client.id} client={client} />
      ))}
    </div>
  )
}
```

### 2. Document Processing

#### Document Upload Component

```typescript
// src/components/documents/document-upload.tsx
'use client'

import { useCallback } from 'react'
import { useDropzone } from 'react-dropzone'
import { useSupabase } from '@/hooks/use-supabase'
import { useDocuments } from '@/hooks/use-documents'
import { processDocument } from '@/lib/ai/document-processor'

export function DocumentUpload({ clientId }: { clientId: string }) {
  const { uploadDocument } = useDocuments(clientId)

  const onDrop = useCallback(async (files: File[]) => {
    for (const file of files) {
      // 1. Process with AI
      const analysis = await processDocument(file)

      // 2. Upload file and create record
      await uploadDocument.mutateAsync({
        file,
        metadata: {
          clientId,
          category: analysis.documentType,
          extractedData: analysis.data
        }
      })
    }
  }, [clientId, uploadDocument])

  const { getRootProps, getInputProps, isDragActive } = useDropzone({ onDrop })

  return (
    <div
      {...getRootProps()}
      className={`
        border-2 border-dashed rounded-lg p-8 text-center
        ${isDragActive ? 'border-primary bg-primary/10' : 'border-border'}
      `}
    >
      <input {...getInputProps()} />
      <p>Drag and drop files here or click to select</p>
    </div>
  )
}
```

### 3. Project Management

#### Project Dashboard

```typescript
// src/components/projects/dashboard.tsx
'use client'

import { useState } from 'react'
import { ProjectList } from './project-list'
import { ProjectFilters } from './project-filters'
import { ProjectStats } from './project-stats'
import { ProjectSort } from './project-sort'
import type { Project } from '@/types/database.types'

const sortOptions = {
  'due-date': (a: Project, b: Project) =>
    new Date(a.due_date) - new Date(b.due_date),
  'priority': (a: Project, b: Project) =>
    priorityWeight[b.priority] - priorityWeight[a.priority]
}

export function ProjectDashboard() {
  const [sortBy, setSortBy] = useState('due-date')
  const [filters, setFilters] = useState({})

  return (
    <div className="space-y-6">
      <div className="flex justify-between">
        <ProjectFilters onChange={setFilters} />
        <ProjectSort value={sortBy} onChange={setSortBy} />
      </div>
      <ProjectStats />
      <ProjectList sortBy={sortBy} filters={filters} />
    </div>
  )
}
```

### 4. Tax Return Processing

#### Tax Return Workspace

```typescript
// src/components/tax-returns/workspace.tsx
'use client'

import { useQuery } from '@tanstack/react-query'
import { useSupabase } from '@/hooks/use-supabase'
import { DocumentList } from './document-list'
import { WorkflowStatus } from './workflow-status'
import { ReturnDetails } from './return-details'
import type { TaxReturn } from '@/types/database.types'

export function TaxReturnWorkspace({
  returnId
}: {
  returnId: string
}) {
  const { supabase } = useSupabase()

  const { data: taxReturn } = useQuery({
    queryKey: ['tax-returns', returnId],
    queryFn: async () => {
      const { data, error } = await supabase
        .from('tax_returns')
        .select(`
          *,
          client:clients(*),
          documents:documents(*),
          tasks:tasks(*)
        `)
        .eq('id', returnId)
        .single()

      if (error) throw error
      return data as TaxReturn
    }
  })

  if (!taxReturn) return null

  return (
    <div className="grid grid-cols-12 gap-6">
      <div className="col-span-8">
        <ReturnDetails taxReturn={taxReturn} />
        <DocumentList documents={taxReturn.documents} />
      </div>
      <div className="col-span-4">
        <WorkflowStatus
          status={taxReturn.status}
          tasks={taxReturn.tasks}
        />
      </div>
    </div>
  )
}
```

## API Routes

### 1. Document Processing API

```typescript
// src/app/api/documents/process/route.ts
import { createRouteHandlerClient } from "@supabase/ssr";
import { cookies } from "next/headers";

export async function POST(request: Request) {
  const supabase = createRouteHandlerClient({ cookies });
  const formData = await request.formData();
  const file = formData.get("file") as File;

  try {
    // 1. Process with AI
    const extractedData = await processDocumentWithAI(file);

    // 2. Store results
    const { data, error } = await supabase
      .from("documents")
      .insert({
        file_name: file.name,
        extracted_data: extractedData,
        processing_status: "completed",
      })
      .select()
      .single();

    if (error) throw error;

    return Response.json(data);
  } catch (error) {
    return Response.json({ error: error.message }, { status: 500 });
  }
}
```

### 2. Tax Return Analysis API

```typescript
// src/app/api/tax-returns/analyze/route.ts
import { createRouteHandlerClient } from "@supabase/ssr";
import { cookies } from "next/headers";

export async function POST(request: Request) {
  const supabase = createRouteHandlerClient({ cookies });
  const { returnId } = await request.json();

  try {
    // 1. Get tax return data
    const { data: taxReturn } = await supabase
      .from("tax_returns")
      .select(
        `
        *,
        documents(*)
      `,
      )
      .eq("id", returnId)
      .single();

    // 2. Analyze with AI
    const analysis = await analyzeTaxReturnWithAI(taxReturn);

    // 3. Store results
    const { data, error } = await supabase
      .from("tax_returns")
      .update({
        ai_analysis: analysis,
        analysis_status: "completed",
        last_analyzed_at: new Date().toISOString(),
      })
      .eq("id", returnId)
      .select()
      .single();

    if (error) throw error;

    return Response.json(data);
  } catch (error) {
    return Response.json({ error: error.message }, { status: 500 });
  }
}
```

## Testing Framework

### 1. Component Testing

```typescript
// src/components/documents/__tests__/document-upload.test.tsx
import { render, screen, fireEvent } from '@testing-library/react'
import { DocumentUpload } from '../document-upload'
import { useDocuments } from '@/hooks/use-documents'

jest.mock('@/hooks/use-documents')

describe('DocumentUpload', () => {
  it('handles file uploads correctly', async () => {
    const mockUpload = jest.fn()
    ;(useDocuments as jest.Mock).mockReturnValue({
      uploadDocument: {
        mutateAsync: mockUpload
      }
    })

    render(<DocumentUpload clientId="123" />)

    const file = new File(['test'], 'test.pdf', { type: 'application/pdf' })
    const input = screen.getByRole('button')

    await fireEvent.drop(input, {
      dataTransfer: {
        files: [file]
      }
    })

    expect(mockUpload).toHaveBeenCalledWith(expect.objectContaining({
      file,
      metadata: expect.any(Object)
    }))
  })
})
```

### 2. API Route Testing

```typescript
// src/app/api/__tests__/documents.test.ts
import { createRouteHandlerClient } from "@supabase/ssr";
import { POST } from "../documents/process/route";

jest.mock("@supabase/ssr");

describe("Document Processing API", () => {
  it("processes documents correctly", async () => {
    const mockInsert = jest.fn().mockResolvedValue({
      data: { id: "123" },
      error: null,
    });

    (createRouteHandlerClient as jest.Mock).mockReturnValue({
      from: () => ({
        insert: mockInsert,
        select: () => ({
          single: () => mockInsert(),
        }),
      }),
    });

    const formData = new FormData();
    formData.append("file", new File(["test"], "test.pdf"));

    const response = await POST(
      new Request("http://localhost", {
        method: "POST",
        body: formData,
      }),
    );

    expect(response.status).toBe(200);
    const data = await response.json();
    expect(data).toHaveProperty("id");
  });
});
```

### 3. Integration Testing

```typescript
// src/tests/integration/tax-workflow.test.ts
import { test, expect } from "@playwright/test";

test.describe("Tax Return Workflow", () => {
  test("complete tax return workflow", async ({ page }) => {
    // 1. Create new tax return
    await page.goto("/tax-returns/new");
    await page.fill('[name="client_id"]', "test-client");
    await page.fill('[name="tax_year"]', "2024");
    await page.click('button[type="submit"]');

    // 2. Upload documents
    await page.setInputFiles('input[type="file"]', "test-docs/w2.pdf");
    await expect(page.getByText("Processing...")).toBeVisible();
    await expect(page.getByText("Completed")).toBeVisible();

    // 3. Verify workflow progress
    await expect(page.getByText("Documents Received")).toHaveClass(/completed/);

    // 4. Complete review
    await page.click('[data-testid="complete-review"]');
    await expect(page.getByText("Ready for Filing")).toBeVisible();
  });
});
```

## AI Integration Points

### 1. Document Analysis

```typescript
// src/lib/ai/document-analysis.ts
import { type AnalysisResult } from "@/types/ai";

export async function analyzeDocument(document: File): Promise<AnalysisResult> {
  // 1. Convert document to text/data
  const documentData = await prepareDocumentData(document);

  // 2. Send to AI service
  const response = await fetch("/api/ai/analyze", {
    method: "POST",
    body: JSON.stringify({ documentData }),
  });

  // 3. Process and validate results
  const result = await response.json();
  return validateAnalysisResult(result);
}

function validateAnalysisResult(
  result: unknown,
): asserts result is AnalysisResult {
  // Add validation logic here
}
```

### 2. Tax Return Automation

```typescript
// src/lib/ai/tax-automation.ts
import { type TaxReturn, type AIRecommendation } from "@/types/tax";

export async function generateTaxRecommendations(
  taxReturn: TaxReturn,
): Promise<AIRecommendation[]> {
  // 1. Gather all relevant data
  const data = await aggregateTaxData(taxReturn);

  // 2. Generate recommendations
  const recommendations = await fetch("/api/ai/tax-recommendations", {
    method: "POST",
    body: JSON.stringify(data),
  }).then((res) => res.json());

  // 3. Validate and process recommendations
  return processTaxRecommendations(recommendations);
}
```

## Real-time Features

### 1. Task Updates

```typescript
// src/hooks/use-real-time-tasks.ts
import { useEffect } from "react";
import { useQueryClient } from "@tanstack/react-query";
import { useSupabase } from "./use-supabase";

export function useRealTimeTasks(projectId: string) {
  const { supabase } = useSupabase();
  const queryClient = useQueryClient();

  useEffect(() => {
    const channel = supabase
      .channel(`project-${projectId}`)
      .on(
        "postgres_changes",
        {
          event: "*",
          schema: "public",
          table: "tasks",
          filter: `project_id=eq.${projectId}`,
        },
        (payload) => {
          queryClient.invalidateQueries(["tasks", projectId]);
        },
      )
      .subscribe();

    return () => {
      supabase.removeChannel(channel);
    };
  }, [projectId, supabase, queryClient]);
}
```

### 2. Document Status Updates

```typescript
// src/hooks/use-real-time-documents.ts
import { useEffect } from "react";
import { useQueryClient } from "@tanstack/react-query";
import { useSupabase } from "./use-supabase";

export function useRealTimeDocuments(clientId: string) {
  const { supabase } = useSupabase();
  const queryClient = useQueryClient();

  useEffect(() => {
    const channel = supabase
      .channel(`client-${clientId}`)
      .on(
        "postgres_changes",
        {
          event: "*",
          schema: "public",
          table: "documents",
          filter: `client_id=eq.${clientId}`,
        },
        (payload) => {
          queryClient.invalidateQueries(["documents", clientId]);
        },
      )
      .subscribe();

    return () => {
      supabase.removeChannel(channel);
    };
  }, [clientId, supabase, queryClient]);
}
```

## Deployment Configuration

### 1. Environment Variables

```env
# Supabase Configuration
NEXT_PUBLIC_SUPABASE_URL=your-project-url
NEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key
SUPABASE_SERVICE_ROLE_KEY=your-service-role-key

# AI Service Configuration
AI_SERVICE_URL=your-ai-service-url
AI_SERVICE_KEY=your-ai-service-key

# Application Configuration
NEXT_PUBLIC_APP_URL=https://your-app-url.com
NODE_ENV=production
```

### 2. Build Configuration

```json
// next.config.js
/** @type {import('next').NextConfig} */
const nextConfig = {
  experimental: {
    serverActions: true,
    serverComponents: true,
  },
  images: {
    domains: ['your-storage-domain.com'],
  },
}

module.exports = nextConfig
```

## Security Considerations

### 1. Authentication Middleware

```typescript
// src/middleware.ts
import { createMiddlewareClient } from "@supabase/auth-helpers-nextjs";
import { NextResponse } from "next/server";
import type { NextRequest } from "next/server";

export async function middleware(request: NextRequest) {
  const res = NextResponse.next();
  const supabase = createMiddlewareClient({ req: request, res });

  const {
    data: { session },
  } = await supabase.auth.getSession();

  if (!session && !request.nextUrl.pathname.startsWith("/auth")) {
    return NextResponse.redirect(new URL("/auth/login", request.url));
  }

  return res;
}

export const config = {
  matcher: ["/((?!_next/static|_next/image|favicon.ico|auth/*).*)"],
};
```

### 2. API Rate Limiting

```typescript
// src/lib/rate-limit.ts
import rateLimit from "express-rate-limit";

export const rateLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // limit each IP to 100 requests per windowMs
});
```

## Next Steps for Technical Implementation

1. Complete component implementation
2. Add comprehensive error handling
3. Implement all real-time features
4. Add full test coverage
5. Configure CI/CD pipeline

---

See [Part B: SOP Implementation](./PART-B.md) for business process implementation details.

#### PART-B-SOPS.md

# Part B: SOP Implementation Guide

## Overview

This guide details how the technical components from Part A implement each Standard Operating Procedure (SOP) for the accounting firm.

## Table of Contents

1. [Client Onboarding Implementation](#client-onboarding-implementation)
2. [Document Management Implementation](#document-management-implementation)
3. [Tax Return Workflow Implementation](#tax-return-workflow-implementation)
4. [Bookkeeping Process Implementation](#bookkeeping-process-implementation)
5. [Quality Control Implementation](#quality-control-implementation)

## Client Onboarding Implementation

### 1. Initial Contact & Information Gathering

```typescript
// src/components/clients/onboarding/InitialContact.tsx
interface OnboardingState {
  step: number
  clientData: ClientData
  documents: Document[]
}

export function InitialContact() {
  const [state, dispatch] = useOnboardingStore()
  const form = useForm<ClientContactForm>({
    resolver: zodResolver(clientContactSchema)
  })

  return (
    <Form {...form}>
      <CardTitle>Initial Contact Information</CardTitle>

      {/* Basic Information */}
      <FormField
        name="company_name"
        label="Business Name"
        required
      />

      {/* Contact Details */}
      <FormField
        name="contact_name"
        label="Primary Contact"
        required
      />

      {/* Service Selection */}
      <ServiceSelectionGroup
        onChange={(services) =>
          dispatch({ type: 'UPDATE_SERVICES', services })
        }
      />

      {/* Schedule Follow-up */}
      <CalendarSelect
        onSelect={(date) =>
          dispatch({ type: 'SCHEDULE_FOLLOWUP', date })
        }
      />
    </Form>
  )
}
```

### 2. Document Collection Process

```typescript
// src/components/clients/onboarding/DocumentCollection.tsx
export function DocumentCollection() {
  const { requiredDocs } = useRequiredDocuments()
  const [uploadedDocs, setUploadedDocs] = useState<string[]>([])

  return (
    <div className="space-y-6">
      <DocumentCheckList
        required={requiredDocs}
        uploaded={uploadedDocs}
      />

      <DocumentUploader
        onUpload={(doc) => {
          setUploadedDocs([...uploadedDocs, doc.id])
        }}
      />

      <MissingDocumentsAlert
        required={requiredDocs}
        uploaded={uploadedDocs}
      />
    </div>
  )
}
```

### 3. Engagement Letter Generation

```typescript
// src/components/clients/onboarding/EngagementLetter.tsx
export function EngagementLetter() {
  const { clientData } = useOnboardingStore()
  const { generateLetter, isGenerating } = useEngagementLetter()

  return (
    <div className="space-y-4">
      <LetterPreview
        client={clientData}
        onGenerate={generateLetter}
        isGenerating={isGenerating}
      />

      <SignatureCapture
        onSign={async (signature) => {
          await saveLetter({
            ...clientData,
            signature
          })
        }}
      />
    </div>
  )
}
```

## Document Management Implementation

### 1. Document Processing Workflow

```typescript
// src/components/documents/ProcessingWorkflow.tsx
export function DocumentProcessingWorkflow() {
  const [docs, setDocs] = useState<ProcessingDocument[]>([])

  return (
    <div className="space-y-6">
      <ProcessingQueue
        documents={docs}
        onProcess={async (doc) => {
          // 1. Upload to storage
          const stored = await uploadToStorage(doc)

          // 2. Process with AI
          const processed = await processWithAI(stored)

          // 3. Update database
          await updateDocument(processed)
        }}
      />

      <ProcessingStatus
        documents={docs}
      />
    </div>
  )
}
```

### 2. Document Categorization

```typescript
// src/components/documents/Categorization.tsx
export function DocumentCategorization() {
  const { documents } = useDocuments()

  return (
    <div>
      <CategoryFilter
        onSelect={(category) => {
          filterDocuments(category)
        }}
      />

      <DocumentGrid
        documents={documents}
        onCategorize={async (doc, category) => {
          await updateCategory(doc.id, category)
        }}
      />
    </div>
  )
}
```

## Tax Return Workflow Implementation

### 1. Initial Review Process

```typescript
// src/components/tax-returns/InitialReview.tsx
export function InitialReview() {
  const { documents, updateStatus } = useTaxReturn()

  return (
    <div className="space-y-6">
      <DocumentCompleteness
        documents={documents}
        requiredDocs={getRequiredDocs()}
      />

      <ReviewChecklist
        items={[
          "All W-2s received",
          "1099s verified",
          "Prior year comparison",
          "Entity status confirmed"
        ]}
        onComplete={async (completed) => {
          if (completed) {
            await updateStatus('ready_for_preparation')
          }
        }}
      />
    </div>
  )
}
```

### 2. Preparation Phase

```typescript
// src/components/tax-returns/Preparation.tsx
export function TaxReturnPreparation() {
  const { return: taxReturn } = useTaxReturn()

  return (
    <div className="grid grid-cols-2 gap-6">
      <PreparationWorkspace
        taxReturn={taxReturn}
        onSave={async (updates) => {
          await saveTaxReturn(updates)
        }}
      />

      <AIAssistant
        context={taxReturn}
        onSuggest={(suggestion) => {
          handleAISuggestion(suggestion)
        }}
      />
    </div>
  )
}
```

## Quality Control Implementation

### 1. Review Process

```typescript
// src/components/quality/ReviewProcess.tsx
export function QualityReview() {
  const { work, reviewer } = useQualityControl()

  return (
    <div className="space-y-6">
      <ReviewerAssignment
        work={work}
        reviewer={reviewer}
      />

      <ReviewChecklist
        items={getReviewItems(work.type)}
      />

      <SignoffForm
        onSignoff={async (notes) => {
          await completeReview(work.id, {
            reviewer: reviewer.id,
            notes,
            timestamp: new Date()
          })
        }}
      />
    </div>
  )
}
```

### 2. Error Detection

```typescript
// src/components/quality/ErrorDetection.tsx
export function ErrorDetection() {
  const { work } = useCurrentWork()
  const { findErrors } = useAIErrorDetection()

  return (
    <div>
      <AIAnalysis
        work={work}
        onAnalyze={async () => {
          const errors = await findErrors(work)
          highlightErrors(errors)
        }}
      />

      <ErrorList
        errors={work.errors}
        onFix={async (error) => {
          await fixError(error)
        }}
      />
    </div>
  )
}
```

## Communication Implementation

### 1. Client Portal

```typescript
// src/components/communication/ClientPortal.tsx
export function ClientPortal() {
  const { client, messages } = useClientCommunication()

  return (
    <div className="grid grid-cols-12 gap-6">
      {/* Document Request Section */}
      <div className="col-span-8">
        <DocumentRequestBoard
          client={client}
          onRequest={async (docType) => {
            await sendDocumentRequest(client.id, docType)
          }}
        />

        <MissingDocumentsTracker
          client={client}
          onFollowUp={(doc) => {
            sendFollowUpReminder(client.id, doc.id)
          }}
        />
      </div>

      {/* Message Center */}
      <div className="col-span-4">
        <MessageThread
          messages={messages}
          onReply={async (message) => {
            await sendClientMessage(client.id, message)
          }}
        />
      </div>
    </div>
  )
}
```

### 2. Team Communication Hub

```typescript
// src/components/communication/TeamHub.tsx
export function TeamHub() {
  const { tasks, team } = useTeamManagement()

  return (
    <div className="space-y-6">
      {/* Task Assignment Board */}
      <TaskBoard
        tasks={tasks}
        team={team}
        onAssign={async (taskId, userId) => {
          await assignTask(taskId, userId)
          await notifyTeamMember(userId, taskId)
        }}
      />

      {/* Internal Notes */}
      <InternalNotes
        onNote={async (note) => {
          await saveInternalNote({
            content: note,
            visibility: 'team-only'
          })
        }}
      />

      {/* Status Updates */}
      <StatusUpdates
        onUpdate={async (update) => {
          await broadcastUpdate(update)
        }}
      />
    </div>
  )
}
```

## Workflow Automation Implementation

### 1. Task Automation

```typescript
// src/components/workflows/TaskAutomation.tsx
export function TaskAutomation() {
  const { workflows } = useWorkflows()

  return (
    <div className="space-y-8">
      {/* Workflow Templates */}
      <WorkflowTemplates
        templates={workflows}
        onApply={async (template, clientId) => {
          await applyWorkflowTemplate(template, clientId)
        }}
      />

      {/* Automated Task Creation */}
      <AutomatedTasks
        onTrigger={async (trigger) => {
          // Create tasks based on triggers
          const tasks = await generateTasksFromTrigger(trigger)
          await createAutomatedTasks(tasks)
        }}
      />

      {/* Deadline Management */}
      <DeadlineTracker
        onDeadline={async (deadline) => {
          await setTaskReminders(deadline)
        }}
      />
    </div>
  )
}
```

### 2. Document Workflow

```typescript
// src/components/workflows/DocumentWorkflow.tsx
export function DocumentWorkflow() {
  const { documents } = useDocumentManagement()

  return (
    <div className="space-y-6">
      {/* Document Processing Pipeline */}
      <ProcessingPipeline
        documents={documents}
        onProcess={async (doc) => {
          // 1. OCR and Data Extraction
          const extractedData = await processDocument(doc)

          // 2. Categorization
          const category = await categorizeDocument(extractedData)

          // 3. Data Validation
          const validatedData = await validateDocumentData(extractedData)

          // 4. Database Update
          await updateDocumentRecord(doc.id, {
            extractedData: validatedData,
            category,
            status: 'processed'
          })
        }}
      />

      {/* Document Review Queue */}
      <ReviewQueue
        documents={documents.filter(d => d.status === 'needs_review')}
        onReview={async (doc, decision) => {
          await processReviewDecision(doc, decision)
        }}
      />
    </div>
  )
}
```

## Client Service Tracking Implementation

### 1. Service Management

```typescript
// src/components/services/ServiceManagement.tsx
export function ServiceManagement() {
  const { services, client } = useClientServices()

  return (
    <div className="space-y-8">
      {/* Active Services Dashboard */}
      <ServicesDashboard
        services={services}
        onUpdate={async (serviceId, updates) => {
          await updateServiceStatus(serviceId, updates)
        }}
      />

      {/* Service Schedule */}
      <ServiceSchedule
        services={services}
        onSchedule={async (service, date) => {
          await scheduleService(service, date)
        }}
      />

      {/* Service History */}
      <ServiceHistory
        client={client}
        onViewDetails={(serviceId) => {
          viewServiceDetails(serviceId)
        }}
      />
    </div>
  )
}
```

### 2. Progress Tracking

```typescript
// src/components/services/ProgressTracking.tsx
export function ProgressTracking() {
  const { milestones } = useServiceProgress()

  return (
    <div className="space-y-6">
      {/* Milestone Tracker */}
      <MilestoneTracker
        milestones={milestones}
        onComplete={async (milestone) => {
          await completeMilestone(milestone)
          await updateClientProgress(milestone.clientId)
        }}
      />

      {/* Progress Reports */}
      <ProgressReports
        onGenerate={async (clientId) => {
          const report = await generateProgressReport(clientId)
          await sendProgressReport(clientId, report)
        }}
      />

      {/* Status Updates */}
      <StatusBoard
        onUpdate={async (status) => {
          await updateServiceStatus(status)
          await notifyRelevantTeam(status)
        }}
      />
    </div>
  )
}
```

## Quality Assurance Implementation

### 1. Validation System

```typescript
// src/components/quality/ValidationSystem.tsx
export function ValidationSystem() {
  const { work } = useWorkValidation()

  return (
    <div className="space-y-6">
      {/* Data Validation */}
      <DataValidator
        data={work.data}
        rules={getValidationRules(work.type)}
        onValidate={async (results) => {
          await processValidationResults(results)
        }}
      />

      {/* Quality Checklist */}
      <QualityChecklist
        items={getQualityItems(work.type)}
        onComplete={async (checklist) => {
          await completeQualityCheck(work.id, checklist)
        }}
      />

      {/* Review Notes */}
      <ReviewNotes
        onNote={async (note) => {
          await addReviewNote(work.id, note)
          await notifyPreparer(work.id, note)
        }}
      />
    </div>
  )
}
```

### 2. Compliance Monitoring

```typescript
// src/components/quality/ComplianceMonitoring.tsx
export function ComplianceMonitoring() {
  const { compliance } = useComplianceChecks()

  return (
    <div className="space-y-8">
      {/* Compliance Dashboard */}
      <ComplianceDashboard
        checks={compliance.checks}
        onCheck={async (check) => {
          await runComplianceCheck(check)
        }}
      />

      {/* Regulatory Updates */}
      <RegulatoryUpdates
        onUpdate={async (update) => {
          await processRegulatoryUpdate(update)
          await notifyTeamOfChanges(update)
        }}
      />

      {/* Audit Trail */}
      <AuditTrail
        onExport={async () => {
          const audit = await generateAuditReport()
          await exportAuditTrail(audit)
        }}
      />
    </div>
  )
}
```

## Integration Points with Part A

Each component above integrates with the technical implementation from Part A through:

1. Database Interactions

```typescript
// Uses the Supabase client from Part A
const { supabase } = useSupabase();

// Queries using established patterns
const { data } = await supabase.from("clients").select("*").eq("id", clientId);
```

2. Real-time Updates

```typescript
// Uses real-time subscriptions from Part A
useRealTimeUpdates("clients", (update) => {
  // Handle updates
});
```

3. Error Handling

```typescript
// Uses error handling patterns from Part A
try {
  await processDocument(doc);
} catch (error) {
  handleError(error, {
    context: "document-processing",
    severity: "high",
  });
}
```

4. AI Integration

```typescript
// Uses AI processing setup from Part A
const aiResult = await analyzeDocument(document, {
  type: "tax_document",
  expectedFields: ["income", "deductions"],
});
```

## Validation Steps

For each SOP implementation:

1. Unit Testing

```typescript
test("validates document processing workflow", async () => {
  const workflow = new DocumentWorkflow();
  const result = await workflow.process(testDocument);
  expect(result.status).toBe("processed");
});
```

2. Integration Testing

```typescript
test("completes full client onboarding", async () => {
  const onboarding = new OnboardingProcess();
  await onboarding.complete(testClient);
  expect(onboarding.status).toBe("completed");
});
```

3. User Acceptance Testing

```typescript
test("team can use communication hub", async () => {
  const hub = new TeamHub();
  const message = await hub.sendMessage(testMessage);
  expect(message.delivered).toBe(true);
});
```

## Implementation Checklist

For each SOP component:

‚úÖ Component created and tested
‚úÖ Database interactions implemented
‚úÖ Real-time updates configured
‚úÖ Error handling in place
‚úÖ AI integration points established
‚úÖ Documentation updated
‚úÖ Team training materials prepared

## Next Steps

1. Complete all component implementations
2. Run full test suite
3. Document integration points
4. Prepare deployment plan
5. Create team training materials

See [Part A: Technical Implementation](./PART-A.md) for the technical foundation these implementations build upon.

### Implementation

#### PROGRESS.md

# Implementation Progress

## Implementation Status Legend

- üî≤ Planned Feature (Not Started)
- ‚è≥ In Development
- ‚úÖ Actually Implemented & Tested
- ‚ö†Ô∏è Needs Review/Fixes

## Current Status (as of January 2024)

### Authentication & Security

- ‚úÖ Basic authentication with Supabase
- ‚úÖ Server-side session handling
- ‚úÖ Role-based access control implementation
  - ‚úÖ RoleGuard component with tests
  - ‚úÖ useAuth hook with role support
  - ‚úÖ Security tests
  - ‚úÖ Error boundary handling
- ‚úÖ Authentication Pages
  - ‚úÖ Login page implementation
  - ‚úÖ Registration page
  - ‚úÖ Password reset flow
- ‚úÖ Row Level Security (RLS) policies
  - ‚úÖ All tables have RLS enabled
  - ‚úÖ Role-based access policies
  - ‚úÖ Profile-based permissions

### Data Layer & Management

- ‚úÖ Database schema implementation
  - ‚úÖ Core tables (clients, tax_returns, documents)
  - ‚úÖ Relationship tables
  - ‚úÖ Enum types
- ‚úÖ Core data fetching hooks
  - ‚úÖ useClients hook
    - ‚úÖ Type-safety with `Database` types
    - ‚úÖ Global error handling integration
    - ‚úÖ Real-time updates
    - ‚úÖ SSR support with initial data [NEW]
  - ‚úÖ useTaxReturns hook
    - ‚úÖ Type-safety with `Database` types
    - ‚úÖ Global error handling integration
    - ‚úÖ Real-time updates
    - ‚úÖ SSR support with initial data [NEW]
  - ‚úÖ useProcessingStatus
  - ‚úÖ Actual data fetching implementation
  - ‚úÖ Error handling implementation
  - ‚úÖ Loading states
- ‚è≥ Real-time updates
  - ‚úÖ Supabase channel subscriptions setup
  - ‚ö†Ô∏è Full real-time integration completed for clients/tax returns, but extended coverage needed
  - üî≤ Offline support

### Client Management

- ‚úÖ Client Onboarding Workflow
  - ‚úÖ Basic validation implementation
  - ‚úÖ Client data type definitions
  - ‚úÖ Client listing page
  - ‚úÖ Client creation form
  - ‚úÖ Client details view
  - ‚úÖ Client data CRUD operations
  - ‚è≥ Advanced validation rules (in progress)

### Document Management

- ‚ö†Ô∏è Document System
  - ‚úÖ Document status definitions
  - ‚úÖ Basic structure setup
  - ‚úÖ Upload component
  - ‚úÖ Document listing
  - ‚úÖ Integration with custom storage service
  - ‚úÖ Global error handling
  - üî≤ Preview functionality
  - ‚è≥ Document workflow automation

### Tax Return System

- ‚è≥ Core Features
  - ‚úÖ Return creation workflow
  - ‚úÖ Status management
  - ‚úÖ Integration with `task.service.ts` for QC tasks
  - üî≤ Document linking
- üî≤ Automation
  - ‚è≥ Basic workflow
  - üî≤ AI assistance
  - üî≤ Quality checks

### AI Integration

- ‚úÖ Basic document processing setup
- ‚úÖ AI Integration Framework
  - ‚úÖ Fallback logic implementation
  - ‚úÖ Error handling for AI calls
  - ‚úÖ Basic AI service integration
  - ‚è≥ Advanced AI features (in progress)
  - üî≤ AI performance monitoring

### UI Components

- ‚úÖ Core components
  - ‚úÖ TaxReturnList
  - ‚úÖ DocumentUpload
  - ‚úÖ ProcessingStatus
  - ‚úÖ ClientList
  - ‚úÖ AuthLoading
  - ‚úÖ AuthErrorBoundary
- ‚úÖ Layout components
  - ‚úÖ Basic dashboard layout
  - ‚è≥ Responsive design improvements
- ‚úÖ Core Pages
  - ‚úÖ Dashboard home
  - ‚úÖ Client management
  - ‚úÖ Document center
  - ‚úÖ Tax return workspace

### Testing

- ‚úÖ Testing infrastructure setup
- ‚úÖ Authentication tests
  - ‚úÖ RoleGuard component tests
  - ‚úÖ useAuth hook tests
  - ‚úÖ AuthErrorBoundary tests
- ‚è≥ Component tests
  - ‚úÖ TaxReturnForm tests
  - üî≤ Client components
  - üî≤ Document components
- üî≤ Integration tests
- üî≤ E2E tests

## Next Steps (Prioritized)

1. **Critical Path**
   - ‚úÖ Implement missing core pages (Dashboard, Clients, Documents)
   - ‚úÖ Complete data fetching implementations
   - ‚ö†Ô∏è Extend real-time sync for all data models
2. **Short Term**
   - ‚úÖ Complete client management features
   - ‚úÖ Implement document upload and listing
   - ‚úÖ Add basic tax return workflow (with QC tasks)
   - üî≤ Preview functionality for documents
   - üî≤ Document linking in tax returns
3. **Medium Term**
   - Enhance AI features
   - Add advanced automation
   - Complete testing coverage

## Dependencies and Blockers

- Full real-time coverage needed (beyond clients/tax_returns)
- Document linking in tax returns remains pending
- Offline support not yet implemented

## Notes

- Improved type safety with `Database` schema
- Leveraged global error handling via `handleError`
- Introduced partial real-time updates for Clients and Tax Returns
- Next focus: preview docs, link them to returns, expand real-time events

## Recent Updates (January 2024)

- ‚úÖ SSR Implementation Complete
  - Implemented proper SSR with `@supabase/ssr`
  - Created separate browser/server clients
  - Added cookie handling for server components
  - Updated all components to use correct clients
  - Added real-time updates for client components

### Completed Changes

1. **SSR Infrastructure**

   - ‚úÖ Installed `@supabase/ssr` package
   - ‚úÖ Created `supabaseServerClient.ts` for server components
   - ‚úÖ Created `supabaseBrowserClient.ts` for client components
   - ‚úÖ Implemented proper cookie handling in server client
   - ‚úÖ Updated all component imports

2. **Implementation Status**
   - ‚úÖ Client creation (server & browser)
   - ‚úÖ Cookie handling (server components)
   - ‚úÖ Component separation (server vs client)
   - ‚úÖ Real-time updates (client components)
   - ‚úÖ Type safety with Database types

### Next Steps

1. Extend SSR pattern to remaining pages
2. Add error boundaries for SSR components
3. Implement loading UI for SSR
4. Add E2E tests for SSR functionality

### Migration Status

- ‚úÖ Updated package.json dependencies
- ‚úÖ Created browser client utility
- ‚úÖ Created server client utility
- ‚úÖ Updated all imports
- ‚úÖ Tested SSR functionality
- ‚úÖ Verified cookie handling
- ‚è≥ Extending to remaining pages

### Required Changes

1. **Immediate Fixes Needed**

   - üî≤ Install `@supabase/ssr` package
   - üî≤ Create separate browser/server client utilities
   - üî≤ Update cookie handling in server client
   - üî≤ Update all component imports

2. **Implementation Status**
   - ‚ö†Ô∏è Client creation (needs update)
   - ‚ö†Ô∏è Cookie handling (needs revision)
   - ‚ö†Ô∏è Component separation (needs update)

### Next Steps

1. Install correct dependencies
2. Create proper client utilities
3. Update all components to use correct clients
4. Test SSR functionality

### Migration Checklist

- üî≤ Update package.json dependencies
- üî≤ Create browser client utility
- üî≤ Create server client utility
- üî≤ Update all imports
- üî≤ Test SSR functionality
- üî≤ Verify cookie handling

## UI Framework and Design System Implementation (March 2024)

### ‚úÖ Completed Tasks

1. **Theme Configuration**

   - Implemented shadcn/ui theme with proper color tokens
   - Set up dark mode support with proper color variables
   - Configured typography system with Inter and Fira Code fonts
   - Added proper border radius and spacing variables

2. **Font System**

   - Fixed font loading issues by replacing GeistMono with Fira Code
   - Properly configured Next.js font loading with variables
   - Added proper font fallbacks in Tailwind config
   - Implemented proper font feature settings

3. **Layout Components**

   - Created responsive dashboard layout
   - Implemented Kanban-style task board
   - Added data tables for documents and tax returns
   - Added loading states and error boundaries

4. **Component Library Setup**
   - Integrated shadcn/ui components
   - Added proper animations and transitions
   - Implemented toast notifications
   - Created reusable error boundary component

### üöß In Progress

1. **Data Integration**

   - Implementing Supabase data fetching
   - Adding proper type definitions
   - Setting up real-time updates
   - Implementing proper error handling

2. **Authentication Flow**

   - Setting up protected routes
   - Implementing login/logout functionality
   - Adding role-based access control
   - Setting up session management

3. **Client Management**
   - Building client profile pages
   - Implementing client search and filtering
   - Adding document upload functionality
   - Creating client communication tools

### üìã Upcoming Tasks

1. **Tax Return Management**

   - Build tax return creation workflow
   - Implement status tracking system
   - Add document attachment system
   - Create review and approval process

2. **Document Management**

   - Implement secure document storage
   - Add version control for documents
   - Create document sharing system
   - Add document templates

3. **Reporting System**
   - Create financial reports dashboard
   - Implement tax season analytics
   - Add client progress tracking
   - Build custom report generator

## Technical Improvements

### Recent Updates (March 2024)

1. **Font System Overhaul**

```typescript
// Updated font configuration in layout.tsx
const inter = Inter({
  subsets: ["latin"],
  variable: "--font-inter",
});

const firaCode = Fira_Code({
  subsets: ["latin"],
  variable: "--font-mono",
});
```

2. **Theme System Enhancement**

```css
/* Updated color system in theme.css */
:root {
  --background: 0 0% 100%;
  --foreground: 222.2 47.4% 11.2%;
  /* ... other color tokens */
}
```

3. **Component Improvements**

```typescript
// Added loading states to data components
{isLoading ? (
  <LoadingSpinner />
) : (
  <DataTable data={data} />
)}
```

### Next Steps

1. **Performance Optimization**

   - Implement proper code splitting
   - Add proper caching strategies
   - Optimize image loading
   - Improve bundle size

2. **Security Enhancements**

   - Add proper input validation
   - Implement rate limiting
   - Set up proper CORS policies
   - Add audit logging

3. **Testing Implementation**
   - Add unit tests for components
   - Implement integration tests
   - Add end-to-end testing
   - Set up continuous integration

## Known Issues

1. ~~Font loading issues with GeistMono~~ (Fixed)
2. ~~Missing color tokens in dark mode~~ (Fixed)
3. ~~Inconsistent loading states~~ (Fixed)

## Dependencies Added

```json
{
  "@tailwindcss/typography": "latest",
  "@tailwindcss/forms": "latest",
  "tailwindcss-animate": "latest"
}
```

#### SUPABASE_SSR.md

# Supabase SSR Implementation Guide

## Overview

This guide outlines the proper implementation of Supabase with Next.js 13+ App Router, using `@supabase/ssr` for server and client components.

## Setup

### 1. Installation

```bash
npm install @supabase/ssr @supabase/supabase-js
```

### 2. Environment Variables

```env
NEXT_PUBLIC_SUPABASE_URL=your_supabase_project_url
NEXT_PUBLIC_SUPABASE_ANON_KEY=your_supabase_anon_key
```

## Implementation Structure

### 1. Server Client (`src/lib/supabaseServerClient.ts`)

```typescript
import { createServerClient } from "@supabase/ssr";
import { cookies } from "next/headers";
import { Database } from "@/types/database.types";

export function getSupabaseServerClient() {
  const cookieStore = cookies();
  return createServerClient<Database>(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get: (name: string) => cookieStore.get(name)?.value,
      },
    },
  );
}
```

### 2. Browser Client (`src/lib/supabaseBrowserClient.ts`)

```typescript
import { createBrowserClient } from "@supabase/ssr";
import { Database } from "@/types/database.types";

export const supabaseBrowserClient = createBrowserClient<Database>(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
);
```

### 3. Server Component Example (`src/app/clients/page.tsx`)

```typescript
import { getSupabaseServerClient } from '@/lib/supabaseServerClient';
import ClientList from '@/components/client/ClientList';

async function getClients() {
  const supabase = getSupabaseServerClient();
  const { data: clients } = await supabase.from('clients').select('*');
  return clients || [];
}

export default async function ClientsPage() {
  const initialClients = await getClients();

  return (
    <main className="p-4">
      <h1 className="text-xl font-bold mb-4">Clients</h1>
      <ClientList initialClients={initialClients} />
    </main>
  );
}
```

### 4. Client Hook Example (`src/hooks/useClients.ts`)

```typescript
"use client";

import { useState, useEffect } from "react";
import { supabaseBrowserClient } from "@/lib/supabaseBrowserClient";
import { handleError } from "@/lib/error-handler";
import { Database } from "@/types/database.types";

type Client = Database["public"]["Tables"]["clients"]["Row"];

export function useClients(initialClients?: Client[] | null) {
  const [clients, setClients] = useState<Client[]>(initialClients || []);
  const [loading, setLoading] = useState(!initialClients);
  const [error, setError] = useState("");

  useEffect(() => {
    // Only fetch if no SSR data
    if (!initialClients) {
      fetchClients();
    }

    // Real-time updates
    const channel = supabaseBrowserClient
      .channel("clients")
      .on(
        "postgres_changes",
        { event: "*", schema: "public", table: "clients" },
        () => {
          fetchClients();
        },
      )
      .subscribe();

    return () => {
      channel.unsubscribe();
    };
  }, []);

  // ... rest of the hook implementation
}
```

### 5. Client Component Example (`src/components/client/ClientList.tsx`)

```typescript
'use client';

import React from 'react';
import { useClients } from '@/hooks/useClients';
import { Database } from '@/types/database.types';

type Client = Database['public']['Tables']['clients']['Row'];

interface ClientListProps {
  initialClients?: Client[] | null;
}

export default function ClientList({ initialClients }: ClientListProps) {
  const { clients, loading, error } = useClients(initialClients);

  if (error) return <div className="text-red-600">Error: {error}</div>;
  if (loading && !clients.length) return <div>Loading...</div>;

  return (
    // Component JSX
  );
}
```

## Best Practices

1. **Client/Server Separation**

   - Use `createServerClient` for Server Components
   - Use `createBrowserClient` for Client Components
   - Never mix server/client code

2. **SSR Data Flow**

   - Fetch initial data in Server Components
   - Pass data to Client Components via props
   - Handle real-time updates on the client

3. **Type Safety**

   - Use Database types throughout
   - Type all client instances
   - Handle null/undefined states

4. **Error Handling**
   - Proper error boundaries
   - Loading states
   - Fallback UI

## Common Issues

1. **Cookie Handling**

   - Server client must use cookies
   - Browser client handles cookies automatically
   - Ensure proper cookie configuration

2. **Real-time Updates**

   - Only subscribe in Client Components
   - Clean up subscriptions
   - Handle connection errors

3. **Type Safety**
   - Import Database types correctly
   - Handle optional props
   - Type all responses

### Specifications

#### WORKFLOWS_GUIDE.md

# User Workflows and Implementation Guide

[Previous content of workflows-guide artifact]

### Standard Operating Procedures

Below is a comprehensive, step-by-step SOP (Standard Operating Procedure) document that you can share with your team. The goal is to have a systemized, interactive checklist for each major function of your accounting and tax preparation firm. Feel free to adapt and refine these procedures to fit your firm‚Äôs specific needs, client base, and technology stack.

---

# **MASTER SOP FOR ACCOUNTING & TAX PREPARATION FIRM**

## **Table of Contents**

1. **Client Onboarding**
2. **Bookkeeping SOP**
3. **Payroll SOP**
4. **Tax Preparation SOP**
   - 4.1. **Individual (1040)**
   - 4.2. **Single-Member LLC (Schedule C)**
   - 4.3. **Partnerships (Form 1065)**
   - 4.4. **S-Corporations (Form 1120S)**
   - 4.5. **Real Estate & Flipping**
5. **Financial Reporting & Review**
6. **Communication & Client Management**
7. **Quality Control & Security**
8. **Year-End Close Process**

Each SOP contains:

- **Purpose**: Why this procedure exists.
- **Scope**: Who and what is covered.
- **Checklist/Steps**: A clear, step-by-step process.
- **Examples**: Illustrations or mini-scenarios.
- **Tools & Templates**: Any templates or software references.

---

## 1. **Client Onboarding**

### **Purpose**

Ensure a consistent and smooth experience for new and returning clients, gather necessary information upfront, and maintain organized client records.

### **Scope**

Applies to all new clients: individuals, LLCs, partnerships, corporations, and real estate owners.

### **Checklist / Steps**

1. **Initial Contact & Information Gathering**

   - Schedule introduction call or meeting.
   - Provide a ‚ÄúClient Welcome Packet‚Äù (digital or PDF) explaining services, required documents, and timelines.
   - \[**Example**\]: For a new restaurant client, include a tailored checklist for sales, payroll, and vendor invoices.

2. **Engagement Letter & Service Agreement**

   - Send engagement letter for e-signature (e.g., via DocuSign).
   - File the signed agreement in the client‚Äôs folder.

3. **Secure Client Portal Setup**

   - Create a secure folder in your document management system (e.g., SharePoint, Google Drive, or a client portal).
   - Provide instructions for uploading sensitive documents (W-2s, 1099s, QuickBooks backups, etc.).

4. **Client Data Collection**

   - Use an intake form or AI-driven questionnaire to capture essential data:
     - Legal entity details (LLC, S-Corp, etc.)
     - EIN, SSN, contact info
     - Past year financial statements or tax returns

5. **Verification & Follow-Up**
   - Verify completeness of documents (ID, prior returns, W-2, 1099, etc.).
   - Schedule a follow-up call to confirm all required documentation is received.

### **Tools & Templates**

- **Welcome Packet Template** (Word/Google Doc)
- **Engagement Letter Template**
- **AI-powered Client Intake Form** (e.g., JotForm, custom tool)

---

## 2. **Bookkeeping SOP**

### **Purpose**

Standardize the monthly or annual bookkeeping process so that transactions are accurately recorded and reconciled.

### **Scope**

Applies to all clients requiring bookkeeping services, including monthly, quarterly, and annual engagements.

### **Checklist / Steps**

1. **Transaction Gathering**

   - **Client Provided**: Bank statements, credit card statements, receipts.
   - **System Imports**: QuickBooks Online bank feeds, merchant statements (Square, Shopify, etc.).

2. **Transaction Categorization**

   - Use a standardized chart of accounts (COA) per client/industry.
   - Apply consistent naming conventions (e.g., ‚ÄúCOGS ‚Äì Food,‚Äù ‚ÄúSales ‚Äì Catering‚Äù).
   - **Example**: For a restaurant client, ensure all food purchases are allocated to ‚ÄúFood COGS‚Äù or ‚ÄúSupplies.‚Äù

3. **Reconciliation**

   - Reconcile each bank account monthly in QuickBooks (or chosen platform).
   - Match statement ending balances with QBO or the general ledger.
   - Flag unreconciled items (outstanding checks, fees, etc.) and investigate promptly.

4. **Month-End Close**

   - Verify all invoices and bills are entered.
   - Post recurring journal entries (e.g., depreciation, payroll accruals).
   - Run a preliminary Profit & Loss (P&L) and Balance Sheet to identify anomalies.

5. **Reporting & Review**
   - Generate final P&L, Balance Sheet, and Cash Flow Statement.
   - Send a monthly or quarterly summary to the client highlighting key changes or concerns.

### **Tools & Templates**

| **Item**            | **Tool**                | **Notes**                          |
| ------------------- | ----------------------- | ---------------------------------- |
| Accounting Software | QuickBooks Online, Xero | Ensure multi-factor authentication |
| Reconciling Tool    | Built-in QBO Reconcile  | For monthly bank recs              |
| COA Templates       | Industry-Specific COA   | Restaurants, Construction, etc.    |

---

## 3. **Payroll SOP**

### **Purpose**

Ensure timely and accurate payroll processing for clients, including tax filings and compliance with federal/state guidelines.

### **Scope**

Applies to weekly, bi-weekly, or monthly payroll services for restaurant clients, contractors, and other small businesses.

### **Checklist / Steps**

1. **Payroll Setup**

   - Collect employee details (W-4, I-9, direct deposit info).
   - Configure payroll software (e.g., Gusto, QuickBooks Payroll).

2. **Payroll Processing**

   - Enter or import employee hours/tips.
   - Calculate wages, taxes, and deductions.
   - Send payroll preview to client for approval (if required).

3. **Disbursement**

   - Process direct deposits or checks on scheduled date.
   - Generate pay stubs; store them securely.

4. **Payroll Tax Filings & Payments**

   - File monthly or semi-weekly 941 deposits.
   - Submit quarterly filings (941, state returns) and annual forms (W-2, W-3, 940).

5. **Recordkeeping & Reconciliation**
   - Reconcile payroll reports to bank statements.
   - Retain payroll records (4+ years) per IRS guidelines.

### **Example**

- **Restaurant**: Weekly payroll with tip reporting. Must accurately track credit card vs. cash tips.

---

## 4. **Tax Preparation SOP**

Below are checklists by entity type. Adapt these based on your clientele‚Äôs needs.

### 4.1. **Individual (Form 1040)**

**Checklist / Steps**

1. **Gather Personal Info**: SSNs, IDs, prior-year returns.
2. **Collect Income Docs**: W-2, 1099 (NEC, INT, DIV, MISC), K-1s, Social Security.
3. **Deductions & Credits**: Mortgage interest, medical, education (1098-T), child tax credits, charitable donations.
4. **Investments & Capital Gains**: 1099-B, crypto statements.
5. **Rental Income (if any)**: Summaries of income/expenses, mortgage interest, property taxes.
6. **Review & Filing**: Generate draft return, review with client, e-file upon approval.

### 4.2. **Single-Member LLC (Schedule C)**

**Checklist / Steps**

1. **Business Structure & EIN**
2. **Income Statement**: Confirm all gross receipts match bank statements/PayPal, etc.
3. **Expenses**: Categorize properly (advertising, meals, rent, mileage).
4. **Home Office Deduction** (if applicable).
5. **Self-Employment Tax**: Calculate and check estimated payments made.
6. **Filing**: Attach Schedule C to Form 1040.

### 4.3. **Partnerships (Form 1065)**

**Checklist / Steps**

1. **Partnership Agreement**: Confirm ownership percentages, profit sharing.
2. **Financials**: P&L, Balance Sheet from QuickBooks or other.
3. **Partner Contributions & Distributions**: Document capital contributions/withdrawals.
4. **K-1 Preparation**: Split each partner‚Äôs share of income, deductions, and credits.
5. **Estimated Taxes**: Track any partner-level estimated payments.
6. **Review & Filing**: Generate Form 1065, review, e-file.

### 4.4. **S-Corporations (Form 1120S)**

**Checklist / Steps**

1. **Corporate Documents**: Articles of Incorporation, By-laws, S-Election acceptance (Form 2553).
2. **Financials**: Verify monthly or quarterly financial statements.
3. **Officer Compensation**: Confirm reasonable salaries, payroll tax compliance.
4. **Distributions vs. Payroll**: Ensure shareholder distributions are properly tracked.
5. **K-1 Preparation**: Allocate income/loss to each shareholder.
6. **Filing**: File Form 1120S, ensure all K-1s are issued.

### 4.5. **Real Estate & Flipping**

**Checklist / Steps**

1. **Property Records**: Purchase/sale agreements, settlement statements (HUD-1), mortgage statements.
2. **Expense Tracking**: Renovations, repairs, property management fees, property taxes.
3. **Capital Improvements vs. Repairs**: Separate capital improvements for depreciation.
4. **Depreciation Schedule**: Use prior-year‚Äôs schedule or calculate new for new properties.
5. **Flips**: Track cost basis, improvements, sale proceeds, short-term vs. long-term capital gains.
6. **Rental Income**: Confirm monthly rent, security deposits, and keep a ledger.
7. **1031 Exchange (If Applicable)**: Gather exchange documents, identify timeline compliance.

---

## 5. **Financial Reporting & Review**

### **Purpose**

Provide clients with timely, accurate financial insights and identify potential issues or opportunities.

### **Scope**

Includes monthly or quarterly review for all major clients (e.g., restaurants, real estate investors, contractors).

### **Checklist / Steps**

1. **Generate Financial Reports**

   - Profit & Loss, Balance Sheet, Cash Flow.
   - Segment for multiple business locations or properties if needed.

2. **Variance Analysis**

   - Compare actual vs. budget or prior periods.
   - Identify unusual spikes/drops in expenses or revenue.

3. **Client Meeting**

   - Schedule a quick Zoom or phone call to discuss results.
   - Provide actionable insights (e.g., cost control, sales trends).

4. **Record Documentation**
   - Save monthly/quarterly reports to client folder.
   - Follow up on any open items or unresolved questions.

---

## 6. **Communication & Client Management**

### **Purpose**

Establish clear communication protocols and ensure no client query or deadline falls through the cracks.

### **Scope**

All emails, calls, messages, and project management related to client work.

### **Checklist / Steps**

1. **Communication Channels**

   - Official firm email, phone, secure portal, or project management tool (e.g., Asana, Trello, Notion).
   - Use AI or chatbots for standard FAQs if desired.

2. **Response Times**

   - Aim for a same-day reply or within 24 hours.
   - Set up an autoresponder during heavy tax seasons to manage expectations.

3. **Task Tracking**

   - Use a centralized project management board for each client (bookkeeping tasks, tax deadlines, etc.).
   - Assign tasks to team members with due dates and priority levels.

4. **Meeting Notes & Follow-Ups**
   - Record key discussion points from client calls.
   - Create action items and deadlines in the PM tool.

---

## 7. **Quality Control & Security**

### **Purpose**

Maintain high accuracy in work output and secure handling of sensitive client data.

### **Scope**

All deliverables (financials, returns, paychecks) and data storage.

### **Checklist / Steps**

1. **Review & Cross-Check**

   - At least one senior team member or peer reviews final financial statements and tax returns before sending to client.
   - Use checklists to ensure all schedules and forms are included.

2. **Encryption & Security**

   - Store documents in encrypted cloud services or secure servers.
   - Enable MFA (multi-factor authentication) on all critical software.
   - Regularly update passwords and follow cybersecurity best practices.

3. **Data Backup**

   - Automated daily/weekly backups of accounting files and client data.
   - Keep an offsite or cloud-based backup in case of local system failure.

4. **Compliance & Regulatory Updates**
   - Track IRS bulletins, tax law changes, and state-level updates.
   - Conduct periodic training or updates for the team.

---

## 8. **Year-End Close Process**

### **Purpose**

Ensure all financials are accurate, all adjusting entries are posted, and every client‚Äôs data is ready for tax filings or final year-end review.

### **Scope**

Includes all clients with fiscal year-end aligning to the calendar year (and adapted for those with alternative year-ends).

### **Checklist / Steps**

1. **Preliminary Review**

   - Verify all bank and credit card accounts are fully reconciled.
   - Ensure payroll and sales tax liabilities match final statements.

2. **Adjusting Entries**

   - Book depreciation, amortization, prepaids, accruals.
   - Clear any suspense or misclassified entries.

3. **Final Reports**

   - Generate final P&L, Balance Sheet.
   - Check balance sheet accounts for reasonableness (A/R, A/P, loans, etc.).

4. **Tax Season Prep**

   - Update client with final financials.
   - Gather any missing documents needed for the annual return.

5. **Kickoff Tax Preparation**
   - Mark each client as ‚ÄúReady for Tax‚Äù in your PM system.
   - Assign to the tax team for immediate or scheduled processing.

---

# **Putting It All Together: Interactive Example**

Below is a mini example of how your team might see these SOPs in practice, using a hypothetical **Restaurant Client** named ‚ÄúPizzaVille‚Äù:

1. **Onboarding**

   - Send a ‚ÄúWelcome Packet‚Äù describing monthly bookkeeping and weekly payroll.
   - Collect prior-year tax returns and Articles of Incorporation.

2. **Bookkeeping**

   - Weekly: Download bank statements from the PizzaVille checking account.
   - Monthly: Reconcile in QuickBooks Online, classify expenses as ‚ÄúFood COGS,‚Äù ‚ÄúLabor,‚Äù ‚ÄúRent,‚Äù etc.

3. **Payroll**

   - Every Friday: Process tips, wages in Gusto. Confirm staff hours. Send stubs.
   - Monthly: Verify 941 payments are made.

4. **Tax Prep**

   - S-Corporation Return (1120S): Collect final income statement, review officer compensation vs. distributions.
   - Real Estate if PizzaVille also owns building: Document depreciation, mortgage interest.

5. **Review & Communication**

   - Monthly check-in call to discuss finances.
   - Provide a short summary highlighting food cost ratio vs. prior month.

6. **Year-End**
   - Make adjusting entries for depreciation on pizza oven and building improvements.
   - Final review for annual 1120S filing.

---

# **Final Notes & Recommendations**

1. **Customize**: Every business is unique‚Äîadapt these templates for your specific workflows, especially if you focus on restaurants, subcontractors, real estate, or Spanish-speaking entrepreneurs.
2. **Train & Iterate**: Have regular SOP training sessions with your team. Encourage feedback and update your SOPs as new tools or processes emerge.
3. **Use Tools Wisely**: Even if you plan to build your own AI-driven solution, store these SOPs in a place where your team can easily access and update them (e.g., Notion, Confluence, or an internal wiki).
4. **Stay Compliant**: Keep an eye on IRS updates, state-level changes, and best practices in data security. Incorporate changes into your SOPs at least once a year.

---

**With this documentation, your team will have a clear roadmap for each major task.** Feel free to expand or simplify sections as needed. By following these SOPs, you‚Äôll be well on your way to running a systematized, efficient, and scalable accounting and tax preparation firm.

### `src\middleware.ts`

```ts
import { createServerClient } from "@supabase/ssr";
import { NextResponse } from "next/server";
import type { NextRequest } from "next/server";

export async function middleware(req: NextRequest) {
  const res = NextResponse.next();

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return req.cookies.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          res.cookies.set({ name, value, ...options });
        },
        remove(name: string, options: any) {
          res.cookies.set({ name, value: "", ...options });
        },
      },
    },
  );

  // Get user instead of session
  const {
    data: { user },
    error,
  } = await supabase.auth.getUser();

  // Public routes that don't require authentication
  const isPublicRoute =
    req.nextUrl.pathname.startsWith("/auth") ||
    req.nextUrl.pathname.startsWith("/api/auth") ||
    req.nextUrl.pathname === "/";

  if (!user && !isPublicRoute) {
    return NextResponse.redirect(new URL("/auth/login", req.url));
  }

  // Role-based access control for protected routes
  if (user) {
    const { data: profile } = await supabase
      .from("profiles")
      .select("role")
      .eq("id", user.id)
      .single();

    // Admin-only routes
    if (
      req.nextUrl.pathname.startsWith("/admin") &&
      profile?.role !== "admin"
    ) {
      return NextResponse.redirect(new URL("/dashboard", req.url));
    }

    // Manager-only routes
    if (
      req.nextUrl.pathname.startsWith("/manager") &&
      !["admin", "manager"].includes(profile?.role || "")
    ) {
      return NextResponse.redirect(new URL("/dashboard", req.url));
    }
  }

  return res;
}

export const config = {
  matcher: ["/((?!_next/static|_next/image|favicon.ico).*)"],
};
```

### `src\app\error.tsx`

```tsx
"use client";

import ErrorBoundary from "@/components/error-boundary";

export default function GlobalError({
  error,
  reset,
}: {
  error: Error & { digest?: string };
  reset: () => void;
}) {
  return <ErrorBoundary error={error} reset={reset} />;
}
```

### `src\app\globals.css`

```css
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 0 0% 3.9%;
    --card: 0 0% 100%;
    --card-foreground: 0 0% 3.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 0 0% 3.9%;
    --primary: 0 72.2% 50.6%;
    --primary-foreground: 0 85.7% 97.3%;
    --secondary: 0 0% 96.1%;
    --secondary-foreground: 0 0% 9%;
    --muted: 0 0% 96.1%;
    --muted-foreground: 0 0% 45.1%;
    --accent: 0 0% 96.1%;
    --accent-foreground: 0 0% 9%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 89.8%;
    --input: 0 0% 89.8%;
    --ring: 0 72.2% 50.6%;
    --radius: 0.5rem;
    --chart-1: 12 76% 61%;
    --chart-2: 173 58% 39%;
    --chart-3: 197 37% 24%;
    --chart-4: 43 74% 66%;
    --chart-5: 27 87% 67%;
  }

  .dark {
    --background: 222.2 47.4% 11.2%; /* HSL equivalent of #0f172a */
    --foreground: 210 40% 98%; /* Light text for contrast */
    --card: 222.2 47.4% 11.2%; /* Match background for cards */
    --card-foreground: 210 40% 98%;
    --popover: 0 0% 3.9%;
    --popover-foreground: 0 0% 98%;
    --primary: 0 72.2% 50.6%;
    --primary-foreground: 0 85.7% 97.3%;
    --secondary: 0 0% 14.9%;
    --secondary-foreground: 0 0% 98%;
    --muted: 0 0% 14.9%;
    --muted-foreground: 0 0% 63.9%;
    --accent: 0 0% 14.9%;
    --accent-foreground: 0 0% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 14.9%;
    --input: 0 0% 14.9%;
    --ring: 0 72.2% 50.6%;
    --chart-1: 220 70% 50%;
    --chart-2: 160 60% 45%;
    --chart-3: 30 80% 55%;
    --chart-4: 280 65% 60%;
    --chart-5: 340 75% 55%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
    font-family:
      system-ui,
      -apple-system,
      BlinkMacSystemFont,
      "Segoe UI",
      Roboto,
      "Helvetica Neue",
      Arial,
      sans-serif,
      "Apple Color Emoji",
      "Segoe UI Emoji",
      "Segoe UI Symbol";
    font-feature-settings: "kern", "liga", "clig", "calt", "ss01", "ss02";
    font-kerning: normal;
    font-variant-ligatures: common-ligatures contextual;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    text-rendering: optimizeLegibility;
  }
}
```

### `src\app\layout.tsx`

```tsx
import { Toaster } from "sonner";
import { Inter, Fira_Code } from "next/font/google";
import "./globals.css";
import "../styles/theme.css";

const inter = Inter({
  subsets: ["latin"],
  variable: "--font-inter",
});

const firaCode = Fira_Code({
  subsets: ["latin"],
  variable: "--font-mono",
});

export const metadata = {
  title: "American Dream Taxes Hub",
  description: "Tax preparation and management platform",
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html
      lang="en"
      className={`${inter.variable} ${firaCode.variable}`}
      suppressHydrationWarning
    >
      <body
        className={`${inter.className} min-h-screen bg-background font-sans antialiased`}
        suppressHydrationWarning
      >
        <main className="relative flex min-h-screen flex-col">{children}</main>
        <Toaster position="bottom-right" />
      </body>
    </html>
  );
}
```

### `src\app\loading.tsx`

```tsx
export default function Loading() {
  return (
    <div className="flex h-screen items-center justify-center">
      <div className="h-8 w-8 animate-spin rounded-full border-4 border-primary border-t-transparent"></div>
    </div>
  );
}
```

### `src\app\not-found.tsx`

```tsx
import Link from "next/link";
import { Button } from "@/components/ui/button";

export default function NotFound() {
  return (
    <div className="flex h-screen flex-col items-center justify-center gap-4">
      <h2 className="text-2xl font-bold">Page Not Found</h2>
      <p className="text-muted-foreground">
        Could not find the requested resource
      </p>
      <Button asChild>
        <Link href="/">Return Home</Link>
      </Button>
    </div>
  );
}
```

### `src\app\page.tsx`

```tsx
import { headers } from "next/headers";
import { redirect } from "next/navigation";
import { AuthButton } from "@/components/auth/auth-button";

export default async function Home() {
  const headersList = headers();
  const protocol = headersList.get("x-forwarded-proto") || "http";
  const host = headersList.get("host");
  const baseUrl = `${protocol}://${host}`;

  // Use the auth route handler for session checks
  const res = await fetch(`${baseUrl}/api/auth`, {
    cache: "no-store",
  });

  if (res.ok) {
    const { session } = await res.json();
    if (session) {
      redirect("/dashboard");
    }
  }

  return (
    <main className="flex min-h-screen flex-col items-center justify-center p-24">
      <h1 className="text-4xl font-bold mb-8">
        Welcome to American Dream Taxes
      </h1>
      <p className="text-xl mb-4">Please sign in to continue</p>
      <div className="flex gap-4">
        <AuthButton type="sign-in" />
        <AuthButton type="sign-up" />
      </div>
    </main>
  );
}
```

### `src\app\providers.tsx`

```tsx
"use client";

import React from "react";
import { UnifiedAuthProvider } from "@/providers/unified-auth-provider";
import { QueryClientProvider } from "@tanstack/react-query";
import { queryClient } from "@/lib/react-query";

export function Providers({ children }: { children: React.ReactNode }) {
  return (
    <QueryClientProvider client={queryClient}>
      <UnifiedAuthProvider>{children}</UnifiedAuthProvider>
    </QueryClientProvider>
  );
}
```

### `src\app\actions\auth.ts`

```ts
"use server";

import { getRouteClient } from "@/lib/supabase/server-client";
import { revalidatePath } from "next/cache";
import { redirect } from "next/navigation";

export async function checkAuthServer() {
  const supabase = getRouteClient();
  const {
    data: { session },
    error,
  } = await supabase.auth.getSession();

  if (error) {
    throw new Error(error.message);
  }

  return session;
}

export async function signOutServer() {
  const supabase = getRouteClient();
  const { error } = await supabase.auth.signOut();

  if (error) {
    throw new Error(error.message);
  }

  revalidatePath("/");
  redirect("/login");
}

export async function refreshSessionServer() {
  const supabase = getRouteClient();
  const { data, error } = await supabase.auth.refreshSession();

  if (error) {
    throw new Error(error.message);
  }

  revalidatePath("/");
  return data;
}
```

### `src\app\analytics\page.tsx`

```tsx
"use client";

import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { supabaseBrowserClient } from "@/lib/supabaseBrowserClient";
// Simple chart placeholders - real app might use Recharts, Chart.js, etc.

export default function AnalyticsPage() {
  // Placeholder data
  const revenueData = [1000, 3000, 5000, 2000, 6000, 8000];
  const tasksCompletedData = [5, 10, 7, 12, 15, 20];

  return (
    <div className="p-6 space-y-4">
      <Card>
        <CardHeader>
          <CardTitle className="text-xl">Revenue Over Time</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="h-48 flex items-center justify-center bg-muted rounded">
            {/* Chart placeholder */}
            <span className="text-muted-foreground">
              [Revenue Chart Placeholder]
            </span>
          </div>
        </CardContent>
      </Card>

      <Card>
        <CardHeader>
          <CardTitle>Tasks Completed</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="h-48 flex items-center justify-center bg-muted rounded">
            <span className="text-muted-foreground">
              [Tasks Chart Placeholder]
            </span>
          </div>
        </CardContent>
      </Card>

      <Card>
        <CardHeader>
          <CardTitle>Export Data</CardTitle>
        </CardHeader>
        <CardContent>
          <p className="text-sm text-muted-foreground">
            Download analytics in CSV/PDF format for further analysis.
          </p>
          <Button variant="outline" className="mt-2">
            Export CSV
          </Button>
          <Button variant="outline" className="mt-2 ml-2">
            Export PDF
          </Button>
        </CardContent>
      </Card>
    </div>
  );
}
```

### `src\app\api\ai\classify-route\route.ts`

```ts
import { NextResponse } from "next/server";
import { classifyText } from "@/lib/ai/classify";

export async function POST(request: Request) {
  try {
    const { text } = await request.json();

    if (!text) {
      return NextResponse.json({ error: "Text is required" }, { status: 400 });
    }

    const category = await classifyText(text);
    return NextResponse.json({ category });
  } catch (error) {
    console.error("Classification Error:", error);
    return NextResponse.json(
      { error: "Failed to classify text" },
      { status: 500 },
    );
  }
}
```

### `src\app\api\ai\classify-task\route.ts`

```ts
import { NextResponse } from "next/server";
import { classifyTask, getCategorySuggestions } from "../../../../lib/ai/tasks";

export async function POST(request: Request) {
  try {
    const { title, description } = await request.json();

    if (!title || !description) {
      return NextResponse.json(
        { error: "Title and description are required" },
        { status: 400 },
      );
    }

    // Get both classification and suggestions
    const [category, suggestions] = await Promise.all([
      classifyTask(title, description),
      getCategorySuggestions(title, description),
    ]);

    return NextResponse.json({
      category,
      suggestions,
    });
  } catch (error) {
    console.error("Task classification error:", error);
    return NextResponse.json(
      { error: "Failed to classify task" },
      { status: 500 },
    );
  }
}
```

### `src\app\api\ai\generate\route.ts`

```ts
import { NextResponse } from "next/server";
import { summarizeText } from "@/lib/ai/summarize";

export async function POST(request: Request) {
  try {
    const { text, maxLength } = await request.json();

    if (!text) {
      return NextResponse.json({ error: "Text is required" }, { status: 400 });
    }

    const summary = await summarizeText(text, maxLength);
    return NextResponse.json({ summary });
  } catch (error) {
    console.error("Generate Error:", error);
    return NextResponse.json(
      { error: "Failed to generate summary" },
      { status: 500 },
    );
  }
}
```

### `src\app\api\auth\route.ts`

```ts
import { NextResponse } from "next/server";
import { createClient } from "@/lib/supabase/server";
import type { Database } from "@/types/database.types";

export async function GET() {
  const supabase = createClient();
  const {
    data: { user },
    error,
  } = await supabase.auth.getUser();

  if (error) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }

  if (!user) {
    return NextResponse.json({ error: "Not authenticated" }, { status: 401 });
  }

  // Get user profile data
  const { data: profile, error: profileError } = await supabase
    .from("profiles")
    .select("role, full_name")
    .eq("id", user.id)
    .single();

  if (profileError) {
    return NextResponse.json({ error: profileError.message }, { status: 500 });
  }

  return NextResponse.json({ user, profile });
}

export async function POST(request: Request) {
  const supabase = createClient();
  const { action, ...data } = await request.json();

  try {
    switch (action) {
      case "signOut":
        await supabase.auth.signOut();
        return NextResponse.json({ success: true });

      case "refreshSession":
        const {
          data: { session },
          error: refreshError,
        } = await supabase.auth.refreshSession();
        if (refreshError) throw refreshError;

        const {
          data: { user },
          error: userError,
        } = await supabase.auth.getUser();
        if (userError) throw userError;

        if (!user) {
          return NextResponse.json(
            { error: "Session invalid" },
            { status: 401 },
          );
        }

        // Get updated profile data
        const { data: profile, error: profileError } = await supabase
          .from("profiles")
          .select("role, full_name")
          .eq("id", user.id)
          .single();

        if (profileError) throw profileError;

        return NextResponse.json({ session, user, profile });

      default:
        return NextResponse.json({ error: "Invalid action" }, { status: 400 });
    }
  } catch (error) {
    console.error("Auth API error:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 },
    );
  }
}

export const dynamic = "force-dynamic";
```

### `src\app\api\clients\route.ts`

```ts
import { createRouteHandlerClient } from "@supabase/auth-helpers-nextjs";
import { cookies } from "next/headers";
import { NextResponse } from "next/server";
import { Database } from "@/types/database.types";
import { generateOnboardingTasks } from "@/lib/services/task.service";

export async function POST(request: Request) {
  try {
    const supabase = createRouteHandlerClient<Database>({ cookies });
    const json = await request.json();

    // Create the client
    const { data: client, error: clientError } = await supabase
      .from("clients")
      .insert(json)
      .select()
      .single();

    if (clientError) {
      throw clientError;
    }

    // Generate onboarding tasks if client type is provided
    if (client.type) {
      try {
        await generateOnboardingTasks(client.id, client.type);
      } catch (error) {
        console.error("Failed to generate onboarding tasks:", error);
        // Don't throw here - we still want to return the created client
      }
    }

    return NextResponse.json(client);
  } catch (error) {
    console.error("Error creating client:", error);
    return NextResponse.json(
      { error: "Failed to create client" },
      { status: 500 },
    );
  }
}

export async function GET(request: Request) {
  try {
    const supabase = createRouteHandlerClient<Database>({ cookies });
    const { data: clients, error } = await supabase
      .from("clients")
      .select("*")
      .order("created_at", { ascending: false });

    if (error) {
      throw error;
    }

    return NextResponse.json(clients);
  } catch (error) {
    console.error("Error fetching clients:", error);
    return NextResponse.json(
      { error: "Failed to fetch clients" },
      { status: 500 },
    );
  }
}

export async function PUT(request: Request) {
  try {
    const supabase = createRouteHandlerClient<Database>({ cookies });
    const json = await request.json();
    const { id, ...updates } = json;

    const { data: client, error } = await supabase
      .from("clients")
      .update(updates)
      .eq("id", id)
      .select()
      .single();

    if (error) {
      throw error;
    }

    return NextResponse.json(client);
  } catch (error) {
    console.error("Error updating client:", error);
    return NextResponse.json(
      { error: "Failed to update client" },
      { status: 500 },
    );
  }
}
```

### `src\app\api\documents\route.ts`

```ts
import { NextResponse } from "next/server";
import type { NextRequest } from "next/server";
import { createRouteHandlerClient } from "@supabase/auth-helpers-nextjs";
import { cookies } from "next/headers";
import { Database } from "@/types/database.types";

export async function GET(request: NextRequest) {
  const supabase = createRouteHandlerClient<Database>({ cookies });
  const { data: documents, error } = await supabase
    .from("client_documents")
    .select("*")
    .order("uploaded_at", { ascending: false });

  if (error) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }

  return NextResponse.json(documents);
}

export async function POST(request: NextRequest) {
  const supabase = createRouteHandlerClient<Database>({ cookies });
  const data = await request.json();

  const { data: document, error } = await supabase
    .from("client_documents")
    .insert([data])
    .select()
    .single();

  if (error) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }

  return NextResponse.json(document);
}

export async function PUT(request: NextRequest) {
  const supabase = createRouteHandlerClient<Database>({ cookies });
  const data = await request.json();
  const { id, ...updates } = data;

  const { data: document, error } = await supabase
    .from("client_documents")
    .update(updates)
    .eq("id", id)
    .select()
    .single();

  if (error) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }

  return NextResponse.json(document);
}

export async function DELETE(request: NextRequest) {
  const supabase = createRouteHandlerClient<Database>({ cookies });
  const { searchParams } = new URL(request.url);
  const id = searchParams.get("id");

  if (!id) {
    return NextResponse.json(
      { error: "Document ID is required" },
      { status: 400 },
    );
  }

  const { error } = await supabase
    .from("client_documents")
    .delete()
    .eq("id", id);

  if (error) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }

  return NextResponse.json({ success: true });
}
```

### `src\app\api\documents\reminders\route.ts`

```ts
import { createRouteHandlerClient } from "@supabase/auth-helpers-nextjs";
import { cookies } from "next/headers";
import { NextResponse } from "next/server";
import type { Database } from "@/types/database.types";

export async function GET(request: Request) {
  try {
    const supabase = createRouteHandlerClient<Database>({
      cookies,
      options: {
        auth: {
          persistSession: true,
          autoRefreshToken: true,
          detectSessionInUrl: true,
          flowType: "pkce",
        },
      },
    });

    const { data, error } = await supabase
      .from("document_reminders")
      .select("*")
      .order("due_date", { ascending: true });

    if (error) {
      throw error;
    }

    return NextResponse.json(data);
  } catch (error) {
    console.error("Error fetching reminders:", error);
    return NextResponse.json(
      { error: "Failed to fetch reminders" },
      { status: 500 },
    );
  }
}
```

### `src\app\api\documents\status\route.ts`

```ts
import { NextResponse } from "next/server";
import { createRouteHandlerClient } from "@supabase/auth-helpers-nextjs";
import { cookies } from "next/headers";
import { Database } from "@/types/database.types";

export async function GET(request: Request) {
  const supabase = createRouteHandlerClient<Database>({ cookies });
  const { searchParams } = new URL(request.url);
  const project_id = searchParams.get("project_id");

  if (!project_id) {
    return NextResponse.json(
      { error: "project_id is required" },
      { status: 400 },
    );
  }

  const { data: documents, error } = await supabase
    .from("document_tracking")
    .select("*")
    .eq("project_id", project_id);

  if (error) {
    return NextResponse.json(
      { error: "Failed to fetch document status" },
      { status: 500 },
    );
  }

  return NextResponse.json(documents);
}
```

### `src\app\api\documents\upload\route.ts`

```ts
import { NextResponse } from "next/server";
import { createServerComponentClient } from "@supabase/auth-helpers-nextjs";
import { cookies } from "next/headers";
import {
  categorizeDocument,
  suggestDocumentName,
  extractYearFromFileName,
} from "@/lib/services/document-categorization";
import type { Document } from "@/types/documents";

export async function POST(request: Request) {
  try {
    const formData = await request.formData();
    const file = formData.get("file") as File;
    const projectId = formData.get("projectId") as string;
    const clientId = formData.get("clientId") as string;
    const metadata = formData.get("metadata")
      ? JSON.parse(formData.get("metadata") as string)
      : undefined;

    if (!file || !projectId || !clientId) {
      return NextResponse.json(
        { error: "Missing required fields" },
        { status: 400 },
      );
    }

    // Initialize Supabase client
    const supabase = createServerComponentClient({ cookies });

    // Get current user
    const {
      data: { user },
    } = await supabase.auth.getUser();
    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // Categorize document
    const category = await categorizeDocument(file.name, file.type);
    const year = extractYearFromFileName(file.name);

    // Generate storage path with metadata
    const storagePath = suggestDocumentName(
      file.name,
      category,
      year,
      metadata,
    );

    // Upload file to storage
    const { data: storageData, error: storageError } = await supabase.storage
      .from("documents")
      .upload(storagePath, file, {
        cacheControl: "3600",
        upsert: false,
      });

    if (storageError) {
      throw storageError;
    }

    // Create document record in database
    const documentData: Omit<Document, "id"> = {
      project_id: projectId,
      client_id: clientId,
      name: file.name,
      storage_path: storagePath,
      category,
      type: file.type,
      size: file.size,
      year,
      uploaded_at: new Date().toISOString(),
      uploaded_by: user.id,
      status: "pending",
      metadata,
    };

    const { data: document, error: dbError } = await supabase
      .from("documents")
      .insert(documentData)
      .select()
      .single();

    if (dbError) {
      // Cleanup storage if database insert fails
      await supabase.storage.from("documents").remove([storagePath]);
      throw dbError;
    }

    // Create document tracking record
    const { error: trackingError } = await supabase
      .from("document_tracking")
      .insert({
        document_id: document.id,
        project_id: projectId,
        status: "received",
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      });

    if (trackingError) {
      console.error("Error creating document tracking:", trackingError);
      // Don't throw here, as the document was still created successfully
    }

    return NextResponse.json(document);
  } catch (error) {
    console.error("Error uploading document:", error);
    return NextResponse.json(
      { error: "Failed to upload document" },
      { status: 500 },
    );
  }
}
```

### `src\app\api\projects\route.ts`

```ts
import { createRouteHandlerClient } from "@supabase/auth-helpers-nextjs";
import { cookies } from "next/headers";
import type {
  DbProject,
  ProjectFormData,
  DbProjectUpdate,
} from "@/types/projects";
import { NextResponse } from "next/server";

export async function GET() {
  try {
    const supabase = createRouteHandlerClient({ cookies });
    const { data: projects, error } = await supabase
      .from("projects")
      .select("*")
      .order("created_at", { ascending: false });

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 });
    }

    return NextResponse.json(projects);
  } catch (error) {
    console.error("Error fetching projects:", error);
    return NextResponse.json(
      { error: "Internal Server Error" },
      { status: 500 },
    );
  }
}

export async function POST(request: Request) {
  try {
    const supabase = createRouteHandlerClient({ cookies });
    const projectData: ProjectFormData = await request.json();

    const { data: project, error } = await supabase
      .from("projects")
      .insert([projectData])
      .select()
      .single();

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 });
    }

    return NextResponse.json(project);
  } catch (error) {
    console.error("Error creating project:", error);
    return NextResponse.json(
      { error: "Internal Server Error" },
      { status: 500 },
    );
  }
}

export async function PUT(request: Request) {
  try {
    const supabase = createRouteHandlerClient({ cookies });
    const projectData: DbProjectUpdate = await request.json();
    const { id, ...updateData } = projectData;

    if (!id) {
      return NextResponse.json(
        { error: "Project ID is required" },
        { status: 400 },
      );
    }

    const { data: project, error } = await supabase
      .from("projects")
      .update(updateData)
      .eq("id", id)
      .select()
      .single();

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 });
    }

    return NextResponse.json(project);
  } catch (error) {
    console.error("Error updating project:", error);
    return NextResponse.json(
      { error: "Internal Server Error" },
      { status: 500 },
    );
  }
}

export async function DELETE(request: Request) {
  try {
    const supabase = createRouteHandlerClient({ cookies });
    const { id } = await request.json();

    if (!id) {
      return NextResponse.json(
        { error: "Project ID is required" },
        { status: 400 },
      );
    }

    const { error } = await supabase.from("projects").delete().eq("id", id);

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 });
    }

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error("Error deleting project:", error);
    return NextResponse.json(
      { error: "Internal Server Error" },
      { status: 500 },
    );
  }
}

export const dynamic = "force-dynamic";
```

### `src\app\api\projects\bulk\route.ts`

```ts
import { createServerClient } from "@supabase/ssr";
import { cookies } from "next/headers";
import { NextResponse } from "next/server";
import type { Database } from "@/types/database.types";

export async function POST(request: Request) {
  try {
    const cookieStore = cookies();

    const supabase = createServerClient<Database>(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
      {
        cookies: {
          get(name: string) {
            return cookieStore.get(name)?.value;
          },
          set(name: string, value: string, options: any) {
            try {
              cookieStore.set({ name, value, ...options });
            } catch (error) {
              // Handle cookie parsing errors
              console.error("Error setting cookie:", error);
            }
          },
          remove(name: string, options: any) {
            try {
              cookieStore.set({ name, value: "", ...options, maxAge: 0 });
            } catch (error) {
              // Handle cookie parsing errors
              console.error("Error removing cookie:", error);
            }
          },
        },
      },
    );

    const projects = await request.json();

    const { data, error } = await supabase
      .from("projects")
      .insert(projects)
      .select();

    if (error) {
      throw error;
    }

    return NextResponse.json(data);
  } catch (error) {
    console.error("Error creating projects:", error);
    return NextResponse.json(
      { error: "Failed to create projects" },
      { status: 500 },
    );
  }
}

export const dynamic = "force-dynamic";
```

### `src\app\api\projects\__tests__\route.test.ts`

```ts
import { NextRequest } from "next/server";
import { createRouteHandlerClient } from "@supabase/auth-helpers-nextjs";
import { cookies } from "next/headers";
import { GET } from "../route";
import { createMockSupabaseClient } from "@/lib/supabase/__mocks__/supabase";

jest.mock("@supabase/auth-helpers-nextjs", () => ({
  createRouteHandlerClient: jest.fn(),
}));

jest.mock("next/headers", () => ({
  cookies: jest.fn(),
}));

describe("GET /api/projects", () => {
  let mockSupabase: ReturnType<typeof createMockSupabaseClient>;

  beforeEach(() => {
    mockSupabase = createMockSupabaseClient();
    (createRouteHandlerClient as jest.Mock).mockReturnValue(mockSupabase);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  it("should return projects", async () => {
    const mockProjects = [{ id: 1, name: "Project 1" }];
    mockSupabase
      .from("projects")
      .select.mockResolvedValue({ data: mockProjects, error: null });

    const request = new NextRequest("http://localhost:3000/api/projects");
    const response = await GET(request);
    const data = await response.json();

    expect(data).toEqual(mockProjects);
    expect(mockSupabase.from).toHaveBeenCalledWith("projects");
    expect(mockSupabase.from("projects").select).toHaveBeenCalled();
  });

  it("should handle errors", async () => {
    const mockError = new Error("Database error");
    mockSupabase.from("projects").select.mockRejectedValue(mockError);

    const request = new NextRequest("http://localhost:3000/api/projects");
    const response = await GET(request);
    const data = await response.json();

    expect(response.status).toBe(500);
    expect(data).toEqual({ error: "Failed to fetch projects" });
  });
});
```

### `src\app\api\tasks\route.ts`

```ts
import { createRouteHandlerClient } from "@supabase/auth-helpers-nextjs";
import { cookies } from "next/headers";
import { NextResponse } from "next/server";
import { Database } from "@/types/database.types";
import { taskSchema } from "@/types/validation";
import type { z } from "zod";

type TaskInsert = Database["public"]["Tables"]["tasks"]["Insert"];
type ValidatedTask = z.infer<typeof taskSchema>;
type ChecklistItemInsert =
  Database["public"]["Tables"]["checklist_items"]["Insert"];
type ActivityLogInsert =
  Database["public"]["Tables"]["activity_log_entries"]["Insert"];

interface TaskInput extends ValidatedTask {
  checklistItems?: Array<{
    title: string;
    description?: string | null;
    completed?: boolean;
  }>;
}

export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    const projectId = searchParams.get("projectId");
    const clientId = searchParams.get("clientId");
    const assigneeId = searchParams.get("assigneeId");

    const supabase = createRouteHandlerClient<Database>({ cookies });

    let query = supabase.from("tasks").select(`
        *,
        assignee:profiles(id, full_name, email),
        project:projects(id, name),
        parent_task:tasks(id, title),
        checklist_items(*),
        activity_log_entries(*)
      `);

    if (projectId) {
      query = query.eq("project_id", projectId);
    }
    if (clientId) {
      query = query.eq("client_id", clientId);
    }
    if (assigneeId) {
      query = query.eq("assignee_id", assigneeId);
    }

    const { data, error } = await query;

    if (error) {
      throw error;
    }

    return NextResponse.json(data);
  } catch (error) {
    console.error("Error fetching tasks:", error);
    return NextResponse.json(
      { error: "Failed to fetch tasks" },
      { status: 500 },
    );
  }
}

export async function POST(request: Request) {
  try {
    const formData: TaskInput = await request.json();
    const { checklistItems, ...taskData } = formData;
    const validatedData = taskSchema.parse(taskData);

    const supabase = createRouteHandlerClient<Database>({ cookies });

    // Insert task first
    const { data: task, error: taskError } = await supabase
      .from("tasks")
      .insert([
        {
          title: validatedData.title,
          description: validatedData.description,
          status: validatedData.status,
          priority: validatedData.priority,
          due_date: validatedData.due_date,
          assignee_id: validatedData.assignee_id,
          project_id: validatedData.project_id,
        } satisfies TaskInsert,
      ])
      .select()
      .single();

    if (taskError) throw taskError;

    // Handle checklist items if provided
    if (checklistItems?.length) {
      const { error: checklistError } = await supabase
        .from("checklist_items")
        .insert(
          checklistItems.map((item) => ({
            task_id: task.id,
            title: item.title,
            description: item.description,
            completed: item.completed || false,
          })),
        );

      if (checklistError) throw checklistError;
    }

    // Add activity log entry
    const { error: activityError } = await supabase
      .from("activity_log_entries")
      .insert({
        task_id: task.id,
        action: "created",
        details: { status: task.status },
      });

    if (activityError) throw activityError;

    return NextResponse.json(task);
  } catch (error) {
    console.error("Error creating task:", error);
    return NextResponse.json(
      { error: "Failed to create task" },
      { status: 500 },
    );
  }
}

export async function PUT(request: Request) {
  try {
    const { id, checklistItems, ...updates }: TaskInput & { id: string } =
      await request.json();

    if (!id || typeof id !== "string") {
      return NextResponse.json(
        { error: "Valid task ID (UUID) is required" },
        { status: 400 },
      );
    }

    const validatedData = taskSchema.partial().parse(updates);
    const supabase = createRouteHandlerClient<Database>({ cookies });

    // Update task
    const { data: task, error: taskError } = await supabase
      .from("tasks")
      .update({
        title: validatedData.title,
        description: validatedData.description,
        status: validatedData.status,
        priority: validatedData.priority,
        due_date: validatedData.due_date,
        assignee_id: validatedData.assignee_id,
        project_id: validatedData.project_id,
      })
      .eq("id", id)
      .select()
      .single();

    if (taskError) throw taskError;

    // Handle checklist items if provided
    if (checklistItems !== undefined) {
      // Delete existing items
      await supabase.from("checklist_items").delete().eq("task_id", id);

      // Insert new items
      if (checklistItems.length > 0) {
        const { error: checklistError } = await supabase
          .from("checklist_items")
          .insert(
            checklistItems.map(
              (item) =>
                ({
                  task_id: id,
                  title: item.title,
                  description: item.description,
                  completed: item.completed || false,
                }) satisfies ChecklistItemInsert,
            ),
          );

        if (checklistError) throw checklistError;
      }
    }

    // Add activity log entry for update
    const { error: activityError } = await supabase
      .from("activity_log_entries")
      .insert({
        task_id: id,
        action: "updated",
        details: { updates: validatedData },
      } satisfies ActivityLogInsert);

    if (activityError) throw activityError;

    return NextResponse.json(task);
  } catch (error) {
    console.error("Error updating task:", error);
    return NextResponse.json(
      { error: "Failed to update task" },
      { status: 500 },
    );
  }
}

export async function DELETE(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    const id = searchParams.get("id");

    if (!id || typeof id !== "string") {
      return NextResponse.json(
        { error: "Valid task ID (UUID) is required" },
        { status: 400 },
      );
    }

    const supabase = createRouteHandlerClient<Database>({ cookies });

    // Delete related records first (due to foreign key constraints)
    await Promise.all([
      supabase.from("checklist_items").delete().eq("task_id", id),
      supabase.from("activity_log_entries").delete().eq("task_id", id),
    ]);

    // Then delete the task
    const { error } = await supabase.from("tasks").delete().eq("id", id);

    if (error) throw error;

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error("Error deleting task:", error);
    return NextResponse.json(
      { error: "Failed to delete task" },
      { status: 500 },
    );
  }
}

export const dynamic = "force-dynamic";
```

### `src\app\api\tasks\generate\route.ts`

```ts
import { NextResponse } from "next/server";
import { createRouteHandlerClient } from "@supabase/auth-helpers-nextjs";
import { cookies } from "next/headers";
import { Database } from "@/types/database.types";
import { classifyTask } from "@/lib/ai/tasks";

interface TemplateTask {
  title: string;
  description: string;
}

export async function POST(request: Request) {
  try {
    const supabase = createRouteHandlerClient<Database>({
      cookies,
      options: {
        auth: {
          persistSession: true,
          autoRefreshToken: true,
        },
      },
    });

    const { project_id, template_id } = await request.json();

    if (!project_id || !template_id) {
      return NextResponse.json(
        { error: "project_id and template_id are required" },
        { status: 400 },
      );
    }

    // Fetch template tasks
    const { data: templateTasks, error } = await supabase
      .from("template_tasks")
      .select("*")
      .eq("template_id", template_id);

    if (error) {
      return NextResponse.json(
        { error: "Failed to fetch template tasks" },
        { status: 500 },
      );
    }

    // Insert tasks for project with classification
    const tasksToInsert = await Promise.all(
      templateTasks.map(async (task: TemplateTask) => {
        const category = await classifyTask(task.title, task.description);
        return {
          project_id,
          title: task.title,
          description: task.description,
          status: "not_started",
          category,
        };
      }),
    );

    const { data: insertedTasks, error: insertError } = await supabase
      .from("tasks")
      .insert(tasksToInsert)
      .select();

    if (insertError) {
      console.error("Failed to insert tasks:", insertError);
      return NextResponse.json(
        { error: "Failed to generate tasks", details: insertError.message },
        { status: 500 },
      );
    }

    return NextResponse.json(insertedTasks);
  } catch (error) {
    console.error("Error generating tasks:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 },
    );
  }
}

export const dynamic = "force-dynamic";
```

### `src\app\api\tax-returns\[id]\route.ts`

```ts
import { createRouteHandlerClient } from "@supabase/auth-helpers-nextjs";
import { NextResponse } from "next/server";
import { cookies } from "next/headers";
import { Database } from "@/types/database.types";

export async function GET(
  request: Request,
  { params }: { params: { id: string } },
) {
  try {
    const supabase = createRouteHandlerClient<Database>({ cookies });

    const { data, error } = await supabase
      .from("tax_returns")
      .select(
        `
        *,
        client:client_id (*),
        project:project_id (*),
        documents:documents (*)
      `,
      )
      .eq("id", params.id)
      .single();

    if (error) {
      throw error;
    }

    return NextResponse.json(data);
  } catch (error) {
    console.error("Error fetching tax return:", error);
    return NextResponse.json(
      { error: "Failed to fetch tax return" },
      { status: 500 },
    );
  }
}

export async function PUT(
  request: Request,
  { params }: { params: { id: string } },
) {
  try {
    const supabase = createRouteHandlerClient<Database>({ cookies });
    const updates = await request.json();

    try {
      // Update tax return
      const { error: updateError } = await supabase
        .from("tax_returns")
        .update({
          ...updates,
          updated_at: new Date().toISOString(),
        })
        .eq("id", params.id);

      if (updateError) {
        throw updateError;
      }

      // If status is changed to 'completed', update related project
      if (updates.status === "completed") {
        const { error: projectError } = await supabase
          .from("projects")
          .update({
            status: "completed",
            updated_at: new Date().toISOString(),
          })
          .eq("tax_return_id", params.id);

        if (projectError) {
          throw projectError;
        }
      }

      // Commit transaction
      await supabase.rpc("commit_transaction");

      // Fetch updated tax return
      const { data: taxReturn, error: fetchError } = await supabase
        .from("tax_returns")
        .select(
          `
          *,
          client:client_id (*),
          project:project_id (*),
          documents:documents (*)
        `,
        )
        .eq("id", params.id)
        .single();

      if (fetchError) {
        throw fetchError;
      }

      return NextResponse.json(taxReturn);
    } catch (error) {
      // Rollback transaction on error
      await supabase.rpc("rollback_transaction");
      throw error;
    }
  } catch (error) {
    console.error("Error updating tax return:", error);
    return NextResponse.json(
      { error: "Failed to update tax return" },
      { status: 500 },
    );
  }
}

export const dynamic = "force-dynamic";
```

### `src\app\api\templates\route.test.ts`

```ts
import { NextRequest } from "next/server";
import { createRouteHandlerClient } from "@supabase/auth-helpers-nextjs";
import { cookies } from "next/headers";
import { GET } from "./route";
import { createMockSupabaseClient } from "@/lib/supabase/__mocks__/supabase";

jest.mock("@supabase/auth-helpers-nextjs", () => ({
  createRouteHandlerClient: jest.fn(),
}));

jest.mock("next/headers", () => ({
  cookies: jest.fn(),
}));

describe("GET /api/templates", () => {
  let mockSupabase: ReturnType<typeof createMockSupabaseClient>;

  beforeEach(() => {
    mockSupabase = createMockSupabaseClient();
    (createRouteHandlerClient as jest.Mock).mockReturnValue(mockSupabase);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  it("should return templates", async () => {
    const mockTemplates = [{ id: 1, name: "Template 1" }];
    mockSupabase
      .from("templates")
      .select.mockResolvedValue({ data: mockTemplates, error: null });

    const request = new NextRequest("http://localhost:3000/api/templates");
    const response = await GET(request);
    const data = await response.json();

    expect(data).toEqual(mockTemplates);
    expect(mockSupabase.from).toHaveBeenCalledWith("templates");
    expect(mockSupabase.from("templates").select).toHaveBeenCalled();
  });

  it("should handle errors", async () => {
    const mockError = new Error("Database error");
    mockSupabase.from("templates").select.mockRejectedValue(mockError);

    const request = new NextRequest("http://localhost:3000/api/templates");
    const response = await GET(request);
    const data = await response.json();

    expect(response.status).toBe(500);
    expect(data).toEqual({ error: "Failed to fetch templates" });
  });
});
```

### `src\app\api\templates\route.ts`

```ts
import { NextResponse } from "next/server";
import { createRouteHandlerClient } from "@supabase/auth-helpers-nextjs";
import { cookies } from "next/headers";
import { Database } from "@/types/database.types";

type TemplateRow = Database["public"]["Tables"]["project_templates"]["Row"];
type TemplateInsert =
  Database["public"]["Tables"]["project_templates"]["Insert"];

export async function GET() {
  try {
    const supabase = createRouteHandlerClient<Database>({ cookies });
    const { data: templates, error } = await supabase
      .from("project_templates")
      .select("*")
      .order("created_at", { ascending: false });

    if (error) throw error;

    return NextResponse.json(templates);
  } catch (error) {
    console.error("Error fetching templates:", error);
    return NextResponse.json(
      { error: "Failed to fetch templates" },
      { status: 500 },
    );
  }
}

export async function POST(request: Request) {
  try {
    const supabase = createRouteHandlerClient<Database>({ cookies });
    const template = (await request.json()) as TemplateInsert;

    const { data, error } = await supabase
      .from("project_templates")
      .insert(template)
      .select()
      .single();

    if (error) throw error;

    return NextResponse.json(data);
  } catch (error) {
    console.error("Error creating template:", error);
    return NextResponse.json(
      { error: "Failed to create template" },
      { status: 500 },
    );
  }
}
```

### `src\app\api\workflows\route.ts`

```ts
import { createRouteHandlerClient } from "@supabase/auth-helpers-nextjs";
import { cookies } from "next/headers";
import { NextResponse } from "next/server";
import type { Database } from "@/types/database.types";

type CreateWorkflowRequest = {
  title: string;
  description?: string;
  steps: any[];
};

export async function GET() {
  const supabase = createRouteHandlerClient<Database>({ cookies });
  try {
    const { data, error } = await supabase.from("workflow_templates").select();
    if (error) throw error;
    return NextResponse.json(data);
  } catch (error) {
    return new NextResponse("Error fetching workflows", { status: 500 });
  }
}

export async function POST(request: Request) {
  const supabase = createRouteHandlerClient<Database>({ cookies });
  try {
    const body = (await request.json()) as CreateWorkflowRequest;
    if (!body.title || !Array.isArray(body.steps)) {
      return new NextResponse("Missing required fields", { status: 400 });
    }

    const { data, error } = await supabase
      .from("workflow_templates")
      .insert({
        name: body.title,
        description: body.description,
        steps: body.steps,
        created_at: new Date().toISOString(),
      })
      .select()
      .single();

    if (error) throw error;
    return NextResponse.json(data);
  } catch (error) {
    return new NextResponse("Error creating workflow", { status: 500 });
  }
}
```

### `src\app\api\workflows\tax-return\route.ts`

```ts
import { createRouteHandlerClient } from "@supabase/auth-helpers-nextjs";
import { NextResponse } from "next/server";
import { cookies } from "next/headers";
import { Database } from "@/types/database.types";

export async function GET() {
  const supabase = createRouteHandlerClient<Database>({ cookies });

  const workflowStages = [
    {
      stage: "Client Intake",
      tasks: ["New client form", "Engagement letter"],
    },
    {
      stage: "Document Collection",
      tasks: ["Document checklist", "Reminders"],
    },
    {
      stage: "Preparation",
      tasks: ["Data entry", "Calculations"],
    },
    {
      stage: "Review",
      tasks: ["Quality check", "Client approval"],
    },
    {
      stage: "Filing",
      tasks: ["E-file submission", "Paper filing"],
    },
    {
      stage: "Follow-up",
      tasks: ["Acknowledgement", "Amendments"],
    },
  ];

  return NextResponse.json(workflowStages);
}
```

### `src\app\auth\callback\route.ts`

```ts
import { createServerClient } from "@supabase/ssr";
import { cookies } from "next/headers";
import { NextResponse } from "next/server";
import type { Database } from "@/types/database.types";

export async function GET(request: Request) {
  const { searchParams, origin } = new URL(request.url);
  const code = searchParams.get("code");
  const next = searchParams.get("next") ?? "/dashboard";

  if (!code) {
    console.error("No code in request");
    return NextResponse.redirect(
      `${origin}/login?error=No authorization code found`,
    );
  }

  try {
    const cookieStore = cookies();

    const supabase = createServerClient<Database>(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
      {
        cookies: {
          get(name: string) {
            return cookieStore.get(name)?.value;
          },
          set(name: string, value: string, options: any) {
            try {
              cookieStore.set({ name, value, ...options });
            } catch (error) {
              // Handle cookie parsing errors
              console.error("Error setting cookie:", error);
            }
          },
          remove(name: string, options: any) {
            try {
              cookieStore.set({ name, value: "", ...options, maxAge: 0 });
            } catch (error) {
              // Handle cookie parsing errors
              console.error("Error removing cookie:", error);
            }
          },
        },
      },
    );

    const { error } = await supabase.auth.exchangeCodeForSession(code);

    if (error) {
      console.error("Auth error:", error.message);
      return NextResponse.redirect(
        `${origin}/login?error=${encodeURIComponent(error.message)}`,
      );
    }

    return NextResponse.redirect(`${origin}${next}`);
  } catch (error) {
    console.error("Callback error:", error);
    return NextResponse.redirect(`${origin}/login?error=Authentication failed`);
  }
}
```

### `src\app\auth\login\page.tsx`

```tsx
import { createClient } from "@/lib/supabase/server";
import { redirect } from "next/navigation";
import { LoginForm } from "@/components/auth/login-form";

export default async function LoginPage() {
  const supabase = createClient();

  const {
    data: { session },
  } = await supabase.auth.getSession();

  if (session) {
    redirect("/dashboard");
  }

  return (
    <div className="container mx-auto py-10">
      <LoginForm />
    </div>
  );
}
```

### `src\app\auth\signup\page.tsx`

```tsx
import { redirect } from "next/navigation";
import { getServerClient } from "@/lib/supabase/server-client";
import { SignUpForm } from "@/components/auth/signup-form";

export default async function SignUpPage() {
  const supabase = getServerClient();
  const {
    data: { session },
  } = await supabase.auth.getSession();

  if (session) {
    redirect("/dashboard");
  }

  return <SignUpForm />;
}
```

### `src\app\batch-operations\page.tsx`

```tsx
"use client";

import { useState } from "react";
import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { supabaseBrowserClient } from "@/lib/supabaseBrowserClient";

interface SelectedItem {
  type: "client" | "document" | "return";
  id: string | number;
}

export default function BatchOperationsPage() {
  const [selectedItems, setSelectedItems] = useState<SelectedItem[]>([]);

  function addSelectedItem(item: SelectedItem) {
    setSelectedItems((prev) => [...prev, item]);
  }

  async function handleDeleteAll() {
    for (const item of selectedItems) {
      // This is a naive approach; real logic will vary
      const table =
        item.type === "client"
          ? "clients"
          : item.type === "document"
            ? "documents"
            : "tax_returns";
      await supabaseBrowserClient.from(table).delete().eq("id", item.id);
    }
    alert(`Deleted ${selectedItems.length} items.`);
    setSelectedItems([]);
  }

  return (
    <div className="p-6 space-y-4">
      <Card>
        <CardHeader>
          <CardTitle className="text-xl">Batch Operations</CardTitle>
        </CardHeader>
        <CardContent>
          <p className="text-sm text-muted-foreground">
            Select multiple items from different tables and perform bulk
            actions.
          </p>
          <Button className="mt-2" variant="outline" onClick={handleDeleteAll}>
            Delete Selected
          </Button>
        </CardContent>
      </Card>

      {/* Example placeholders for adding items */}
      <Card>
        <CardHeader>
          <CardTitle>Add Items to Selection</CardTitle>
        </CardHeader>
        <CardContent className="space-y-2">
          <Button
            variant="outline"
            onClick={() => addSelectedItem({ type: "client", id: "client-42" })}
          >
            Add Client #42
          </Button>
          <Button
            variant="outline"
            onClick={() => addSelectedItem({ type: "document", id: 99 })}
          >
            Add Document #99
          </Button>
          <Button
            variant="outline"
            onClick={() => addSelectedItem({ type: "return", id: 123 })}
          >
            Add Return #123
          </Button>
        </CardContent>
      </Card>

      {selectedItems.length > 0 && (
        <Card>
          <CardHeader>
            <CardTitle>Currently Selected Items</CardTitle>
          </CardHeader>
          <CardContent>
            <ul className="space-y-1">
              {selectedItems.map((item, idx) => (
                <li key={idx}>
                  <strong>{item.type}:</strong> {item.id}
                </li>
              ))}
            </ul>
          </CardContent>
        </Card>
      )}
    </div>
  );
}
```

### `src\app\clients\page.tsx`

```tsx
import { getSupabaseServerClient } from "@/lib/supabaseServerClient";
import ClientList from "@/components/client/ClientList";
import { Database } from "@/types/database.types";

async function getClients() {
  const supabase = getSupabaseServerClient();
  const { data: clients } = await supabase.from("clients").select("*");
  return clients || [];
}

export default async function ClientsPage() {
  const initialClients = await getClients();

  return (
    <main className="p-4">
      <h1 className="text-xl font-bold mb-4">Clients</h1>
      <ClientList initialClients={initialClients} />
    </main>
  );
}
```

### `src\app\clients\[clientId]\page.tsx`

```tsx
import { notFound } from "next/navigation";
import { getSupabaseServerClient } from "@/lib/supabaseServerClient";
import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Database } from "@/types/database.types";

type Client = Database["public"]["Tables"]["clients"]["Row"];
type DocumentRow = Database["public"]["Tables"]["documents"]["Row"];

export const revalidate = 0;

async function getClientData(id: string) {
  const supabase = getSupabaseServerClient();
  const { data: clientData } = await supabase
    .from("clients")
    .select("*")
    .eq("id", id)
    .single();
  return clientData;
}

async function getClientDocuments(id: string) {
  const supabase = getSupabaseServerClient();
  const { data: docs } = await supabase
    .from("documents")
    .select("*")
    .eq("client_id", id);
  return docs || [];
}

export default async function ClientProfilePage({
  params,
}: {
  params: { clientId: string };
}) {
  const { clientId } = params;
  const clientData = await getClientData(clientId);
  if (!clientData) {
    notFound();
  }
  const clientDocs = await getClientDocuments(clientId);

  return (
    <div className="p-6 space-y-6">
      <Card>
        <CardHeader>
          <CardTitle>Client Profile</CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          <h2 className="text-lg font-semibold">{clientData?.full_name}</h2>
          <p className="text-sm text-muted-foreground">
            {clientData?.contact_email}
          </p>
          <p className="text-sm text-muted-foreground">{clientData?.phone}</p>
          <Button variant="outline" size="sm">
            Edit Profile
          </Button>
        </CardContent>
      </Card>

      <Card>
        <CardHeader>
          <CardTitle>Documents</CardTitle>
        </CardHeader>
        <CardContent>
          {clientDocs.length === 0 ? (
            <p className="text-sm text-muted-foreground">
              No documents uploaded.
            </p>
          ) : (
            <ul className="space-y-2">
              {clientDocs.map((doc) => (
                <li key={doc.id} className="flex items-center justify-between">
                  <span>{doc.file_name}</span>
                  <Button variant="outline" size="sm">
                    View
                  </Button>
                </li>
              ))}
            </ul>
          )}
        </CardContent>
      </Card>
    </div>
  );
}
```

### `src\app\clients\[id]\page.tsx`

```tsx
import { notFound } from "next/navigation";
import { getServerClient } from "@/lib/supabase/server-client";
import type { ClientWithRelations } from "@/types/clients";

export default async function ClientPage({
  params,
}: {
  params: { id: string };
}) {
  const supabase = getServerClient();

  const { data, error } = await supabase
    .from("clients")
    .select(
      `
      *,
      contact_details:client_contact_details(*)
    `,
    )
    .eq("id", params.id)
    .single<ClientWithRelations>();

  if (error || !data) {
    notFound();
  }

  const client = data;

  return (
    <div className="container mx-auto p-4">
      <h1 className="text-2xl font-bold mb-4">Client Details</h1>
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        <div className="bg-white p-6 rounded-lg shadow">
          <h2 className="text-xl font-semibold mb-4">Basic Information</h2>
          <div className="space-y-2">
            <p>
              <span className="font-medium">Name:</span>{" "}
              {client.full_name || client.company_name}
            </p>
            <p>
              <span className="font-medium">Email:</span> {client.contact_email}
            </p>
            <p>
              <span className="font-medium">Phone:</span>{" "}
              {client.contact_details?.phone || "N/A"}
            </p>
          </div>
        </div>

        <div className="bg-white p-6 rounded-lg shadow">
          <h2 className="text-xl font-semibold mb-4">Additional Details</h2>
          <div className="space-y-2">
            <p>
              <span className="font-medium">Address:</span>{" "}
              {client.contact_details?.address || "N/A"}
            </p>
            <p>
              <span className="font-medium">City:</span>{" "}
              {client.contact_details?.city || "N/A"}
            </p>
            <p>
              <span className="font-medium">State:</span>{" "}
              {client.contact_details?.state || "N/A"}
            </p>
            <p>
              <span className="font-medium">Zip:</span>{" "}
              {client.contact_details?.zip || "N/A"}
            </p>
          </div>
        </div>
      </div>
    </div>
  );
}
```

### `src\app\dashboard\layout.tsx`

```tsx
import Sidebar from "@/components/dashboard/Sidebar";
import { UserNav } from "@/components/dashboard/UserNav";
import Link from "next/link";
import { redirect } from "next/navigation";
import { createClient } from "@/lib/supabase/server";

export default async function DashboardLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const supabase = createClient();
  const {
    data: { session },
  } = await supabase.auth.getSession();

  if (!session) {
    redirect("/auth/login");
  }

  return (
    <div className="flex h-screen">
      <Sidebar />
      <div className="flex-1 flex flex-col">
        <header className="h-16 border-b flex items-center justify-between px-6">
          <Link href="/dashboard" className="text-xl font-semibold">
            American Dream Taxes
          </Link>
          <UserNav />
        </header>
        <main className="flex-1 overflow-y-auto p-6">{children}</main>
      </div>
    </div>
  );
}
```

### `src\app\dashboard\loading.tsx`

```tsx
export default function Loading() {
  return (
    <div className="flex items-center justify-center h-[80vh]">
      <p>Loading dashboard...</p>
    </div>
  );
}
```

### `src\app\dashboard\page.tsx`

```tsx
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";

export default function DashboardPage() {
  // Placeholder for metrics
  const revenue = 54321.98;
  const clientsCount = 55;
  const pendingTaxReturns = 12;
  const deadlines = [
    { id: "deadline-1", label: "Q4 Tax Payment", date: "2024-01-15" },
    { id: "deadline-2", label: "Year End Filing", date: "2023-12-31" },
  ];
  const recentActivities = [
    { id: 1, text: "Client John Doe uploaded W-2" },
    { id: 2, text: "Alice Johnson completed tax return" },
    { id: 3, text: "New client Onboarding: Sarah James" },
  ];

  return (
    <div className="space-y-8 p-6">
      <div className="grid gap-4 md:grid-cols-4">
        <Card>
          <CardHeader>
            <CardTitle>Revenue</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-3xl font-bold">${revenue.toFixed(2)}</div>
          </CardContent>
        </Card>
        <Card>
          <CardHeader>
            <CardTitle>Clients</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-3xl font-bold">{clientsCount}</div>
          </CardContent>
        </Card>
        <Card>
          <CardHeader>
            <CardTitle>Pending Returns</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-3xl font-bold">{pendingTaxReturns}</div>
          </CardContent>
        </Card>
        <Card>
          <CardHeader>
            <CardTitle>Deadlines</CardTitle>
          </CardHeader>
          <CardContent>
            {deadlines.length === 0 ? (
              <p className="text-muted-foreground text-sm">
                No upcoming deadlines
              </p>
            ) : (
              <ul className="space-y-1">
                {deadlines.map((d) => (
                  <li key={d.id}>
                    {d.label} -{" "}
                    <span className="text-sm text-gray-500">{d.date}</span>
                  </li>
                ))}
              </ul>
            )}
          </CardContent>
        </Card>
      </div>

      <Card>
        <CardHeader>
          <CardTitle>Recent Activities</CardTitle>
        </CardHeader>
        <CardContent>
          {recentActivities.length === 0 ? (
            <p className="text-muted-foreground text-sm">No recent activity</p>
          ) : (
            <ul className="space-y-2">
              {recentActivities.map((act) => (
                <li key={act.id} className="flex items-center justify-between">
                  <span>{act.text}</span>
                  <Button variant="outline" size="sm">
                    View
                  </Button>
                </li>
              ))}
            </ul>
          )}
        </CardContent>
      </Card>
    </div>
  );
}
```

### `src\app\dashboard\analytics\page.tsx`

```tsx
import { createClient } from "@/lib/supabase/server";
import { redirect } from "next/navigation";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";

export default async function AnalyticsPage() {
  const supabase = createClient();
  const {
    data: { session },
  } = await supabase.auth.getSession();

  if (!session) {
    redirect("/auth/login");
  }

  return (
    <div className="space-y-6">
      <div>
        <h3 className="text-2xl font-semibold tracking-tight">Analytics</h3>
        <p className="text-sm text-muted-foreground">
          Track your practice performance and insights.
        </p>
      </div>

      <Tabs defaultValue="overview" className="space-y-4">
        <TabsList>
          <TabsTrigger value="overview">Overview</TabsTrigger>
          <TabsTrigger value="clients">Client Analytics</TabsTrigger>
          <TabsTrigger value="returns">Return Analytics</TabsTrigger>
          <TabsTrigger value="revenue">Revenue</TabsTrigger>
        </TabsList>

        <TabsContent value="overview" className="space-y-4">
          <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-4">
            <Card>
              <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                <CardTitle className="text-sm font-medium">
                  Total Clients
                </CardTitle>
              </CardHeader>
              <CardContent>
                <div className="text-2xl font-bold">0</div>
                <p className="text-xs text-muted-foreground">
                  +0% from last month
                </p>
              </CardContent>
            </Card>
            <Card>
              <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                <CardTitle className="text-sm font-medium">
                  Active Returns
                </CardTitle>
              </CardHeader>
              <CardContent>
                <div className="text-2xl font-bold">0</div>
                <p className="text-xs text-muted-foreground">
                  0 completed this month
                </p>
              </CardContent>
            </Card>
            <Card>
              <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                <CardTitle className="text-sm font-medium">Revenue</CardTitle>
              </CardHeader>
              <CardContent>
                <div className="text-2xl font-bold">$0</div>
                <p className="text-xs text-muted-foreground">
                  +0% from last month
                </p>
              </CardContent>
            </Card>
            <Card>
              <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                <CardTitle className="text-sm font-medium">
                  Efficiency
                </CardTitle>
              </CardHeader>
              <CardContent>
                <div className="text-2xl font-bold">0%</div>
                <p className="text-xs text-muted-foreground">
                  Average processing time
                </p>
              </CardContent>
            </Card>
          </div>
        </TabsContent>

        <TabsContent value="clients" className="space-y-4">
          <Card>
            <CardHeader>
              <CardTitle>Client Growth</CardTitle>
              <CardDescription>
                Track client acquisition and retention metrics.
              </CardDescription>
            </CardHeader>
            <CardContent>
              {/* Client analytics charts will be implemented here */}
              <div className="text-sm text-muted-foreground">
                No client data available yet.
              </div>
            </CardContent>
          </Card>
        </TabsContent>

        <TabsContent value="returns" className="space-y-4">
          <Card>
            <CardHeader>
              <CardTitle>Return Processing</CardTitle>
              <CardDescription>
                Monitor tax return processing efficiency and status.
              </CardDescription>
            </CardHeader>
            <CardContent>
              {/* Return analytics charts will be implemented here */}
              <div className="text-sm text-muted-foreground">
                No return data available yet.
              </div>
            </CardContent>
          </Card>
        </TabsContent>

        <TabsContent value="revenue" className="space-y-4">
          <Card>
            <CardHeader>
              <CardTitle>Revenue Analytics</CardTitle>
              <CardDescription>
                Track revenue growth and financial metrics.
              </CardDescription>
            </CardHeader>
            <CardContent>
              {/* Revenue analytics charts will be implemented here */}
              <div className="text-sm text-muted-foreground">
                No revenue data available yet.
              </div>
            </CardContent>
          </Card>
        </TabsContent>
      </Tabs>
    </div>
  );
}
```

### `src\app\dashboard\clients\page.tsx`

```tsx
import { getSupabaseServerClient } from "@/lib/supabaseServerClient";
import ClientList from "@/components/client/ClientList";
import { Database } from "@/types/database.types";

async function getClients() {
  const supabase = getSupabaseServerClient();
  const { data: clients } = await supabase.from("clients").select("*");
  return clients || [];
}

export default async function ClientsPage() {
  const initialClients = await getClients();

  return (
    <main className="p-4">
      <h1 className="text-xl font-bold mb-4">Clients</h1>
      <ClientList initialClients={initialClients} />
    </main>
  );
}
```

### `src\app\dashboard\settings\page.tsx`

```tsx
import { createClient } from "@/lib/supabase/server";
import { redirect } from "next/navigation";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Separator } from "@/components/ui/separator";
import { Button } from "@/components/ui/button";
import { Switch } from "@/components/ui/switch";
import { Label } from "@/components/ui/label";

export default async function SettingsPage() {
  const supabase = createClient();
  const {
    data: { session },
  } = await supabase.auth.getSession();

  if (!session) {
    redirect("/auth/login");
  }

  return (
    <div className="space-y-6">
      <div>
        <h3 className="text-2xl font-semibold tracking-tight">Settings</h3>
        <p className="text-sm text-muted-foreground">
          Manage your account settings and preferences.
        </p>
      </div>
      <Separator />
      <div className="grid gap-6">
        <Card>
          <CardHeader>
            <CardTitle>Profile Settings</CardTitle>
            <CardDescription>
              Update your profile information and preferences.
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="space-y-1">
              <Label>Email Notifications</Label>
              <div className="flex items-center space-x-2">
                <Switch id="email-notifications" />
                <Label htmlFor="email-notifications">
                  Receive email notifications
                </Label>
              </div>
            </div>
            <Button>Save Changes</Button>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>Security Settings</CardTitle>
            <CardDescription>
              Manage your security preferences and authentication methods.
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="space-y-1">
              <Label>Two-Factor Authentication</Label>
              <div className="flex items-center space-x-2">
                <Switch id="2fa" />
                <Label htmlFor="2fa">Enable two-factor authentication</Label>
              </div>
            </div>
            <Button variant="secondary">Update Security Settings</Button>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>Notification Preferences</CardTitle>
            <CardDescription>
              Customize how you receive notifications and alerts.
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="space-y-1">
              <Label>Push Notifications</Label>
              <div className="flex items-center space-x-2">
                <Switch id="push-notifications" />
                <Label htmlFor="push-notifications">
                  Enable push notifications
                </Label>
              </div>
            </div>
            <Button variant="outline">Update Preferences</Button>
          </CardContent>
        </Card>
      </div>
    </div>
  );
}
```

### `src\app\dashboard\tax-returns\page.tsx`

```tsx
import { createClient } from "@/lib/supabase/server";
import { redirect } from "next/navigation";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Plus } from "lucide-react";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { TaxReturnList } from "@/components/tax/TaxReturnList";
import { DocumentUpload } from "@/components/tax/DocumentUpload";

export default async function TaxReturnsPage() {
  const supabase = createClient();
  const {
    data: { session },
  } = await supabase.auth.getSession();

  if (!session) {
    redirect("/auth/login");
  }

  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <div>
          <h3 className="text-2xl font-semibold tracking-tight">Tax Returns</h3>
          <p className="text-sm text-muted-foreground">
            Manage and process tax returns for your clients.
          </p>
        </div>
        <Button>
          <Plus className="mr-2 h-4 w-4" />
          New Tax Return
        </Button>
      </div>

      <Card>
        <CardHeader>
          <CardTitle>Document Upload</CardTitle>
          <CardDescription>Upload tax documents for processing</CardDescription>
        </CardHeader>
        <CardContent>
          <DocumentUpload taxReturnId="new" />
        </CardContent>
      </Card>

      <Tabs defaultValue="active" className="space-y-4">
        <TabsList>
          <TabsTrigger value="active">Active</TabsTrigger>
          <TabsTrigger value="completed">Completed</TabsTrigger>
          <TabsTrigger value="archived">Archived</TabsTrigger>
        </TabsList>
        <TabsContent value="active" className="space-y-4">
          <Card>
            <CardHeader>
              <CardTitle>Active Returns</CardTitle>
              <CardDescription>
                Tax returns currently being processed.
              </CardDescription>
            </CardHeader>
            <CardContent>
              <TaxReturnList clientId={session.user.id} />
            </CardContent>
          </Card>
        </TabsContent>
        <TabsContent value="completed" className="space-y-4">
          <Card>
            <CardHeader>
              <CardTitle>Completed Returns</CardTitle>
              <CardDescription>
                Successfully processed tax returns.
              </CardDescription>
            </CardHeader>
            <CardContent>
              <TaxReturnList clientId={session.user.id} />
            </CardContent>
          </Card>
        </TabsContent>
        <TabsContent value="archived" className="space-y-4">
          <Card>
            <CardHeader>
              <CardTitle>Archived Returns</CardTitle>
              <CardDescription>
                Historical tax returns from previous years.
              </CardDescription>
            </CardHeader>
            <CardContent>
              <TaxReturnList clientId={session.user.id} />
            </CardContent>
          </Card>
        </TabsContent>
      </Tabs>
    </div>
  );
}
```

### `src\app\documents\page.tsx`

```tsx
"use client";

import { useEffect, useState } from "react";
import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Database } from "@/types/database.types";
import { supabaseBrowserClient } from "@/lib/supabaseBrowserClient";
import {
  Dialog,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { useForm } from "react-hook-form";

type DocumentRow = Database["public"]["Tables"]["documents"]["Row"];

export default function DocumentsPage() {
  const [docs, setDocs] = useState<DocumentRow[]>([]);
  const [search, setSearch] = useState("");
  const [previewDoc, setPreviewDoc] = useState<DocumentRow | null>(null);

  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm<{ file: FileList }>();

  async function fetchDocuments() {
    const { data, error } = await supabaseBrowserClient
      .from("documents")
      .select("*");
    if (!error && data) {
      setDocs(data);
    }
  }

  useEffect(() => {
    fetchDocuments();
  }, []);

  async function onUpload(data: { file: FileList }) {
    if (!data.file?.[0]) return;
    const file = data.file[0];
    // Basic client-side validation
    if (file.size > 10_000_000) {
      alert("File too large (max 10MB).");
      return;
    }
    // TODO: storage upload logic, DB insert
    // ...
    await fetchDocuments();
  }

  const filteredDocs = docs.filter((d) =>
    d.file_name?.toLowerCase().includes(search.toLowerCase()),
  );

  return (
    <div className="p-6 space-y-4">
      <Card>
        <CardHeader>
          <CardTitle className="text-xl">Documents</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="flex gap-2 mb-4">
            <Input
              placeholder="Search documents..."
              value={search}
              onChange={(e) => setSearch(e.target.value)}
            />
            <Dialog>
              <DialogTrigger asChild>
                <Button variant="default">Upload</Button>
              </DialogTrigger>
              <DialogContent>
                <DialogHeader>
                  <DialogTitle>Upload Document</DialogTitle>
                </DialogHeader>
                <form
                  onSubmit={handleSubmit(onUpload)}
                  className="space-y-4 mt-2"
                >
                  <input
                    type="file"
                    {...register("file", { required: true })}
                  />
                  {errors.file && (
                    <p className="text-red-500 text-sm">File is required.</p>
                  )}
                  <Button type="submit">Upload</Button>
                </form>
              </DialogContent>
            </Dialog>
          </div>
          {filteredDocs.length === 0 ? (
            <div className="text-sm text-muted-foreground">
              No documents found.
            </div>
          ) : (
            <table className="w-full border-collapse">
              <thead>
                <tr className="border-b text-left">
                  <th className="py-2">File Name</th>
                  <th className="py-2">Status</th>
                  <th className="py-2">Actions</th>
                </tr>
              </thead>
              <tbody>
                {filteredDocs.map((doc) => (
                  <tr key={doc.id} className="border-b last:border-none">
                    <td className="py-2">{doc.file_name}</td>
                    <td className="py-2">{doc.document_status}</td>
                    <td className="py-2 space-x-2">
                      <Button
                        variant="outline"
                        size="sm"
                        onClick={() => setPreviewDoc(doc)}
                      >
                        Preview
                      </Button>
                      <Button variant="outline" size="sm">
                        Delete
                      </Button>
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          )}
        </CardContent>
      </Card>

      {/* Example preview dialog */}
      <Dialog open={!!previewDoc} onOpenChange={() => setPreviewDoc(null)}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>{previewDoc?.file_name}</DialogTitle>
          </DialogHeader>
          <div className="text-sm text-muted-foreground">
            {/* Actual preview logic goes here, e.g., PDF viewer */}
            This is a placeholder for document preview.
          </div>
        </DialogContent>
      </Dialog>
    </div>
  );
}
```

### `src\app\login\page.tsx`

```tsx
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import { getBrowserClient } from "@/lib/supabase/browser-client";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { useToast } from "@/components/ui/use-toast";
import { Loader2 } from "lucide-react";

export default function LoginPage() {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [loading, setLoading] = useState(false);
  const router = useRouter();
  const { toast } = useToast();
  const supabase = getBrowserClient();

  const handleLogin = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);

    try {
      const { data, error } = await supabase.auth.signInWithPassword({
        email,
        password,
      });

      if (error) throw error;

      if (data?.session) {
        // Refresh the session in the route handler
        await fetch("/api/auth", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ operation: "REFRESH" }),
        });

        router.push("/dashboard");
        toast({
          title: "Welcome back!",
          description: "Successfully logged in.",
        });
      }
    } catch (err) {
      console.error("Login error:", err);
      toast({
        title: "Error",
        description:
          err instanceof Error
            ? err.message
            : "Failed to login. Please check your credentials and try again.",
        variant: "destructive",
      });
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-background px-4">
      <Card className="w-full max-w-md">
        <CardHeader className="space-y-1">
          <CardTitle className="text-2xl font-bold">Welcome back</CardTitle>
          <CardDescription>Sign in to your account to continue</CardDescription>
        </CardHeader>
        <form onSubmit={handleLogin}>
          <CardContent className="space-y-4">
            <div className="space-y-2">
              <Label htmlFor="email">Email</Label>
              <Input
                id="email"
                type="email"
                placeholder="Enter your email"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                required
                disabled={loading}
                className="w-full"
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="password">Password</Label>
              <Input
                id="password"
                type="password"
                placeholder="Enter your password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                required
                disabled={loading}
                className="w-full"
              />
            </div>
          </CardContent>
          <CardFooter>
            <Button type="submit" className="w-full" disabled={loading}>
              {loading ? (
                <>
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  Signing in...
                </>
              ) : (
                "Sign in"
              )}
            </Button>
          </CardFooter>
        </form>
      </Card>
    </div>
  );
}
```

### `src\app\projects\loading.tsx`

```tsx
import { Skeleton } from "@/components/ui/skeleton";

export default function ProjectsLoading() {
  return (
    <div className="container py-6">
      <div className="flex items-center justify-between mb-8">
        <div>
          <Skeleton className="h-8 w-32" />
          <Skeleton className="h-4 w-48 mt-1" />
        </div>
        <Skeleton className="h-10 w-32" />
      </div>

      <Skeleton className="h-10 w-full" />

      <div className="grid gap-6 mt-6">
        {Array(3)
          .fill(null)
          .map((_, i) => (
            <div key={i} className="border rounded-lg p-4">
              <div className="flex justify-between items-start mb-4">
                <div className="space-y-2">
                  <Skeleton className="h-6 w-48" />
                  <Skeleton className="h-4 w-32" />
                </div>
                <Skeleton className="h-8 w-24" />
              </div>
              <div className="space-y-2">
                <Skeleton className="h-4 w-full" />
                <Skeleton className="h-4 w-3/4" />
              </div>
            </div>
          ))}
      </div>
    </div>
  );
}
```

### `src\app\projects\page.tsx`

```tsx
import { Metadata } from "next";
import ProjectList from "@/components/projects/project-list";
import { NewProjectButton } from "@/components/projects/new-project-button";

export const metadata: Metadata = {
  title: "Projects | American Dream Taxes Hub",
  description: "Tax and accounting project management",
};

export const dynamic = "force-dynamic";

export default async function ProjectsPage() {
  try {
    // Add any data fetching logic here with proper error handling
    return (
      <div className="container px-6 py-8">
        <div className="flex items-center justify-between mb-8">
          <div>
            <h1 className="text-3xl font-bold">Projects</h1>
            <p className="text-muted-foreground mt-1">
              Manage your active projects
            </p>
          </div>
          <NewProjectButton />
        </div>

        <ProjectList />
      </div>
    );
  } catch (error) {
    console.error("Error loading projects:", error);
    return (
      <div className="container px-6 py-8">
        <div className="flex items-center justify-between mb-8">
          <div>
            <h1 className="text-3xl font-bold">Projects</h1>
            <p className="text-muted-foreground mt-1">
              Error loading projects. Please try again later.
            </p>
          </div>
        </div>
      </div>
    );
  }
}
```

### `src\app\projects\[id]\loading.tsx`

```tsx
import { Skeleton } from "@/components/ui/skeleton";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";

export default function ProjectLoading() {
  return (
    <div className="container py-6">
      <div className="space-y-4">
        <div>
          <Skeleton className="h-8 w-[200px]" />
          <Skeleton className="h-4 w-[300px] mt-2" />
        </div>

        <div className="flex items-center gap-4 border-t border-b py-4">
          <div>
            <Skeleton className="h-4 w-[100px]" />
            <Skeleton className="h-6 w-[80px] mt-1" />
          </div>
          <div>
            <Skeleton className="h-4 w-[100px]" />
            <Skeleton className="h-6 w-[80px] mt-1" />
          </div>
          <div>
            <Skeleton className="h-4 w-[100px]" />
            <Skeleton className="h-6 w-[80px] mt-1" />
          </div>
        </div>

        <Tabs defaultValue="tasks" className="mt-6">
          <TabsList>
            <TabsTrigger value="tasks">Tasks</TabsTrigger>
            <TabsTrigger value="details">Details</TabsTrigger>
          </TabsList>

          <TabsContent value="tasks" className="mt-4">
            <div className="space-y-4">
              {[1, 2, 3].map((i) => (
                <div key={i} className="border rounded-lg p-4">
                  <Skeleton className="h-6 w-[200px]" />
                  <Skeleton className="h-4 w-[300px] mt-2" />
                </div>
              ))}
            </div>
          </TabsContent>

          <TabsContent value="details" className="mt-4">
            <div className="grid gap-6 md:grid-cols-2">
              <div className="border rounded-lg p-6">
                <Skeleton className="h-6 w-[150px] mb-4" />
                <div className="space-y-2">
                  <Skeleton className="h-4 w-full" />
                  <Skeleton className="h-4 w-[80%]" />
                  <Skeleton className="h-4 w-[60%]" />
                </div>
              </div>
              <div className="border rounded-lg p-6">
                <Skeleton className="h-6 w-[150px] mb-4" />
                <div className="space-y-2">
                  <Skeleton className="h-4 w-full" />
                  <Skeleton className="h-4 w-[80%]" />
                  <Skeleton className="h-4 w-[60%]" />
                </div>
              </div>
            </div>
          </TabsContent>
        </Tabs>
      </div>
    </div>
  );
}
```

### `src\app\projects\[id]\page.tsx`

```tsx
import { notFound } from "next/navigation";
import { getServerClient } from "@/lib/supabase/server-client";

export default async function ProjectPage({
  params,
}: {
  params: { id: string };
}) {
  const supabase = getServerClient();
  const { data: project, error } = await supabase
    .from("projects")
    .select("*")
    .eq("id", params.id)
    .single();

  if (error || !project) {
    notFound();
  }

  return (
    <div className="container mx-auto p-4">
      <h1 className="text-2xl font-bold mb-4">Project Details</h1>
      <div className="bg-white p-6 rounded-lg shadow">
        <h2 className="text-xl font-semibold mb-4">{project.name}</h2>
        <div className="space-y-2">
          <p>
            <span className="font-medium">Status:</span> {project.status}
          </p>
          <p>
            <span className="font-medium">Description:</span>{" "}
            {project.description || "N/A"}
          </p>
          <p>
            <span className="font-medium">Due Date:</span>{" "}
            {project.due_date || "N/A"}
          </p>
        </div>
      </div>
    </div>
  );
}
```

### `src\app\search\page.tsx`

```tsx
"use client";

import { useState } from "react";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card";
import { supabaseBrowserClient } from "@/lib/supabaseBrowserClient";
import { Database } from "@/types/database.types";

type Client = Database["public"]["Tables"]["clients"]["Row"];
type DocumentRow = Database["public"]["Tables"]["documents"]["Row"];
type TaxReturn = Database["public"]["Tables"]["tax_returns"]["Row"];

export default function SearchPage() {
  const [keyword, setKeyword] = useState("");
  const [searchResults, setSearchResults] = useState<
    { type: string; name: string; id: string }[]
  >([]);

  async function handleSearch() {
    // Searching clients by full_name
    const clientsPromise = supabaseBrowserClient
      .from("clients")
      .select("id, full_name")
      .ilike("full_name", `%${keyword}%`);

    // Searching documents by file_name
    const docsPromise = supabaseBrowserClient
      .from("documents")
      .select("id, file_name")
      .ilike("file_name", `%${keyword}%`);

    // Searching tax_returns by name
    const returnsPromise = supabaseBrowserClient
      .from("tax_returns")
      .select("id, name")
      .ilike("name", `%${keyword}%`);

    const [clientRes, docRes, returnRes] = await Promise.all([
      clientsPromise,
      docsPromise,
      returnsPromise,
    ]);

    const results: { type: string; name: string; id: string }[] = [];

    if (clientRes.data) {
      for (let c of clientRes.data) {
        results.push({ type: "Client", name: c.full_name, id: c.id });
      }
    }
    if (docRes.data) {
      for (let d of docRes.data) {
        results.push({
          type: "Document",
          name: d.file_name,
          id: d.id.toString(),
        });
      }
    }
    if (returnRes.data) {
      for (let r of returnRes.data) {
        results.push({ type: "Tax Return", name: r.name, id: r.id.toString() });
      }
    }
    setSearchResults(results);
  }

  return (
    <div className="p-6 space-y-4">
      <Card>
        <CardHeader>
          <CardTitle className="text-xl">Advanced Search</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="flex gap-2 mb-4">
            <Input
              placeholder="Enter keyword..."
              value={keyword}
              onChange={(e) => setKeyword(e.target.value)}
            />
            <Button onClick={handleSearch}>Search</Button>
          </div>
          {searchResults.length === 0 ? (
            <p className="text-sm text-muted-foreground">No results found.</p>
          ) : (
            <ul className="space-y-1">
              {searchResults.map((res, idx) => (
                <li key={idx} className="flex justify-between items-center">
                  <span>
                    <strong>{res.type}:</strong> {res.name}
                  </span>
                  <Button variant="outline" size="sm">
                    View
                  </Button>
                </li>
              ))}
            </ul>
          )}
        </CardContent>
      </Card>
    </div>
  );
}
```

### `src\app\tasks\page.tsx`

```tsx
import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card";

const columns = [
  { id: "backlog", title: "Backlog" },
  { id: "in-progress", title: "In Progress" },
  { id: "done", title: "Done" },
];

export default function TasksPage() {
  return (
    <div className="p-6 grid grid-cols-1 md:grid-cols-3 gap-6">
      {columns.map((col) => (
        <Card key={col.id} className="space-y-2">
          <CardHeader>
            <CardTitle>{col.title}</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="space-y-2">
              {/* Placeholder tasks */}
              <div className="p-3 border rounded hover:bg-muted transition-colors">
                <span className="font-medium">Task #1</span>
              </div>
              <div className="p-3 border rounded hover:bg-muted transition-colors">
                <span className="font-medium">Task #2</span>
              </div>
            </div>
          </CardContent>
        </Card>
      ))}
    </div>
  );
}
```

### `src\app\tax-returns\page.tsx`

```tsx
import { getSupabaseServerClient } from "@/lib/supabaseServerClient";
import TaxReturnList from "@/components/tax-return/TaxReturnList";
import { Database } from "@/types/database.types";

async function getTaxReturns() {
  const supabase = getSupabaseServerClient();
  const { data: returns } = await supabase.from("tax_returns").select("*");
  return returns || [];
}

export default async function TaxReturnsPage() {
  const initialReturns = await getTaxReturns();

  return (
    <main className="p-4">
      <h1 className="text-xl font-bold mb-4">Tax Returns</h1>
      <TaxReturnList initialReturns={initialReturns} />
    </main>
  );
}
```

### `src\app\taxreturns\page.tsx`

```tsx
"use client";

import { useEffect, useState } from "react";
import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Database } from "@/types/database.types";
import { supabaseBrowserClient } from "@/lib/supabaseBrowserClient";
import { CheckCircle, AlertCircle, Loader2 } from "lucide-react";

type BaseReturn = Database["public"]["Tables"]["tax_returns"]["Row"];
type TaxReturn = Omit<BaseReturn, "client_id"> & {
  client_id: string;
  clients: {
    full_name: string;
  };
};

export default function TaxReturnsPage() {
  const [returns, setReturns] = useState<TaxReturn[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  async function fetchReturns() {
    try {
      setIsLoading(true);
      const { data, error } = await supabaseBrowserClient
        .from("tax_returns")
        .select("*, clients(full_name)");

      if (error) throw error;

      if (data) {
        setReturns(data as unknown as TaxReturn[]);
      }
    } catch (err) {
      setError(
        err instanceof Error ? err.message : "Failed to fetch tax returns",
      );
    } finally {
      setIsLoading(false);
    }
  }

  useEffect(() => {
    fetchReturns();
  }, []);

  function renderStatusIcon(status?: string) {
    switch (status) {
      case "approved":
        return <CheckCircle className="text-green-500 w-4 h-4" />;
      case "rejected":
        return <AlertCircle className="text-red-500 w-4 h-4" />;
      default:
        return <span className="text-sm text-muted-foreground">{status}</span>;
    }
  }

  if (error) {
    return (
      <div className="p-6">
        <Card>
          <CardContent className="pt-6">
            <div className="text-destructive">Error: {error}</div>
          </CardContent>
        </Card>
      </div>
    );
  }

  return (
    <div className="p-6 space-y-4">
      <Card>
        <CardHeader className="flex flex-row items-center justify-between">
          <CardTitle className="text-xl">Tax Returns</CardTitle>
          <Button
            variant="outline"
            size="sm"
            onClick={() => fetchReturns()}
            disabled={isLoading}
          >
            {isLoading && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
            Refresh
          </Button>
        </CardHeader>
        <CardContent>
          {isLoading ? (
            <div className="flex justify-center items-center py-8">
              <Loader2 className="h-8 w-8 animate-spin text-muted-foreground" />
            </div>
          ) : returns.length === 0 ? (
            <div className="text-sm text-muted-foreground text-center py-8">
              No tax returns found.
            </div>
          ) : (
            <table className="w-full border-collapse">
              <thead>
                <tr className="border-b text-left">
                  <th className="py-2">Client</th>
                  <th className="py-2">Tax Year</th>
                  <th className="py-2">Status</th>
                  <th className="py-2">Due Date</th>
                  <th className="py-2">Actions</th>
                </tr>
              </thead>
              <tbody>
                {returns.map((r) => (
                  <tr key={r.id} className="border-b last:border-none">
                    <td className="py-2">{r.clients.full_name}</td>
                    <td className="py-2">{r.tax_year}</td>
                    <td className="py-2 flex items-center gap-2">
                      {renderStatusIcon(r.status)} {r.status}
                    </td>
                    <td className="py-2">
                      {new Date(r.due_date).toLocaleDateString()}
                    </td>
                    <td className="py-2">
                      <Button variant="outline" size="sm">
                        Open
                      </Button>
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          )}
        </CardContent>
      </Card>
    </div>
  );
}
```

### `src\app\templates\layout.tsx`

```tsx
import { redirect } from "next/navigation";
import { getServerClient } from "@/lib/supabase/server-client";

export default async function TemplatesLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const supabase = getServerClient();
  const {
    data: { session },
  } = await supabase.auth.getSession();

  if (!session) {
    redirect("/login");
  }

  return <>{children}</>;
}
```

### `src\app\templates\page.tsx`

```tsx
"use client";

import { ProjectTemplateList } from "@/components/templates/project-template-list";

export default function TemplatesPage() {
  return (
    <div className="container mx-auto py-6">
      <ProjectTemplateList />
    </div>
  );
}
```

### `src\app\templates\new\page.tsx`

```tsx
import TemplateForm from "@/components/templates/template-form";
import { getCategories } from "@/lib/api/templates";
import { redirect } from "next/navigation";

export default async function NewTemplatePage() {
  const categories = await getCategories();

  if (!categories) {
    redirect("/templates");
  }

  return (
    <div className="container mx-auto px-4 py-8">
      <h1 className="text-2xl font-bold mb-6">Create New Template</h1>
      <TemplateForm
        mode="create"
        categories={categories}
        onSuccess={() => redirect("/templates")}
      />
    </div>
  );
}
```

### `src\app\unauthorized\page.tsx`

```tsx
"use client";

import { useAuth } from "@/components/providers/auth-provider";
import { Button } from "@/components/ui/button";
import { useRouter } from "next/navigation";

export default function UnauthorizedPage() {
  const { signOut } = useAuth();
  const router = useRouter();

  const handleSignOut = async () => {
    try {
      await signOut();
    } catch (error) {
      console.error("Error signing out:", error);
    }
  };

  const handleBack = () => {
    router.back();
  };

  return (
    <div className="flex items-center justify-center min-h-screen bg-background">
      <div className="max-w-md w-full mx-auto p-8">
        <div className="text-center space-y-6">
          <h1 className="text-4xl font-bold text-foreground">Access Denied</h1>
          <p className="text-lg text-muted-foreground">
            You do not have permission to access this page. Please contact your
            administrator if you believe this is an error.
          </p>
          <div className="flex flex-col space-y-4">
            <Button onClick={handleBack} variant="outline">
              Go Back
            </Button>
            <Button onClick={handleSignOut} variant="destructive">
              Sign Out
            </Button>
          </div>
        </div>
      </div>
    </div>
  );
}
```

### `src\app\workspace\loading.tsx`

```tsx
import { Skeleton } from "@/components/ui/skeleton";

export default function WorkspaceLoading() {
  return (
    <div className="container py-6">
      <div className="flex items-center justify-between mb-8">
        <div>
          <Skeleton className="h-8 w-32" />
          <Skeleton className="h-4 w-48 mt-1" />
        </div>
        <Skeleton className="h-10 w-32" />
      </div>

      <Skeleton className="h-10 w-full" />

      <div className="grid gap-6 mt-6">
        {Array(3)
          .fill(null)
          .map((_, i) => (
            <div key={i} className="border rounded-lg p-4">
              <div className="flex justify-between items-start mb-4">
                <div className="space-y-2">
                  <Skeleton className="h-6 w-48" />
                  <Skeleton className="h-4 w-32" />
                </div>
                <Skeleton className="h-8 w-24" />
              </div>
              <div className="space-y-2">
                <Skeleton className="h-4 w-full" />
                <Skeleton className="h-4 w-3/4" />
              </div>
            </div>
          ))}
      </div>
    </div>
  );
}
```

### `src\components\error-boundary.tsx`

```tsx
"use client";

import { useEffect } from "react";
import { toast } from "sonner";

export default function ErrorBoundary({
  error,
  reset,
}: {
  error: Error & { digest?: string };
  reset: () => void;
}) {
  useEffect(() => {
    console.error(error);
    toast.error("Something went wrong!");
  }, [error]);

  return (
    <div className="flex min-h-screen items-center justify-center">
      <div className="text-center">
        <h2 className="text-xl font-bold mb-4">Something went wrong!</h2>
        <button
          onClick={reset}
          className="px-4 py-2 bg-primary text-white rounded hover:bg-primary/90"
        >
          Try again
        </button>
      </div>
    </div>
  );
}

// Named export for direct imports
export { ErrorBoundary };
```

### `src\components\ErrorBoundary.tsx`

```tsx
"use client";

import React, { Component, ErrorInfo } from "react";
import { captureError } from "@/lib/error-reporting";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Button } from "@/components/ui/button";
import { AlertTriangle } from "lucide-react";

interface ErrorBoundaryProps {
  children: React.ReactNode;
}

interface ErrorBoundaryState {
  hasError: boolean;
  error: Error | null;
}

export class ErrorBoundary extends Component<
  ErrorBoundaryProps,
  ErrorBoundaryState
> {
  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = {
      hasError: false,
      error: null,
    };
  }

  static getDerivedStateFromError(error: Error) {
    return {
      hasError: true,
      error,
    };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    captureError(error, errorInfo);
  }

  resetError = () => {
    this.setState({
      hasError: false,
      error: null,
    });
  };

  render() {
    if (this.state.hasError) {
      return (
        <Alert variant="destructive" className="m-4">
          <AlertTriangle className="h-4 w-4" />
          <AlertTitle>Something went wrong</AlertTitle>
          <AlertDescription className="mt-2">
            <p>{this.state.error?.message || "An unexpected error occurred"}</p>
            <Button
              onClick={this.resetError}
              variant="outline"
              size="sm"
              className="mt-4"
            >
              Try Again
            </Button>
          </AlertDescription>
        </Alert>
      );
    }

    return this.props.children;
  }
}
```

### `src\components\header.tsx`

```tsx
"use client";

import { useAuth } from "@/hooks/use-auth";
import Link from "next/link";

export function Header() {
  const { user, signOut, loading } = useAuth();

  return (
    <header className="border-b">
      <div className="container mx-auto px-4 py-4 flex justify-between items-center">
        <Link href="/" className="text-xl font-bold">
          American Dream Taxes
        </Link>

        <nav className="flex items-center gap-4">
          {!loading && user ? (
            <>
              <Link href="/dashboard">Dashboard</Link>
              <button
                onClick={signOut}
                className="px-4 py-2 bg-primary text-white rounded"
              >
                Sign Out
              </button>
            </>
          ) : (
            <Link
              href="/auth/login"
              className="px-4 py-2 bg-primary text-white rounded"
            >
              Sign In
            </Link>
          )}
        </nav>
      </div>
    </header>
  );
}
```

### `src\components\mode-toggle.tsx`

```tsx
"use client";

import * as React from "react";
import { Moon, Sun } from "lucide-react";
import { useTheme } from "next-themes";
import { Button } from "@/components/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";

export function ModeToggle() {
  const [mounted, setMounted] = React.useState(false);
  const { resolvedTheme, setTheme } = useTheme();

  // useEffect only runs on the client, so now we can safely show the UI
  React.useEffect(() => {
    setMounted(true);
  }, []);

  if (!mounted) {
    return <Button variant="ghost" size="icon" disabled />;
  }

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="ghost" size="icon" className="w-9 px-0">
          <Sun
            className="h-[1.2rem] w-[1.2rem] rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0"
            aria-hidden="true"
          />
          <Moon
            className="absolute h-[1.2rem] w-[1.2rem] rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100"
            aria-hidden="true"
          />
          <span className="sr-only">Toggle theme</span>
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end">
        <DropdownMenuItem onClick={() => setTheme("light")}>
          <Sun className="mr-2 h-4 w-4" />
          <span>Light</span>
        </DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme("dark")}>
          <Moon className="mr-2 h-4 w-4" />
          <span>Dark</span>
        </DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme("system")}>
          <span className="mr-2">üíª</span>
          <span>System</span>
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}
```

### `src\components\navbar.tsx`

```tsx
"use client";

import Link from "next/link";
import { usePathname } from "next/navigation";
import { cn } from "@/lib/utils";
import { Button } from "@/components/ui/button";
import {
  LayoutDashboard,
  Users,
  ClipboardList,
  FileText,
  Settings,
} from "lucide-react";

const mainNavItems = [
  {
    title: "Dashboard",
    href: "/dashboard",
    icon: LayoutDashboard,
  },
  {
    title: "Clients",
    href: "/clients",
    icon: Users,
  },
  {
    title: "Tasks",
    href: "/tasks",
    icon: ClipboardList,
  },
  {
    title: "Templates",
    href: "/templates",
    icon: FileText,
  },
];

const bottomNavItems = [
  {
    title: "Settings",
    href: "/settings",
    icon: Settings,
  },
];

export function Navbar() {
  const pathname = usePathname();

  return (
    <div className="flex h-full w-full flex-col">
      <div className="flex flex-col space-y-2 p-4">
        {mainNavItems.map((item) => {
          const Icon = item.icon;
          return (
            <Link key={item.href} href={item.href}>
              <Button
                variant="ghost"
                size="lg"
                className={cn(
                  "w-full justify-start gap-2",
                  pathname === item.href
                    ? "bg-secondary"
                    : "hover:bg-secondary/50",
                )}
              >
                <Icon className="h-5 w-5" />
                {item.title}
              </Button>
            </Link>
          );
        })}
      </div>
      <div className="mt-auto">
        <div className="flex flex-col space-y-2 p-4">
          {bottomNavItems.map((item) => {
            const Icon = item.icon;
            return (
              <Link key={item.href} href={item.href}>
                <Button
                  variant="ghost"
                  size="lg"
                  className={cn(
                    "w-full justify-start gap-2",
                    pathname === item.href
                      ? "bg-secondary"
                      : "hover:bg-secondary/50",
                  )}
                >
                  <Icon className="h-5 w-5" />
                  {item.title}
                </Button>
              </Link>
            );
          })}
        </div>
      </div>
    </div>
  );
}
```

### `src\components\role-guard.tsx`

```tsx
"use client";

import { useAuth } from "@/hooks/use-auth";
import { ReactNode } from "react";

interface RoleGuardProps {
  children: ReactNode;
  allowedRoles: string[];
  fallback?: ReactNode;
}

export function RoleGuard({
  children,
  allowedRoles,
  fallback = null,
}: RoleGuardProps) {
  const { user, loading } = useAuth();

  // Show nothing while checking authentication
  if (loading) {
    return null;
  }

  // Show fallback if user is not authenticated
  if (!user) {
    return fallback;
  }

  // Check if user has required role
  const userRole = user.app_metadata?.role as string;
  if (!userRole || !allowedRoles.includes(userRole)) {
    return fallback;
  }

  // User has required role, show protected content
  return <>{children}</>;
}
```

### `src\components\shell.tsx`

```tsx
interface DashboardShellProps extends React.HTMLAttributes<HTMLDivElement> {}

export function DashboardShell({
  children,
  className,
  ...props
}: DashboardShellProps) {
  return (
    <div className="flex-1 space-y-4 p-8 pt-6" {...props}>
      {children}
    </div>
  );
}
```

### `src\components\theme-provider.tsx`

```tsx
"use client";

import { createContext, useContext, useEffect, useState } from "react";

type Theme = "light" | "dark" | "high-contrast";

interface ThemeProviderProps {
  children: React.ReactNode;
}

interface ThemeContextValue {
  theme: Theme;
  setTheme: (theme: Theme) => void;
}

const ThemeContext = createContext<ThemeContextValue | undefined>(undefined);

export function ThemeProvider({ children }: ThemeProviderProps) {
  const [theme, setTheme] = useState<Theme>("light");

  useEffect(() => {
    // Check for system high contrast mode
    const mediaQuery = window.matchMedia("(forced-colors: active)");
    const prefersHighContrast = mediaQuery.matches;

    // Check for saved theme preference
    const savedTheme = localStorage.getItem("theme") as Theme;
    const systemTheme = window.matchMedia("(prefers-color-scheme: dark)")
      .matches
      ? "dark"
      : "light";

    // Set initial theme
    if (prefersHighContrast) {
      setTheme("high-contrast");
    } else if (savedTheme) {
      setTheme(savedTheme);
    } else {
      setTheme(systemTheme);
    }

    // Listen for system high contrast mode changes
    const handleHighContrastChange = (e: MediaQueryListEvent) => {
      if (e.matches) {
        setTheme("high-contrast");
      } else {
        setTheme((localStorage.getItem("theme") as Theme) || systemTheme);
      }
    };

    mediaQuery.addEventListener("change", handleHighContrastChange);

    return () => {
      mediaQuery.removeEventListener("change", handleHighContrastChange);
    };
  }, []);

  const handleThemeChange = (newTheme: Theme) => {
    setTheme(newTheme);
    localStorage.setItem("theme", newTheme);
    document.documentElement.setAttribute("data-theme", newTheme);

    // Update meta theme-color
    const metaThemeColor = document.querySelector('meta[name="theme-color"]');
    if (metaThemeColor) {
      metaThemeColor.setAttribute(
        "content",
        newTheme === "dark"
          ? "#000000"
          : newTheme === "high-contrast"
            ? "#000000"
            : "#ffffff",
      );
    }
  };

  useEffect(() => {
    handleThemeChange(theme);
  }, [theme]);

  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}

export function useTheme() {
  const context = useContext(ThemeContext);
  if (context === undefined) {
    throw new Error("useTheme must be used within a ThemeProvider");
  }
  return context;
}

export function ThemeToggle() {
  const { theme, setTheme } = useTheme();

  const handleThemeToggle = () => {
    const nextTheme =
      theme === "light" ? "dark" : theme === "dark" ? "high-contrast" : "light";
    setTheme(nextTheme);
  };

  return (
    <button
      onClick={handleThemeToggle}
      className="p-2 rounded-md hover:bg-accent"
      aria-label={`Current theme: ${theme}. Click to switch theme.`}
    >
      {theme === "light" && (
        <span className="sr-only">Switch to dark mode</span>
      )}
      {theme === "dark" && (
        <span className="sr-only">Switch to high contrast mode</span>
      )}
      {theme === "high-contrast" && (
        <span className="sr-only">Switch to light mode</span>
      )}
      <svg
        xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        className="w-5 h-5"
        aria-hidden="true"
      >
        {theme === "light" && (
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth={2}
            d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"
          />
        )}
        {theme === "dark" && (
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth={2}
            d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707"
          />
        )}
        {theme === "high-contrast" && (
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth={2}
            d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"
          />
        )}
      </svg>
    </button>
  );
}
```

### `src\components\theme-toggle.tsx`

```tsx
"use client";

import * as React from "react";
import { Moon, Sun } from "lucide-react";
import { useTheme } from "next-themes";

import { Button } from "@/components/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";

export function ThemeToggle({ isCollapsed }: { isCollapsed: boolean }) {
  const { setTheme } = useTheme();

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="ghost" size="icon">
          <Sun className="h-[1.2rem] w-[1.2rem] rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0" />
          <Moon className="absolute h-[1.2rem] w-[1.2rem] rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100" />
          <span className="sr-only">Toggle theme</span>
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align={isCollapsed ? "start" : "end"}>
        <DropdownMenuItem onClick={() => setTheme("light")}>
          Light
        </DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme("dark")}>
          Dark
        </DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme("system")}>
          System
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}
```

### `src\components\ai\ProcessingStatus.tsx`

```tsx
"use client";

import { Progress } from "@/components/ui/progress";
import { useProcessingStatus } from "@/hooks/useProcessingStatus";

function StatusMessage({ status }: { status: string }) {
  switch (status) {
    case "idle":
      return <p>Ready to process</p>;
    case "processing":
      return <p>Processing document...</p>;
    case "completed":
      return <p>Processing complete</p>;
    case "error":
      return <p>Error processing document</p>;
    default:
      return null;
  }
}

export function ProcessingStatus({ documentId }: { documentId: string }) {
  const { status, progress } = useProcessingStatus(documentId);

  return (
    <div>
      <Progress value={progress} />
      <StatusMessage status={status} />
    </div>
  );
}
```

### `src\components\auth\auth-button.tsx`

```tsx
"use client";

import { useRouter } from "next/navigation";
import { useCallback, useState } from "react";
import { useToast } from "@/components/ui/use-toast";
import { Button } from "@/components/ui/button";

interface AuthButtonProps {
  type: "sign-in" | "sign-up";
}

export function AuthButton({ type }: AuthButtonProps) {
  const [loading, setLoading] = useState(false);
  const router = useRouter();
  const { toast } = useToast();

  const handleAuth = useCallback(async () => {
    try {
      setLoading(true);
      router.push(`/auth/${type === "sign-in" ? "login" : "signup"}`);
    } catch (error) {
      console.error("Auth error:", error);
      toast({
        title: "Error",
        description:
          error instanceof Error ? error.message : "An error occurred",
        variant: "destructive",
      });
    } finally {
      setLoading(false);
    }
  }, [type, router, toast]);

  const buttonText = type === "sign-in" ? "Sign In" : "Sign Up";
  const buttonVariant = type === "sign-in" ? "default" : "outline";

  return (
    <Button onClick={handleAuth} disabled={loading} variant={buttonVariant}>
      {loading ? "Loading..." : buttonText}
    </Button>
  );
}
```

### `src\components\auth\auth-error-boundary.tsx`

```tsx
"use client";

import { Component, type ReactNode } from "react";
import { useRouter } from "next/navigation";

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
}

interface State {
  hasError: boolean;
  error: Error | null;
}

export class AuthErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error) {
    // Log error to monitoring service
    console.error("Auth Error:", error);
  }

  private handleRetry = () => {
    this.setState({ hasError: false, error: null });
  };

  render() {
    if (this.state.hasError) {
      if (this.props.fallback) {
        return this.props.fallback;
      }

      return (
        <div className="min-h-screen flex items-center justify-center">
          <div className="bg-white p-8 rounded-lg shadow-md max-w-md w-full">
            <h2 className="text-2xl font-semibold text-gray-800 mb-4">
              Authentication Error
            </h2>
            <p className="text-gray-600 mb-6">
              {this.state.error?.message || "An authentication error occurred."}
            </p>
            <div className="flex gap-4">
              <button
                onClick={this.handleRetry}
                className="px-4 py-2 bg-primary text-white rounded hover:bg-primary/90 transition-colors"
              >
                Retry
              </button>
              <a
                href="/auth/login"
                className="px-4 py-2 border border-gray-300 rounded hover:bg-gray-50 transition-colors"
              >
                Back to Login
              </a>
            </div>
          </div>
        </div>
      );
    }

    return this.props.children;
  }
}
```

### `src\components\auth\auth-form.tsx`

```tsx
"use client";

import { useTransition } from "react";
import { signOut, refreshSession } from "@/app/actions/auth";
import { useToast } from "@/components/ui/use-toast";

export function AuthForm() {
  const [isPending, startTransition] = useTransition();
  const { toast } = useToast();

  const handleSignOut = async () => {
    startTransition(async () => {
      try {
        await signOut();
        toast({
          title: "Signed out successfully",
          description: "You have been signed out of your account.",
        });
      } catch (error) {
        toast({
          title: "Error",
          description:
            error instanceof Error ? error.message : "Failed to sign out",
          variant: "destructive",
        });
      }
    });
  };

  const handleRefresh = async () => {
    startTransition(async () => {
      try {
        await refreshSession();
        toast({
          title: "Session refreshed",
          description: "Your session has been refreshed successfully.",
        });
      } catch (error) {
        toast({
          title: "Error",
          description:
            error instanceof Error
              ? error.message
              : "Failed to refresh session",
          variant: "destructive",
        });
      }
    });
  };

  return (
    <form className="space-y-4">
      <button
        type="button"
        onClick={handleSignOut}
        disabled={isPending}
        className="px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600 transition-colors disabled:opacity-50"
      >
        {isPending ? "Loading..." : "Sign Out"}
      </button>
      <button
        type="button"
        onClick={handleRefresh}
        disabled={isPending}
        className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors disabled:opacity-50"
      >
        {isPending ? "Loading..." : "Refresh Session"}
      </button>
    </form>
  );
}
```

### `src\components\auth\auth-loading.tsx`

```tsx
"use client";

interface AuthLoadingProps {
  message?: string;
}

export function AuthLoading({ message = "Loading..." }: AuthLoadingProps) {
  return (
    <div className="min-h-screen flex flex-col items-center justify-center">
      <div className="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-primary mb-4"></div>
      <p className="text-gray-600">{message}</p>
    </div>
  );
}

export function AuthLoadingInline({
  message = "Loading...",
}: AuthLoadingProps) {
  return (
    <div className="flex items-center justify-center p-4">
      <div className="animate-spin rounded-full h-6 w-6 border-t-2 border-b-2 border-primary mr-3"></div>
      <p className="text-gray-600 text-sm">{message}</p>
    </div>
  );
}
```

### `src\components\auth\login-form.tsx`

```tsx
"use client";

import { createBrowserClient } from "@supabase/ssr";
import { useRouter } from "next/navigation";
import { useState } from "react";
import { toast } from "@/components/ui/use-toast";

export function LoginForm() {
  const [loading, setLoading] = useState(false);
  const router = useRouter();

  const supabase = createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
  );

  async function handleSubmit(e: React.FormEvent<HTMLFormElement>) {
    e.preventDefault();
    setLoading(true);

    try {
      const formData = new FormData(e.currentTarget);
      const { error } = await supabase.auth.signInWithPassword({
        email: formData.get("email") as string,
        password: formData.get("password") as string,
      });

      if (error) throw error;

      router.refresh();
      router.push("/dashboard");
    } catch (error) {
      toast({
        title: "Error",
        description: error.message,
        variant: "destructive",
      });
    } finally {
      setLoading(false);
    }
  }

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <div className="space-y-2">
        <label htmlFor="email">Email</label>
        <input
          id="email"
          name="email"
          type="email"
          required
          className="w-full p-2 border rounded"
        />
      </div>
      <div className="space-y-2">
        <label htmlFor="password">Password</label>
        <input
          id="password"
          name="password"
          type="password"
          required
          className="w-full p-2 border rounded"
        />
      </div>
      <button
        type="submit"
        disabled={loading}
        className="w-full py-2 px-4 bg-primary text-white rounded"
      >
        {loading ? "Loading..." : "Sign In"}
      </button>
    </form>
  );
}
```

### `src\components\auth\role-guard.tsx`

```tsx
"use client";

import { useAuth } from "@/providers/unified-auth-provider";
import { useRouter } from "next/navigation";
import { useEffect } from "react";

interface RoleGuardProps {
  children: React.ReactNode;
  requiredRole: string;
  fallbackPath?: string;
}

export function RoleGuard({
  children,
  requiredRole,
  fallbackPath = "/dashboard",
}: RoleGuardProps) {
  const { hasRole, loading } = useAuth();
  const router = useRouter();

  useEffect(() => {
    if (!loading && !hasRole(requiredRole)) {
      router.push(fallbackPath);
    }
  }, [loading, hasRole, requiredRole, fallbackPath, router]);

  if (loading) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-primary"></div>
      </div>
    );
  }

  if (!hasRole(requiredRole)) {
    return null;
  }

  return <>{children}</>;
}
```

### `src\components\auth\signup-form.tsx`

```tsx
"use client";

import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { useRouter } from "next/navigation";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { useToast } from "@/components/ui/use-toast";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import type { Database } from "@/types/database.types";

const schema = z.object({
  fullName: z.string().min(2, "Full name must be at least 2 characters"),
  email: z.string().email(),
  password: z.string().min(8, "Password must be at least 8 characters"),
  role: z.enum(["admin", "team_member"]),
});

export function SignUpForm() {
  const router = useRouter();
  const { toast } = useToast();
  const supabase = createClientComponentClient<Database>({
    options: {
      auth: {
        persistSession: true,
        autoRefreshToken: true,
        detectSessionInUrl: true,
        flowType: "pkce",
      },
    },
  });

  const form = useForm({
    resolver: zodResolver(schema),
    defaultValues: {
      fullName: "",
      email: "",
      password: "",
      role: "team_member",
    },
  });

  const onSubmit = async (data) => {
    try {
      const { error: signUpError } = await supabase.auth.signUp({
        email: data.email,
        password: data.password,
        options: {
          data: {
            full_name: data.fullName,
            role: data.role,
          },
        },
      });
      if (signUpError) throw signUpError;

      // Create profile record
      const { error: profileError } = await supabase.from("profiles").insert({
        id: (await supabase.auth.getUser()).data.user?.id,
        full_name: data.fullName,
        email: data.email,
        role: data.role,
      });
      if (profileError) throw profileError;

      toast({
        description:
          "Account created successfully! Please check your email to verify your account.",
      });
      router.push("/auth/login");
    } catch (error: any) {
      toast({ description: error.message });
    }
  };

  return (
    <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
      <Input
        placeholder="Full Name"
        {...form.register("fullName")}
        disabled={form.formState.isSubmitting}
      />
      {form.formState.errors.fullName?.message && (
        <p className="text-sm text-red-500">
          {form.formState.errors.fullName.message}
        </p>
      )}

      <Input
        type="email"
        placeholder="Email"
        {...form.register("email")}
        disabled={form.formState.isSubmitting}
      />
      {form.formState.errors.email?.message && (
        <p className="text-sm text-red-500">
          {form.formState.errors.email.message}
        </p>
      )}

      <Input
        type="password"
        placeholder="Password"
        {...form.register("password")}
        disabled={form.formState.isSubmitting}
      />
      {form.formState.errors.password?.message && (
        <p className="text-sm text-red-500">
          {form.formState.errors.password.message}
        </p>
      )}

      <Select
        onValueChange={(value) =>
          form.setValue("role", value as "admin" | "team_member")
        }
        defaultValue={form.getValues("role")}
        disabled={form.formState.isSubmitting}
      >
        <SelectTrigger>
          <SelectValue placeholder="Select role" />
        </SelectTrigger>
        <SelectContent>
          <SelectItem value="admin">Admin</SelectItem>
          <SelectItem value="team_member">Team Member</SelectItem>
        </SelectContent>
      </Select>
      {form.formState.errors.role?.message && (
        <p className="text-sm text-red-500">
          {form.formState.errors.role.message}
        </p>
      )}

      <Button
        type="submit"
        className="w-full"
        disabled={form.formState.isSubmitting}
      >
        {form.formState.isSubmitting ? "Creating account..." : "Create Account"}
      </Button>
    </form>
  );
}
```

### `src\components\auth\user-button.tsx`

```tsx
"use client";

import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Button } from "@/components/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { User } from "lucide-react";

export function UserButton() {
  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="ghost" className="relative h-8 w-8 rounded-full">
          <Avatar className="h-8 w-8">
            <AvatarImage src="" alt="User" />
            <AvatarFallback>
              <User className="h-4 w-4" />
            </AvatarFallback>
          </Avatar>
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent className="w-56" align="end" forceMount>
        <DropdownMenuLabel className="font-normal">
          <div className="flex flex-col space-y-1">
            <p className="text-sm font-medium leading-none">User</p>
            <p className="text-xs leading-none text-muted-foreground">
              user@example.com
            </p>
          </div>
        </DropdownMenuLabel>
        <DropdownMenuSeparator />
        <DropdownMenuGroup>
          <DropdownMenuItem>
            Profile
            <DropdownMenuShortcut>‚áß‚åòP</DropdownMenuShortcut>
          </DropdownMenuItem>
          <DropdownMenuItem>
            Settings
            <DropdownMenuShortcut>‚åòS</DropdownMenuShortcut>
          </DropdownMenuItem>
        </DropdownMenuGroup>
        <DropdownMenuSeparator />
        <DropdownMenuItem>
          Log out
          <DropdownMenuShortcut>‚áß‚åòQ</DropdownMenuShortcut>
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}
```

### `src\components\auth\__tests__\auth-error-boundary.test.tsx`

```tsx
import { render, screen, fireEvent } from "@testing-library/react";
import { AuthErrorBoundary } from "../auth-error-boundary";

const ErrorComponent = () => {
  throw new Error("Test error");
};

describe("AuthErrorBoundary", () => {
  beforeEach(() => {
    // Prevent console.error from cluttering test output
    jest.spyOn(console, "error").mockImplementation(() => {});
  });

  afterEach(() => {
    jest.restoreAllMocks();
  });

  it("renders children when there is no error", () => {
    render(
      <AuthErrorBoundary>
        <div>Test Content</div>
      </AuthErrorBoundary>,
    );

    expect(screen.getByText("Test Content")).toBeInTheDocument();
  });

  it("renders error UI when there is an error", () => {
    render(
      <AuthErrorBoundary>
        <ErrorComponent />
      </AuthErrorBoundary>,
    );

    expect(screen.getByText("Authentication Error")).toBeInTheDocument();
    expect(screen.getByText("Test error")).toBeInTheDocument();
  });

  it("renders custom fallback when provided", () => {
    const fallback = <div>Custom Error UI</div>;

    render(
      <AuthErrorBoundary fallback={fallback}>
        <ErrorComponent />
      </AuthErrorBoundary>,
    );

    expect(screen.getByText("Custom Error UI")).toBeInTheDocument();
  });

  it("has retry button that resets error boundary", () => {
    const { rerender } = render(
      <AuthErrorBoundary>
        <ErrorComponent />
      </AuthErrorBoundary>,
    );

    const retryButton = screen.getByText("Retry");
    fireEvent.click(retryButton);

    // After clicking retry, the error boundary should reset
    rerender(
      <AuthErrorBoundary>
        <div>Recovered Content</div>
      </AuthErrorBoundary>,
    );

    expect(screen.getByText("Recovered Content")).toBeInTheDocument();
  });

  it("has working login link", () => {
    render(
      <AuthErrorBoundary>
        <ErrorComponent />
      </AuthErrorBoundary>,
    );

    const loginLink = screen.getByText("Back to Login");
    expect(loginLink).toHaveAttribute("href", "/auth/login");
  });
});
```

### `src\components\auth\__tests__\auth-loading.test.tsx`

```tsx
import { render, screen } from "@testing-library/react";
import { AuthLoading, AuthLoadingInline } from "../auth-loading";

describe("AuthLoading", () => {
  it("renders with default message", () => {
    render(<AuthLoading />);
    expect(screen.getByText("Loading...")).toBeInTheDocument();
    expect(document.querySelector(".animate-spin")).toBeInTheDocument();
  });

  it("renders with custom message", () => {
    const message = "Custom loading message";
    render(<AuthLoading message={message} />);
    expect(screen.getByText(message)).toBeInTheDocument();
  });

  it("has full screen height", () => {
    render(<AuthLoading />);
    expect(document.querySelector(".min-h-screen")).toBeInTheDocument();
  });
});

describe("AuthLoadingInline", () => {
  it("renders with default message", () => {
    render(<AuthLoadingInline />);
    expect(screen.getByText("Loading...")).toBeInTheDocument();
    expect(document.querySelector(".animate-spin")).toBeInTheDocument();
  });

  it("renders with custom message", () => {
    const message = "Custom loading message";
    render(<AuthLoadingInline message={message} />);
    expect(screen.getByText(message)).toBeInTheDocument();
  });

  it("has smaller spinner than full AuthLoading", () => {
    const { rerender } = render(<AuthLoading />);
    const fullSpinner = document.querySelector(".animate-spin");

    rerender(<AuthLoadingInline />);
    const inlineSpinner = document.querySelector(".animate-spin");

    expect(fullSpinner?.classList.contains("h-12")).toBeTruthy();
    expect(inlineSpinner?.classList.contains("h-6")).toBeTruthy();
  });

  it("has inline layout", () => {
    render(<AuthLoadingInline />);
    const container = document.querySelector(".flex");
    expect(container?.classList.contains("min-h-screen")).toBeFalsy();
  });
});
```

### `src\components\auth\__tests__\role-guard.test.tsx`

```tsx
import { render, screen, waitFor } from "@testing-library/react";
import { RoleGuard } from "../role-guard";
import { useAuth } from "@/providers/unified-auth-provider";
import { useRouter } from "next/navigation";

// Mock the hooks
jest.mock("@/providers/unified-auth-provider");
jest.mock("next/navigation");

describe("RoleGuard", () => {
  const mockRouter = {
    push: jest.fn(),
  };

  beforeEach(() => {
    (useRouter as jest.Mock).mockReturnValue(mockRouter);
    mockRouter.push.mockClear();
  });

  it("renders children when user has required role", () => {
    (useAuth as jest.Mock).mockReturnValue({
      hasRole: (role: string) => role === "admin",
      loading: false,
    });

    render(
      <RoleGuard requiredRole="admin">
        <div>Protected Content</div>
      </RoleGuard>,
    );

    expect(screen.getByText("Protected Content")).toBeInTheDocument();
  });

  it("shows loading state when loading", () => {
    (useAuth as jest.Mock).mockReturnValue({
      hasRole: () => false,
      loading: true,
    });

    render(
      <RoleGuard requiredRole="admin">
        <div>Protected Content</div>
      </RoleGuard>,
    );

    expect(screen.queryByText("Protected Content")).not.toBeInTheDocument();
    expect(document.querySelector(".animate-spin")).toBeInTheDocument();
  });

  it("redirects when user does not have required role", async () => {
    (useAuth as jest.Mock).mockReturnValue({
      hasRole: () => false,
      loading: false,
    });

    render(
      <RoleGuard requiredRole="admin" fallbackPath="/dashboard">
        <div>Protected Content</div>
      </RoleGuard>,
    );

    await waitFor(() => {
      expect(mockRouter.push).toHaveBeenCalledWith("/dashboard");
    });
    expect(screen.queryByText("Protected Content")).not.toBeInTheDocument();
  });

  it("uses default fallback path when not specified", async () => {
    (useAuth as jest.Mock).mockReturnValue({
      hasRole: () => false,
      loading: false,
    });

    render(
      <RoleGuard requiredRole="admin">
        <div>Protected Content</div>
      </RoleGuard>,
    );

    await waitFor(() => {
      expect(mockRouter.push).toHaveBeenCalledWith("/dashboard");
    });
  });
});
```

### `src\components\client\ClientList.tsx`

```tsx
"use client";

import React from "react";
import { useClients } from "@/hooks/useClients";
import { Database } from "@/types/database.types";

type Client = Database["public"]["Tables"]["clients"]["Row"];

interface ClientListProps {
  initialClients?: Client[] | null;
}

export default function ClientList({ initialClients }: ClientListProps) {
  const { clients, loading, error, updateClient, deleteClient } =
    useClients(initialClients);

  if (error) {
    return <div className="text-red-600">Error: {error}</div>;
  }

  if (loading && !clients.length) {
    return <div>Loading clients...</div>;
  }

  return (
    <div className="space-y-2">
      {clients.map((client) => (
        <div
          key={client.id}
          className="border p-2 rounded shadow-sm flex justify-between"
        >
          <div>
            <p className="font-semibold">
              {client.full_name || "Unnamed Client"}
            </p>
            <p className="text-sm text-gray-600">{client.contact_email}</p>
          </div>
          <div className="space-x-2">
            <button
              onClick={() => updateClient(client.id, { status: "active" })}
              className="bg-blue-500 text-white px-3 py-1 rounded"
            >
              Activate
            </button>
            <button
              onClick={() => deleteClient(client.id)}
              className="bg-red-500 text-white px-3 py-1 rounded"
            >
              Delete
            </button>
          </div>
        </div>
      ))}
    </div>
  );
}
```

### `src\components\clients\client-combobox.tsx`

```tsx
"use client";

import React from "react";
import { getBrowserClient } from "@/lib/supabase/browser-client";
import { Check, ChevronsUpDown } from "lucide-react";
import { cn } from "@/lib/utils";
import { Button } from "@/components/ui/button";
import {
  Command,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandItem,
} from "@/components/ui/command";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import type { Database } from "@/types/database.types";

interface Client {
  id: string;
  full_name: string | null;
  company_name: string | null;
  type: "business" | "individual";
}

interface ClientComboboxProps {
  onSelectAction?: (clientId: string) => void;
  onChange?: (clientId: string | null) => void;
  selectedId?: string | null;
  value?: string | null;
}

export function ClientCombobox({
  onSelectAction,
  onChange,
  selectedId,
  value,
}: ClientComboboxProps) {
  const [open, setOpen] = React.useState(false);
  const [clients, setClients] = React.useState<Client[]>([]);
  const [loading, setLoading] = React.useState(true);
  const supabase = getBrowserClient();

  React.useEffect(() => {
    async function loadClients() {
      const { data } = await supabase
        .from("clients")
        .select("id, full_name, company_name, type")
        .order("type", { ascending: true })
        .order("company_name", { ascending: true })
        .order("full_name", { ascending: true });

      setClients(
        (data || []).filter(
          (client): client is Client =>
            client.type === "business" || client.type === "individual",
        ),
      );
      setLoading(false);
    }

    loadClients();
  }, []);

  const selected = React.useMemo(
    () => clients.find((client) => client.id === (value ?? selectedId)),
    [clients, value, selectedId],
  );

  const getDisplayName = (client: Client) => {
    if (client.type === "business" && client.company_name) {
      return client.company_name;
    }
    return client.full_name || "Unnamed Client";
  };

  const handleSelect = (clientId: string) => {
    onSelectAction?.(clientId);
    onChange?.(clientId);
    setOpen(false);
  };

  if (loading) {
    return (
      <Button variant="outline" className="w-full justify-between">
        Loading clients...
      </Button>
    );
  }

  return (
    <Popover open={open} onOpenChange={setOpen}>
      <PopoverTrigger asChild>
        <Button
          variant="outline"
          role="combobox"
          aria-expanded={open}
          className="w-full justify-between"
        >
          {selected ? getDisplayName(selected) : "Select client..."}
          <ChevronsUpDown className="ml-2 h-4 w-4 shrink-0 opacity-50" />
        </Button>
      </PopoverTrigger>
      <PopoverContent className="w-[400px] p-0">
        <Command>
          <CommandInput placeholder="Search clients..." />
          <CommandEmpty>No client found.</CommandEmpty>
          <CommandGroup>
            {clients.map((client) => (
              <CommandItem
                key={client.id}
                value={client.id}
                onSelect={() => handleSelect(client.id)}
              >
                <Check
                  className={cn(
                    "mr-2 h-4 w-4",
                    selected?.id === client.id ? "opacity-100" : "opacity-0",
                  )}
                />
                {getDisplayName(client)}
              </CommandItem>
            ))}
          </CommandGroup>
        </Command>
      </PopoverContent>
    </Popover>
  );
}
```

### `src\components\clients\client-details.tsx`

```tsx
"use client";

import { useEffect, useState } from "react";
import { getBrowserClient } from "@/lib/supabase/browser-client";
import type { Database } from "@/types/database.types";
import type { ClientWithRelations, TaxInfo } from "@/types/clients";

interface ClientDetailsProps {
  clientId: string;
}

type ClientResponse = Database["public"]["Tables"]["clients"]["Row"] & {
  documents: Database["public"]["Tables"]["client_documents"]["Row"][];
  workflows: Database["public"]["Tables"]["client_onboarding_workflows"]["Row"][];
  assigned_preparer: Database["public"]["Tables"]["users"]["Row"] | null;
  tax_returns: Database["public"]["Tables"]["tax_returns"]["Row"][];
  projects: Database["public"]["Tables"]["projects"]["Row"][];
};

export function ClientDetails({ clientId }: ClientDetailsProps) {
  const [client, setClient] = useState<ClientWithRelations | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const supabase = getBrowserClient();

  useEffect(() => {
    const fetchClient = async () => {
      try {
        const { data, error } = await supabase
          .from("clients")
          .select(
            `
            *,
            assigned_preparer:users(id, full_name, email),
            documents:client_documents(*),
            workflows:client_onboarding_workflows(*),
            tax_returns:tax_returns(*),
            projects:projects(*)
          `,
          )
          .eq("id", clientId)
          .single();

        if (error) {
          throw error;
        }

        if (data) {
          const clientData = data as unknown as ClientResponse;
          const enhancedClient: ClientWithRelations = {
            ...clientData,
            tax_info: clientData.tax_info as TaxInfo | null,
            documents: clientData.documents,
            workflows: clientData.workflows,
            assigned_preparer: clientData.assigned_preparer,
            tax_returns: clientData.tax_returns,
            projects: clientData.projects,
          };
          setClient(enhancedClient);
        }
      } catch (error) {
        console.error("Error fetching client:", error);
      } finally {
        setIsLoading(false);
      }
    };

    fetchClient();
  }, [clientId, supabase]);

  if (isLoading) {
    return <div>Loading...</div>;
  }

  if (!client) {
    return <div>Client not found</div>;
  }

  const taxInfo = client.tax_info;

  return (
    <div className="space-y-6">
      <div>
        <h2 className="text-2xl font-bold">Client Details</h2>
        <div className="mt-4 grid gap-4 md:grid-cols-2">
          <div>
            <h3 className="font-semibold">Basic Information</h3>
            <div className="mt-2 space-y-2">
              <p>
                <span className="font-medium">Name:</span>{" "}
                {client.full_name || client.company_name}
              </p>
              <p>
                <span className="font-medium">Email:</span>{" "}
                {client.contact_email}
              </p>
              <p>
                <span className="font-medium">Status:</span> {client.status}
              </p>
              <p>
                <span className="font-medium">Type:</span> {client.type}
              </p>
            </div>
          </div>
          <div>
            <h3 className="font-semibold">Tax Information</h3>
            <div className="mt-2 space-y-2">
              <p>
                <span className="font-medium">Filing Status:</span>{" "}
                {taxInfo?.filing_status}
              </p>
              <p>
                <span className="font-medium">Tax ID:</span> {taxInfo?.tax_id}
              </p>
              <p>
                <span className="font-medium">Last Filed:</span>{" "}
                {taxInfo?.last_filed_date}
              </p>
            </div>
          </div>
        </div>
      </div>

      <div>
        <h3 className="font-semibold">Documents</h3>
        <div className="mt-2">
          {client.documents?.length ? (
            <ul className="space-y-2">
              {client.documents.map((doc) => (
                <li key={doc.id}>
                  {doc.document_name} - {doc.status}
                </li>
              ))}
            </ul>
          ) : (
            <p>No documents found</p>
          )}
        </div>
      </div>

      <div>
        <h3 className="font-semibold">Projects</h3>
        <div className="mt-2">
          {client.projects?.length ? (
            <ul className="space-y-2">
              {client.projects.map((project) => (
                <li key={project.id}>
                  {project.name} - {project.status}
                </li>
              ))}
            </ul>
          ) : (
            <p>No projects found</p>
          )}
        </div>
      </div>

      <div>
        <h3 className="font-semibold">Tax Returns</h3>
        <div className="mt-2">
          {client.tax_returns?.length ? (
            <ul className="space-y-2">
              {client.tax_returns.map((taxReturn) => (
                <li key={taxReturn.id}>
                  {taxReturn.tax_year} - {taxReturn.status}
                </li>
              ))}
            </ul>
          ) : (
            <p>No tax returns found</p>
          )}
        </div>
      </div>
    </div>
  );
}

export default ClientDetails;
```

### `src\components\clients\client-dialog.tsx`

```tsx
"use client";

import { useState } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { getBrowserClient } from "@/lib/supabase/browser-client";
import { Database } from "@/types/database.types";
import { DbClient, ClientWithRelations, ClientFormData } from "@/types/clients";
import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { clientFormSchema } from "@/lib/validations/client";

interface ClientDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  client?: DbClient | null;
  onSubmit: (data: ClientFormData) => Promise<void>;
}

export function ClientDialog({
  open,
  onOpenChange,
  client,
  onSubmit,
}: ClientDialogProps) {
  const [isLoading, setIsLoading] = useState(false);
  const {
    register,
    handleSubmit,
    formState: { errors },
    setValue,
    reset,
  } = useForm<ClientFormData>({
    resolver: zodResolver(clientFormSchema),
    defaultValues: {
      id: client?.id || "",
      full_name: client?.full_name || "",
      company_name: client?.company_name || "",
      contact_email: client?.contact_email || "",
      status: client?.status || "pending",
      type: client?.type || "individual",
      tax_info: client?.tax_info
        ? JSON.parse(JSON.stringify(client.tax_info))
        : null,
    },
  });

  const handleFormSubmit = async (data: ClientFormData) => {
    setIsLoading(true);
    try {
      await onSubmit(data);
      reset();
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>{client ? "Edit Client" : "Create Client"}</DialogTitle>
        </DialogHeader>
        <form onSubmit={handleSubmit(handleFormSubmit)} className="space-y-4">
          <div className="space-y-2">
            <Label htmlFor="full_name">Full Name</Label>
            <Input
              id="full_name"
              {...register("full_name")}
              className={errors.full_name ? "border-destructive" : ""}
            />
            {errors.full_name && (
              <p className="text-sm text-destructive">
                {errors.full_name.message}
              </p>
            )}
          </div>
          <div className="space-y-2">
            <Label htmlFor="company_name">Company Name</Label>
            <Input
              id="company_name"
              {...register("company_name")}
              className={errors.company_name ? "border-destructive" : ""}
            />
            {errors.company_name && (
              <p className="text-sm text-destructive">
                {errors.company_name.message}
              </p>
            )}
          </div>
          <div className="space-y-2">
            <Label htmlFor="contact_email">Contact Email</Label>
            <Input
              id="contact_email"
              type="email"
              {...register("contact_email")}
              className={errors.contact_email ? "border-destructive" : ""}
            />
            {errors.contact_email && (
              <p className="text-sm text-destructive">
                {errors.contact_email.message}
              </p>
            )}
          </div>
          <div className="space-y-2">
            <Label htmlFor="status">Status</Label>
            <Select
              onValueChange={(value) => setValue("status", value as any)}
              defaultValue={client?.status || "pending"}
            >
              <SelectTrigger>
                <SelectValue placeholder="Select status" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="active">Active</SelectItem>
                <SelectItem value="inactive">Inactive</SelectItem>
                <SelectItem value="pending">Pending</SelectItem>
                <SelectItem value="archived">Archived</SelectItem>
              </SelectContent>
            </Select>
            {errors.status && (
              <p className="text-sm text-destructive">
                {errors.status.message}
              </p>
            )}
          </div>
          <div className="space-y-2">
            <Label htmlFor="type">Type</Label>
            <Select
              onValueChange={(value) => setValue("type", value as any)}
              defaultValue={client?.type || "individual"}
            >
              <SelectTrigger>
                <SelectValue placeholder="Select type" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="individual">Individual</SelectItem>
                <SelectItem value="business">Business</SelectItem>
              </SelectContent>
            </Select>
            {errors.type && (
              <p className="text-sm text-destructive">{errors.type.message}</p>
            )}
          </div>
          <div className="flex justify-end space-x-2">
            <Button
              type="button"
              variant="outline"
              onClick={() => onOpenChange(false)}
            >
              Cancel
            </Button>
            <Button type="submit" disabled={isLoading}>
              {isLoading
                ? client
                  ? "Updating..."
                  : "Creating..."
                : client
                  ? "Update"
                  : "Create"}
            </Button>
          </div>
        </form>
      </DialogContent>
    </Dialog>
  );
}
```

### `src\components\clients\client-form.tsx`

```tsx
"use client";

import { useState } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import {
  Form,
  FormField,
  FormItem,
  FormLabel,
  FormControl,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import {
  clientFormSchema,
  type ClientFormSchema,
} from "@/lib/validations/client";
import { DbClient, DbClientContactDetails, TaxInfo } from "@/types/clients";
import { Button } from "@/components/ui/button";
import { useToast } from "@/components/ui/use-toast";
import { Loader2 } from "lucide-react";

interface ClientFormProps {
  client?:
    | (DbClient & {
        contact_details?: DbClientContactDetails | null;
        tax_info?: TaxInfo | null;
      })
    | null;
  onSubmit: (data: ClientFormSchema) => Promise<void>;
  defaultValues?: Partial<ClientFormSchema>;
  isEditing?: boolean;
}

export function ClientForm({
  client,
  onSubmit,
  defaultValues,
  isEditing = false,
}: ClientFormProps) {
  const [isSubmitting, setIsSubmitting] = useState(false);
  const { toast } = useToast();

  const form = useForm<ClientFormSchema>({
    resolver: zodResolver(clientFormSchema),
    defaultValues: {
      full_name: client?.full_name || "",
      company_name: client?.company_name || "",
      contact_email: client?.contact_email || "",
      onboarding_notes: client?.onboarding_notes || "",
      status: client?.status || "pending",
      type: client?.type || "individual",
      contact_details: client?.contact_details || {
        phone: "",
        address: "",
        city: "",
        state: "",
        zip: "",
      },
      tax_info: client?.tax_info || {
        filing_status: "",
        tax_id: "",
        tax_year: new Date().getFullYear(),
        filing_type: null,
        tax_id_type: null,
        dependents: [],
        previous_returns: [],
      },
    },
  });

  const handleSubmit = async (data: ClientFormSchema) => {
    try {
      setIsSubmitting(true);
      await onSubmit(data);
      form.reset();
      toast({
        title: "Success",
        description: isEditing
          ? "Client updated successfully"
          : "Client created successfully",
      });
    } catch (error) {
      console.error("Failed to submit client:", error);
      toast({
        title: "Error",
        description: isEditing
          ? "Failed to update client"
          : "Failed to create client",
        variant: "destructive",
      });
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(handleSubmit)} className="space-y-6">
        <Card>
          <CardHeader>
            <CardTitle>Client Information</CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            <FormField
              control={form.control}
              name="full_name"
              render={({ field, fieldState }) => (
                <FormItem>
                  <FormLabel>Full Name</FormLabel>
                  <FormControl>
                    <Input
                      {...field}
                      placeholder="Full name"
                      aria-invalid={fieldState.invalid}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name="company_name"
              render={({ field, fieldState }) => (
                <FormItem>
                  <FormLabel>Company Name</FormLabel>
                  <FormControl>
                    <Input
                      {...field}
                      placeholder="Company name (if applicable)"
                      aria-invalid={fieldState.invalid}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name="contact_email"
              render={({ field, fieldState }) => (
                <FormItem>
                  <FormLabel>Email</FormLabel>
                  <FormControl>
                    <Input
                      {...field}
                      type="email"
                      placeholder="Email address"
                      aria-invalid={fieldState.invalid}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name="onboarding_notes"
              render={({ field, fieldState }) => (
                <FormItem>
                  <FormLabel>Onboarding Notes</FormLabel>
                  <FormControl>
                    <Textarea
                      {...field}
                      placeholder="Add any onboarding notes"
                      aria-invalid={fieldState.invalid}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
          </CardContent>
        </Card>
        <div className="flex justify-end space-x-2">
          <Button type="submit" disabled={isSubmitting}>
            {isSubmitting ? (
              <>
                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                Creating...
              </>
            ) : (
              "Create Client"
            )}
          </Button>
        </div>
      </form>
    </Form>
  );
}
```

### `src\components\clients\client-list.tsx`

```tsx
"use client";

import { useState, useEffect, useTransition } from "react";
import { ColumnManager } from "./column-manager";
import { getBrowserClient } from "@/lib/supabase/browser-client";
import { Mail, FileText, ClipboardList, Trash } from "lucide-react";
import { useToast } from "@/components/ui/use-toast";
import { format } from "date-fns";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";

type Client = {
  id: string;
  full_name: string;
  company_name: string;
  contact_email: string;
  status: string;
  type: string;
  contact_info: {
    phone?: string;
    address?: string;
  };
  tax_info: {
    tax_id?: string;
    filing_status?: string;
    last_filed?: string;
    next_deadline?: string;
  };
  created_at: string;
  updated_at: string;
};

const ALL_COLUMNS = [
  "Name",
  "Company",
  "Contact",
  "Type",
  "Status",
  "Created",
  "Filing Status",
  "Last Filed",
  "Next Deadline",
  "Actions",
];

const COLUMN_STORAGE_KEY = "client-columns-prefs";

export function ClientList() {
  const [visibleColumns, setVisibleColumns] = useState<string[]>(() => {
    // Only run this effect in the browser
    if (typeof window === "undefined") return ALL_COLUMNS;

    // Try to load from localStorage
    const savedColumns = localStorage.getItem(COLUMN_STORAGE_KEY);
    return savedColumns ? JSON.parse(savedColumns) : ALL_COLUMNS;
  });
  const [clients, setClients] = useState<Client[]>([]);
  const [isPending, startTransition] = useTransition();
  const [loading, setLoading] = useState(true);
  const supabase = getBrowserClient();
  const { toast } = useToast();

  const handleQuickEmail = (client: Client) => {
    window.location.href = `mailto:${client.contact_email}`;
  };

  const handleRequestDocument = (client: Client) => {
    // TODO: Implement document request logic
    console.log("Requesting documents from", client.full_name);
  };

  const handleAddNote = (client: Client) => {
    // TODO: Implement add note logic
    console.log("Adding note for", client.full_name);
  };

  const handleDeleteClient = async (clientId: string) => {
    try {
      const { error } = await supabase
        .from("clients")
        .delete()
        .eq("id", clientId);

      if (error) throw error;

      setClients(clients.filter((c) => c.id !== clientId));
      toast({
        title: "Client deleted",
        description: "Client was successfully removed",
      });
    } catch (error) {
      toast({
        title: "Error",
        description: "Failed to delete client",
        variant: "destructive",
      });
    }
  };

  useEffect(() => {
    // Only run this effect in the browser
    if (typeof window === "undefined") return;

    const fetchClients = async () => {
      try {
        const { data, error } = await supabase
          .from("clients")
          .select("*")
          .order("created_at", { ascending: false });

        if (error) throw error;
        setClients(data || []);
      } catch (error) {
        console.error("Error fetching clients:", error);
        toast({
          title: "Error",
          description: "Failed to load clients",
          variant: "destructive",
        });
      } finally {
        setLoading(false);
      }
    };

    startTransition(() => {
      fetchClients();
    });
  }, [supabase, toast]);

  if (loading) {
    return (
      <div className="flex items-center justify-center h-32">
        Loading clients...
      </div>
    );
  }

  return (
    <div className="space-y-4">
      <div className="flex items-center justify-between">
        <h2 className="text-xl font-semibold">Clients</h2>
        <ColumnManager
          allColumns={ALL_COLUMNS}
          visibleColumns={visibleColumns}
          onColumnToggle={(column) => {
            setVisibleColumns((prev) => {
              const newColumns = prev.includes(column)
                ? prev.filter((c) => c !== column)
                : [...prev, column];
              // Save to localStorage
              localStorage.setItem(
                COLUMN_STORAGE_KEY,
                JSON.stringify(newColumns),
              );
              return newColumns;
            });
          }}
        />
      </div>
      <Table>
        <TableHeader>
          <TableRow>
            {visibleColumns.includes("Name") && <TableHead>Name</TableHead>}
            {visibleColumns.includes("Company") && (
              <TableHead>Company</TableHead>
            )}
            {visibleColumns.includes("Contact") && (
              <TableHead>Contact</TableHead>
            )}
            {visibleColumns.includes("Type") && <TableHead>Type</TableHead>}
            {visibleColumns.includes("Status") && <TableHead>Status</TableHead>}
            {visibleColumns.includes("Created") && (
              <TableHead>Created</TableHead>
            )}
            {visibleColumns.includes("Filing Status") && (
              <TableHead>Filing Status</TableHead>
            )}
            {visibleColumns.includes("Last Filed") && (
              <TableHead>Last Filed</TableHead>
            )}
            {visibleColumns.includes("Next Deadline") && (
              <TableHead>Next Deadline</TableHead>
            )}
            {visibleColumns.includes("Actions") && (
              <TableHead className="text-right">Actions</TableHead>
            )}
          </TableRow>
        </TableHeader>
        <TableBody>
          {clients.map((client) => (
            <TableRow key={client.id}>
              {visibleColumns.includes("Name") && (
                <TableCell className="font-medium">
                  <div>
                    <div>{client.full_name}</div>
                    <div className="text-sm text-gray-500">
                      {client.contact_info?.phone}
                    </div>
                  </div>
                </TableCell>
              )}
              {visibleColumns.includes("Company") && (
                <TableCell>{client.company_name || "-"}</TableCell>
              )}
              {visibleColumns.includes("Contact") && (
                <TableCell>
                  <div>
                    <div>{client.contact_email}</div>
                    <div className="text-sm text-gray-500">
                      {client.contact_info?.address}
                    </div>
                  </div>
                </TableCell>
              )}
              {visibleColumns.includes("Type") && (
                <TableCell>
                  <Badge variant="outline">{client.type}</Badge>
                </TableCell>
              )}
              {visibleColumns.includes("Status") && (
                <TableCell>
                  <Badge
                    variant={
                      client.status === "active" ? "default" : "secondary"
                    }
                  >
                    {client.status}
                  </Badge>
                </TableCell>
              )}
              {visibleColumns.includes("Created") && (
                <TableCell>
                  {format(new Date(client.created_at), "MMM d, yyyy")}
                </TableCell>
              )}
              {visibleColumns.includes("Filing Status") && (
                <TableCell>{client.tax_info?.filing_status || "-"}</TableCell>
              )}
              {visibleColumns.includes("Last Filed") && (
                <TableCell>
                  {client.tax_info?.last_filed
                    ? format(new Date(client.tax_info.last_filed), "MM/dd/yyyy")
                    : "-"}
                </TableCell>
              )}
              {visibleColumns.includes("Next Deadline") && (
                <TableCell>
                  {client.tax_info?.next_deadline
                    ? format(
                        new Date(client.tax_info.next_deadline),
                        "MM/dd/yyyy",
                      )
                    : "-"}
                </TableCell>
              )}
              {visibleColumns.includes("Actions") && (
                <TableCell className="space-x-2">
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={() => handleQuickEmail(client)}
                    aria-label="Email client"
                  >
                    <Mail className="h-4 w-4" />
                  </Button>
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={() => handleRequestDocument(client)}
                    aria-label="Request documents"
                  >
                    <FileText className="h-4 w-4" />
                  </Button>
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={() => handleAddNote(client)}
                    aria-label="Add note"
                  >
                    <ClipboardList className="h-4 w-4" />
                  </Button>
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={() => handleDeleteClient(client.id)}
                    aria-label="Delete client"
                  >
                    <Trash className="h-4 w-4" />
                  </Button>
                </TableCell>
              )}
            </TableRow>
          ))}
        </TableBody>
      </Table>
    </div>
  );
}
```

### `src\components\clients\client-select.tsx`

```tsx
"use client";

import { Check, ChevronsUpDown } from "lucide-react";
import * as React from "react";
import { cn } from "@/lib/utils";
import { Button } from "@/components/ui/button";
import {
  Command,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandItem,
} from "@/components/ui/command";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { DbClient } from "@/types/clients";

interface ClientSelectProps {
  value?: string;
  onSelect: (value: string) => void;
  clients: DbClient[];
  disabled?: boolean;
}

export function ClientSelect({
  value,
  onSelect,
  clients,
  disabled,
}: ClientSelectProps) {
  const [open, setOpen] = React.useState(false);
  const selectedClient = React.useMemo(
    () => clients.find((client) => client.id === value),
    [clients, value],
  );

  return (
    <Popover open={open} onOpenChange={setOpen}>
      <PopoverTrigger asChild>
        <Button
          variant="outline"
          role="combobox"
          aria-expanded={open}
          className="w-full justify-between"
          disabled={disabled}
        >
          {selectedClient ? (
            <span>
              {selectedClient.company_name || selectedClient.full_name}
            </span>
          ) : (
            "Select client..."
          )}
          <ChevronsUpDown className="ml-2 h-4 w-4 shrink-0 opacity-50" />
        </Button>
      </PopoverTrigger>
      <PopoverContent className="w-full p-0">
        <Command>
          <CommandInput placeholder="Search clients..." />
          <CommandEmpty>No client found.</CommandEmpty>
          <CommandGroup>
            {clients.map((client) => (
              <CommandItem
                key={client.id}
                value={client.id}
                onSelect={(currentValue) => {
                  onSelect(currentValue);
                  setOpen(false);
                }}
              >
                <Check
                  className={cn(
                    "mr-2 h-4 w-4",
                    value === client.id ? "opacity-100" : "opacity-0",
                  )}
                />
                {client.company_name || client.full_name}
              </CommandItem>
            ))}
          </CommandGroup>
        </Command>
      </PopoverContent>
    </Popover>
  );
}
```

### `src\components\clients\column-manager.tsx`

```tsx
"use client";

import { Checkbox } from "@/components/ui/checkbox";
import { Button } from "@/components/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { Settings } from "lucide-react";

interface ColumnManagerProps {
  allColumns: string[];
  visibleColumns: string[];
  onColumnToggle: (column: string) => void;
}

export function ColumnManager({
  allColumns,
  visibleColumns,
  onColumnToggle,
}: ColumnManagerProps) {
  return (
    <div className="flex justify-end">
      <DropdownMenu>
        <DropdownMenuTrigger asChild>
          <Button variant="outline" size="sm" className="ml-auto h-8">
            <Settings className="mr-2 h-4 w-4" />
            Columns
          </Button>
        </DropdownMenuTrigger>
        <DropdownMenuContent align="end" className="w-[200px]">
          {allColumns.map((column) => (
            <DropdownMenuItem
              key={column}
              onClick={(e) => {
                e.preventDefault();
                e.stopPropagation();
                onColumnToggle(column);
              }}
              className="cursor-pointer"
            >
              <Checkbox
                checked={visibleColumns.includes(column)}
                className="mr-2"
              />
              {column}
            </DropdownMenuItem>
          ))}
        </DropdownMenuContent>
      </DropdownMenu>
    </div>
  );
}
```

### `src\components\communication\ChatPanel.tsx`

```tsx
"use client";

import React, { useState } from "react";
import { Card, CardHeader, CardContent, CardTitle } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";

interface Message {
  id: number;
  text: string;
  sender: string;
}

export default function ChatPanel() {
  const [messages, setMessages] = useState<Message[]>([
    { id: 1, text: "Welcome to the chat!", sender: "System" },
  ]);
  const [inputValue, setInputValue] = useState("");
  const [msgId, setMsgId] = useState(2);

  function handleSend() {
    if (!inputValue.trim()) return;
    setMessages((prev) => [
      ...prev,
      { id: msgId, text: inputValue, sender: "You" },
    ]);
    setMsgId((prev) => prev + 1);
    setInputValue("");
  }

  return (
    <Card className="h-[400px] flex flex-col">
      <CardHeader>
        <CardTitle>Staff Communication</CardTitle>
      </CardHeader>
      <CardContent className="flex-1 overflow-y-auto space-y-2">
        {messages.map((m) => (
          <div key={m.id}>
            <span className="font-semibold">{m.sender}:</span> {m.text}
          </div>
        ))}
      </CardContent>
      <div className="p-2 flex gap-2">
        <Input
          placeholder="Type a message..."
          value={inputValue}
          onChange={(e) => setInputValue(e.target.value)}
        />
        <Button onClick={handleSend}>Send</Button>
      </div>
    </Card>
  );
}
```

### `src\components\dashboard\dashboard-tabs.tsx`

```tsx
"use client";

import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Overview } from "@/components/dashboard/overview";
import { RecentActivity } from "@/components/dashboard/recent-activity";
import { TaskQueue } from "@/components/dashboard/task-queue";
import { ErrorView } from "@/components/dashboard/error-view";

interface DashboardTabsProps {
  totalActiveClients: number;
  pendingTaxReturns: number;
  activeProjects: number;
  upcomingDeadlines: number;
  errorTitle?: string;
  errorMessage?: string;
}

export function DashboardTabs({
  totalActiveClients,
  pendingTaxReturns,
  activeProjects,
  upcomingDeadlines,
  errorTitle,
  errorMessage,
}: DashboardTabsProps) {
  if (errorTitle && errorMessage) {
    return <ErrorView title={errorTitle} message={errorMessage} />;
  }

  return (
    <Tabs defaultValue="overview" className="space-y-4">
      <TabsList>
        <TabsTrigger value="overview">Overview</TabsTrigger>
        <TabsTrigger value="activity">Recent Activity</TabsTrigger>
        <TabsTrigger value="queue">Task Queue</TabsTrigger>
      </TabsList>
      <TabsContent value="overview" className="space-y-4">
        <Overview
          totalActiveClients={totalActiveClients}
          pendingTaxReturns={pendingTaxReturns}
          activeProjects={activeProjects}
          upcomingDeadlines={upcomingDeadlines}
        />
      </TabsContent>
      <TabsContent value="activity">
        <RecentActivity />
      </TabsContent>
      <TabsContent value="queue">
        <TaskQueue />
      </TabsContent>
    </Tabs>
  );
}
```

### `src\components\dashboard\Dashboard.js`

```js

```

### `src\components\dashboard\DashboardHeader.tsx`

```tsx
import { getServerClient } from "@/lib/supabase/server-client";

export async function DashboardHeader() {
  const supabase = getServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  return (
    <div className="flex items-center justify-between p-6 border-b">
      <h1 className="text-2xl font-bold">
        Welcome, {user?.user_metadata?.full_name || user?.email}
      </h1>
    </div>
  );
}
```

### `src\components\dashboard\DashboardMetrics.tsx`

```tsx
import { Card } from "@/components/ui/card";

interface DashboardMetricsProps {
  metrics: {
    totalActiveClients: number;
    pendingTaxReturns: number;
    activeProjects: number;
    upcomingDeadlines: number;
  };
}

export function DashboardMetrics({ metrics }: DashboardMetricsProps) {
  const metricsData = [
    {
      title: "Active Clients",
      value: metrics.totalActiveClients,
      description: "Total number of active clients",
    },
    {
      title: "Pending Returns",
      value: metrics.pendingTaxReturns,
      description: "Tax returns awaiting completion",
    },
    {
      title: "Active Projects",
      value: metrics.activeProjects,
      description: "Projects in progress or review",
    },
    {
      title: "Upcoming Deadlines",
      value: metrics.upcomingDeadlines,
      description: "Tasks due in the next 7 days",
    },
  ];

  return (
    <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-4">
      {metricsData.map((metric) => (
        <Card key={metric.title} className="p-6">
          <div className="flex flex-col gap-2">
            <h3 className="text-lg font-semibold">{metric.title}</h3>
            <p className="text-3xl font-bold">{metric.value}</p>
            <p className="text-sm text-muted-foreground">
              {metric.description}
            </p>
          </div>
        </Card>
      ))}
    </div>
  );
}
```

### `src\components\dashboard\error-view.tsx`

```tsx
"use client";

import { Button } from "@/components/ui/button";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { AlertTriangle } from "lucide-react";

interface ErrorViewProps {
  title: string;
  message: string;
}

export function ErrorView({ title, message }: ErrorViewProps) {
  return (
    <Alert variant="destructive">
      <AlertTriangle className="h-4 w-4" />
      <AlertTitle>{title}</AlertTitle>
      <AlertDescription className="mt-2 flex flex-col gap-3">
        <p>{message}</p>
        <Button
          variant="outline"
          onClick={() => window.location.reload()}
          className="w-fit"
        >
          Try Again
        </Button>
      </AlertDescription>
    </Alert>
  );
}
```

### `src\components\dashboard\focus-now-dashboard.tsx`

```tsx
"use client";

export function FocusNowDashboard() {
  return (
    <div>
      <h2 className="text-xl font-semibold">Focus Now Dashboard</h2>
      {/* Add your Focus Now Dashboard implementation here */}
    </div>
  );
}
```

### `src\components\dashboard\overview.tsx`

```tsx
"use client";

import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";

interface OverviewProps {
  totalActiveClients: number;
  pendingTaxReturns: number;
  activeProjects: number;
  upcomingDeadlines: number;
}

export function Overview({
  totalActiveClients,
  pendingTaxReturns,
  activeProjects,
  upcomingDeadlines,
}: OverviewProps) {
  return (
    <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-4">
      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle className="text-sm font-medium">
            Total Active Clients
          </CardTitle>
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold">{totalActiveClients}</div>
        </CardContent>
      </Card>

      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle className="text-sm font-medium">
            Pending Tax Returns
          </CardTitle>
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold">{pendingTaxReturns}</div>
          <p className="text-xs text-muted-foreground">
            Not started or gathering documents
          </p>
        </CardContent>
      </Card>

      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle className="text-sm font-medium">Active Projects</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold">{activeProjects}</div>
          <p className="text-xs text-muted-foreground">
            Todo, in progress, or review
          </p>
        </CardContent>
      </Card>

      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle className="text-sm font-medium">
            Upcoming Deadlines
          </CardTitle>
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold">{upcomingDeadlines}</div>
          <p className="text-xs text-muted-foreground">Due within 7 days</p>
        </CardContent>
      </Card>
    </div>
  );
}
```

### `src\components\dashboard\recent-activity.tsx`

```tsx
"use client";

import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { ScrollArea } from "@/components/ui/scroll-area";

export function RecentActivity() {
  return (
    <Card>
      <CardHeader>
        <CardTitle>Recent Activity</CardTitle>
      </CardHeader>
      <CardContent>
        <ScrollArea className="h-[400px]">
          <div className="space-y-4">
            <div className="text-sm text-muted-foreground">
              Activity tracking will be implemented in future phases.
            </div>
          </div>
        </ScrollArea>
      </CardContent>
    </Card>
  );
}
```

### `src\components\dashboard\revenue-card.tsx`

```tsx
"use client";

import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { LineChart } from "@/components/ui/line-chart";

interface RevenueCardProps {
  revenue: number;
  percentageChange: number;
  data: number[];
}

export function RevenueCard({
  revenue,
  percentageChange,
  data,
}: RevenueCardProps) {
  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
        <CardTitle className="text-sm font-medium">Total Revenue</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="text-2xl font-bold">${revenue.toLocaleString()}</div>
        <p className="text-xs text-muted-foreground">
          +{percentageChange}% from last month
        </p>
        <div className="h-[80px]">
          <LineChart
            data={data}
            className="h-full w-full"
            pathClassName="stroke-[hsl(var(--chart-1))]"
          />
        </div>
      </CardContent>
    </Card>
  );
}
```

### `src\components\dashboard\Sidebar.tsx`

```tsx
"use client";

import React from "react";
import Link from "next/link";
import { usePathname } from "next/navigation";
import { cn } from "@/lib/utils";
import { Button } from "@/components/ui/button";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Separator } from "@/components/ui/separator";
import { Home, Settings, Users, FileText, BarChart } from "lucide-react";

interface SidebarNavProps extends React.HTMLAttributes<HTMLElement> {
  items?: {
    href: string;
    title: string;
    icon: React.ReactNode;
  }[];
}

export default function Sidebar({ className }: SidebarNavProps) {
  const pathname = usePathname();

  const items = [
    {
      href: "/dashboard",
      title: "Home",
      icon: <Home className="mr-2 h-4 w-4" />,
    },
    {
      href: "/dashboard/clients",
      title: "Clients",
      icon: <Users className="mr-2 h-4 w-4" />,
    },
    {
      href: "/dashboard/tax-returns",
      title: "Tax Returns",
      icon: <FileText className="mr-2 h-4 w-4" />,
    },
    {
      href: "/dashboard/analytics",
      title: "Analytics",
      icon: <BarChart className="mr-2 h-4 w-4" />,
    },
    {
      href: "/dashboard/settings",
      title: "Settings",
      icon: <Settings className="mr-2 h-4 w-4" />,
    },
  ];

  return (
    <aside className={cn("pb-12 w-64", className)}>
      <div className="space-y-4 py-4">
        <div className="px-4 py-2">
          <h2 className="mb-2 px-2 text-lg font-semibold tracking-tight">
            American Dream Taxes
          </h2>
          <Separator className="my-4" />
        </div>
        <ScrollArea className="h-[calc(100vh-8rem)]">
          <div className="space-y-1 p-2">
            {items.map((item) => (
              <Button
                key={item.href}
                variant={pathname === item.href ? "secondary" : "ghost"}
                className={cn(
                  "w-full justify-start",
                  pathname === item.href && "bg-muted",
                )}
                asChild
              >
                <Link href={item.href}>
                  {item.icon}
                  {item.title}
                </Link>
              </Button>
            ))}
          </div>
        </ScrollArea>
      </div>
    </aside>
  );
}
```

### `src\components\dashboard\smart-queue.tsx`

```tsx
"use client";

export function SmartQueue() {
  return (
    <div>
      <h2 className="text-xl font-semibold">Smart Queue</h2>
      {/* Add your Smart Queue implementation here */}
    </div>
  );
}
```

### `src\components\dashboard\subscriptions-card.tsx`

```tsx
"use client";

import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { BarChart } from "@/components/ui/bar-chart";

interface SubscriptionsCardProps {
  count: number;
  percentageChange: number;
  data: number[];
}

export function SubscriptionsCard({
  count,
  percentageChange,
  data,
}: SubscriptionsCardProps) {
  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
        <CardTitle className="text-sm font-medium">Subscriptions</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="text-2xl font-bold">+{count}</div>
        <p className="text-xs text-muted-foreground">
          +{percentageChange}% from last month
        </p>
        <div className="h-[80px]">
          <BarChart
            data={data}
            className="h-full w-full"
            pathClassName="fill-[hsl(var(--chart-2))]"
          />
        </div>
      </CardContent>
    </Card>
  );
}
```

### `src\components\dashboard\task-queue.tsx`

```tsx
"use client";

import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";

export function TaskQueue() {
  return (
    <Card>
      <CardHeader>
        <CardTitle>Task Queue</CardTitle>
        <CardDescription>Your upcoming and pending tasks</CardDescription>
      </CardHeader>
      <CardContent>
        <div className="space-y-8">
          <div className="flex items-center justify-between">
            <div className="space-y-1">
              <p className="text-sm font-medium leading-none">
                Review Q1 Financial Statements
              </p>
              <p className="text-sm text-muted-foreground">Due in 2 days</p>
            </div>
            <Badge>High Priority</Badge>
          </div>
          <div className="flex items-center justify-between">
            <div className="space-y-1">
              <p className="text-sm font-medium leading-none">
                Prepare Tax Returns for Smith Co
              </p>
              <p className="text-sm text-muted-foreground">Due in 5 days</p>
            </div>
            <Badge variant="secondary">Medium Priority</Badge>
          </div>
          <div className="flex items-center justify-between">
            <div className="space-y-1">
              <p className="text-sm font-medium leading-none">
                Client Meeting: ABC Corp
              </p>
              <p className="text-sm text-muted-foreground">Tomorrow at 2 PM</p>
            </div>
            <Badge variant="outline">Low Priority</Badge>
          </div>
        </div>
      </CardContent>
    </Card>
  );
}
```

### `src\components\dashboard\UserNav.tsx`

```tsx
"use client";

import React from "react";

export const UserNav: React.FC = () => {
  return (
    <div className="flex items-center">
      <span className="mr-2">User Name</span>
      <button className="px-3 py-1 bg-blue-500 text-white rounded">
        Logout
      </button>
    </div>
  );
};
```

### `src\components\document\DocumentList.tsx`

```tsx
"use client";

import React from "react";
import { useDocuments } from "@/hooks/useDocuments";
import { Database } from "@/types/database.types";

type Document = Database["public"]["Tables"]["documents"]["Row"];

interface DocumentListProps {
  initialDocuments?: Document[] | null;
}

export default function DocumentList({ initialDocuments }: DocumentListProps) {
  const { documents, loading, error, updateDocument, deleteDocument } =
    useDocuments(initialDocuments);

  if (error) {
    return <div className="text-red-600">Error: {error}</div>;
  }

  if (loading && !documents.length) {
    return <div>Loading documents...</div>;
  }

  return (
    <div className="space-y-2">
      {documents.map((document) => (
        <div
          key={document.id}
          className="border p-2 rounded shadow-sm flex justify-between"
        >
          <div>
            <p className="font-semibold">{document.file_name}</p>
            <p className="text-sm text-gray-600">Status: {document.status}</p>
          </div>
          <div className="space-x-2">
            <button
              onClick={() =>
                updateDocument(document.id, { status: "processed" })
              }
              className="bg-blue-500 text-white px-3 py-1 rounded"
            >
              Mark Processed
            </button>
            <button
              onClick={() => deleteDocument(document.id, document.file_path)}
              className="bg-red-500 text-white px-3 py-1 rounded"
            >
              Delete
            </button>
          </div>
        </div>
      ))}
    </div>
  );
}
```

### `src\components\documents\document-tracker.tsx`

```tsx
import { useEffect, useState } from "react";

interface DocumentTrackerProps {
  projectId: string;
}

export default function DocumentTracker({ projectId }: DocumentTrackerProps) {
  const [documents, setDocuments] = useState<any[]>([]);

  useEffect(() => {
    const fetchDocuments = async () => {
      const response = await fetch(
        `/api/documents/status?project_id=${projectId}`,
      );
      if (response.ok) {
        const data = await response.json();
        setDocuments(data);
      }
    };

    fetchDocuments();
  }, [projectId]);

  const sendReminder = async (documentId: string) => {
    const response = await fetch("/api/documents/reminders", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ documentId }),
    });

    if (response.ok) {
      setDocuments((prev) =>
        prev.map((doc) =>
          doc.id === documentId ? { ...doc, reminder_sent: true } : doc,
        ),
      );
    }
  };

  return (
    <div className="space-y-4">
      {documents.map((document) => (
        <div key={document.id} className="p-4 border rounded">
          <div className="flex justify-between items-center">
            <div>
              <h3 className="font-medium">{document.document_name}</h3>
              <p className="text-sm text-gray-500">Status: {document.status}</p>
              {document.due_date && (
                <p className="text-sm text-gray-500">
                  Due Date: {new Date(document.due_date).toLocaleDateString()}
                </p>
              )}
            </div>
            {!document.reminder_sent && (
              <button
                onClick={() => sendReminder(document.id)}
                className="px-4 py-2 text-sm font-medium text-white bg-blue-600 rounded hover:bg-blue-700"
              >
                Send Reminder
              </button>
            )}
          </div>
        </div>
      ))}
    </div>
  );
}
```

### `src\components\forms\project\basic-info-form.tsx`

```tsx
"use client";

import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import {
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { UseFormReturn } from "react-hook-form";
import { ProjectFormValues } from "@/lib/validations/project";
import { Tables } from "@/types/database.types";

type Client = Tables<"clients">;
type ProjectTemplate = Tables<"project_templates"> & {
  tasks: Tables<"template_tasks">[];
};

interface BasicInfoFormProps {
  form: UseFormReturn<ProjectFormValues>;
  clients: Client[];
  templates?: ProjectTemplate[];
  templatesLoading?: boolean;
}

export function BasicInfoForm({
  form,
  clients,
  templates = [],
  templatesLoading = false,
}: BasicInfoFormProps) {
  // Group clients by type and create appropriate labels
  const clientOptions = clients
    .sort((a, b) => {
      // Sort by type first, then by name
      if (a.type !== b.type) {
        return a.type === "business" ? -1 : 1;
      }
      // For businesses, sort by company name
      if (a.type === "business") {
        return (a.company_name || "").localeCompare(b.company_name || "");
      }
      // For individuals, sort by full name
      return (a.full_name || "").localeCompare(b.full_name || "");
    })
    .map((client) => ({
      value: client.id,
      label:
        client.type === "business"
          ? `${client.company_name || "Unnamed Business"}`
          : `${client.full_name || "Unnamed Individual"}`,
      group:
        client.type === "business" ? "Business Clients" : "Individual Clients",
    }));

  const templateOptions = templates.map((template) => ({
    value: template.id,
    label: template.title,
  }));

  return (
    <Card>
      <CardHeader>
        <CardTitle>Basic Project Information</CardTitle>
      </CardHeader>
      <CardContent className="space-y-4">
        <FormField
          control={form.control}
          name="name"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Project Name</FormLabel>
              <FormControl>
                <Input {...field} placeholder="Enter project name" />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={form.control}
          name="client_id"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Client</FormLabel>
              <FormControl>
                <Select
                  value={field.value || ""}
                  onValueChange={field.onChange}
                >
                  <SelectTrigger>
                    <SelectValue placeholder="Select a client" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectGroup>
                      <SelectLabel>Business Clients</SelectLabel>
                      {clientOptions
                        .filter((option) => option.group === "Business Clients")
                        .map((option) => (
                          <SelectItem key={option.value} value={option.value}>
                            {option.label}
                          </SelectItem>
                        ))}
                    </SelectGroup>
                    <SelectGroup>
                      <SelectLabel>Individual Clients</SelectLabel>
                      {clientOptions
                        .filter(
                          (option) => option.group === "Individual Clients",
                        )
                        .map((option) => (
                          <SelectItem key={option.value} value={option.value}>
                            {option.label}
                          </SelectItem>
                        ))}
                    </SelectGroup>
                  </SelectContent>
                </Select>
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={form.control}
          name="template_id"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Project Template</FormLabel>
              <FormControl>
                <Select
                  value={field.value || ""}
                  onValueChange={field.onChange}
                >
                  <SelectTrigger>
                    <SelectValue
                      placeholder={
                        templatesLoading
                          ? "Loading templates..."
                          : "Select a template"
                      }
                    />
                  </SelectTrigger>
                  <SelectContent>
                    {templateOptions.map((option) => (
                      <SelectItem key={option.value} value={option.value}>
                        {option.label}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={form.control}
          name="description"
          render={({ field: { value, onChange, ...field } }) => (
            <FormItem>
              <FormLabel>Description</FormLabel>
              <FormControl>
                <Textarea
                  value={value || ""}
                  onChange={onChange}
                  {...field}
                  placeholder="Enter project description"
                  className="min-h-[100px]"
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
      </CardContent>
    </Card>
  );
}
```

### `src\components\forms\project\service-details-form.tsx`

```tsx
"use client";

import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { SelectField } from "../shared/select-field";
import { UseFormReturn } from "react-hook-form";
import { ProjectFormValues } from "@/lib/validations/project";
import { ServiceType } from "@/types/projects";
import { Tables } from "@/types/database.types";

interface ServiceDetailsFormProps {
  form: UseFormReturn<ProjectFormValues>;
  taxReturns?: Tables<"tax_returns">[];
  loading?: boolean;
}

const SERVICE_OPTIONS: { value: ServiceType; label: string }[] = [
  { value: "tax_return", label: "Tax Return" },
  { value: "bookkeeping", label: "Bookkeeping" },
  { value: "payroll", label: "Payroll" },
  { value: "advisory", label: "Advisory" },
];

const TAX_RETURN_STATUS_OPTIONS = [
  { value: "not_started", label: "Not Started" },
  { value: "in_progress", label: "In Progress" },
  { value: "review_needed", label: "Review Needed" },
  { value: "completed", label: "Completed" },
];

export function ServiceDetailsForm({
  form,
  taxReturns = [],
  loading = false,
}: ServiceDetailsFormProps) {
  const watchedServiceType = form.watch("service_type") as ServiceType;
  const watchedClientId = form.watch("client_id");

  const clientTaxReturns = taxReturns.filter(
    (tr) => tr.client_id === watchedClientId,
  );
  const taxReturnOptions = clientTaxReturns.map((tr) => ({
    value: tr.id.toString(),
    label: `${tr.tax_year || "Unknown Year"} - ${tr.filing_type || "Unspecified Type"}`,
  }));

  return (
    <Card>
      <CardHeader>
        <CardTitle>Service Details</CardTitle>
      </CardHeader>
      <CardContent className="space-y-4">
        <SelectField
          form={form}
          name="service_type"
          label="Service Type"
          options={SERVICE_OPTIONS}
          placeholder="Select service type"
        />

        {watchedServiceType === "tax_return" && (
          <div className="space-y-4">
            <h3 className="text-sm font-medium">Tax Return Details</h3>
            <SelectField
              form={form}
              name="tax_return_id"
              label="Tax Return"
              options={taxReturnOptions}
              placeholder={
                loading ? "Loading tax returns..." : "Select tax return"
              }
              description="Select the tax return this project is for"
            />
            <SelectField
              form={form}
              name="tax_return_status"
              label="Initial Status"
              options={TAX_RETURN_STATUS_OPTIONS}
              placeholder="Select initial status"
              defaultValue="not_started"
            />
          </div>
        )}

        {watchedServiceType === "bookkeeping" && (
          <div className="space-y-4">
            <h3 className="text-sm font-medium">Bookkeeping Details</h3>
            <SelectField
              form={form}
              name="accounting_period"
              label="Accounting Period"
              options={[
                { value: "monthly", label: "Monthly" },
                { value: "quarterly", label: "Quarterly" },
                { value: "annual", label: "Annual" },
              ]}
              placeholder="Select period"
            />
          </div>
        )}
      </CardContent>
    </Card>
  );
}
```

### `src\components\forms\project\task-form.tsx`

```tsx
"use client";

import { useForm } from "react-hook-form";
import { Button } from "@/components/ui/button";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { TaskFormData } from "@/types/tasks";

interface TaskFormProps {
  defaultValues?: Partial<TaskFormData>;
  onSubmit: (data: TaskFormData) => Promise<void>;
}

export function TaskForm({ defaultValues, onSubmit }: TaskFormProps) {
  const form = useForm<TaskFormData>({
    defaultValues: defaultValues || {
      title: "",
      description: "",
      status: "todo",
      priority: "medium",
    },
  });

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
        <FormField
          control={form.control}
          name="title"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Title</FormLabel>
              <FormControl>
                <Input {...field} />
              </FormControl>
            </FormItem>
          )}
        />
        <FormField
          control={form.control}
          name="description"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Description</FormLabel>
              <FormControl>
                <Textarea {...field} />
              </FormControl>
            </FormItem>
          )}
        />
        <div className="flex justify-end">
          <Button type="submit">Save</Button>
        </div>
      </form>
    </Form>
  );
}
```

### `src\components\forms\project\timeline-team-form.tsx`

```tsx
"use client";

import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { DatePickerField } from "../shared/date-picker-field";
import { MultiSelectField } from "../shared/multi-select-field";
import { UseFormReturn } from "react-hook-form";
import { ProjectFormValues } from "@/lib/validations/project";
import { TaskForm } from "./task-form";

interface TimelineTeamFormProps {
  form: UseFormReturn<ProjectFormValues>;
  teamMembers: Array<{ id: string; name: string }>;
}

export function TimelineTeamForm({ form, teamMembers }: TimelineTeamFormProps) {
  const teamMemberOptions = teamMembers.map((member) => ({
    value: member.id,
    label: member.name,
  }));

  const handleAddTask = () => {
    const currentTasks = form.getValues("template_tasks") || [];
    form.setValue("template_tasks", [
      ...currentTasks,
      {
        title: "",
        description: "",
        priority: "medium",
        dependencies: [],
        assigned_team: [],
        status: "not_started",
        progress: 0,
      },
    ]);
  };

  return (
    <Card>
      <CardHeader>
        <CardTitle>Timeline & Team</CardTitle>
      </CardHeader>
      <CardContent className="space-y-4">
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          <DatePickerField form={form} name="due_date" label="Due Date" />

          <MultiSelectField
            form={form}
            name="team_members"
            label="Team Members"
            options={teamMemberOptions}
            placeholder="Select team members"
          />
        </div>

        <div className="space-y-4">
          <div className="flex items-center justify-between">
            <h3 className="text-sm font-medium">Tasks</h3>
            <Button
              type="button"
              variant="outline"
              size="sm"
              onClick={handleAddTask}
            >
              Add Task
            </Button>
          </div>

          {form.watch("template_tasks")?.map((_, index) => (
            <TaskForm
              key={index}
              defaultValues={{
                title: "",
                description: "",
                status: "todo",
                priority: "medium",
              }}
              onSubmit={async (data) => {
                // Handle task submission
                console.log("Task submitted:", data);
              }}
            />
          ))}
        </div>
      </CardContent>
    </Card>
  );
}
```

### `src\components\forms\project\__tests__\basic-info-form.test.tsx`

```tsx
import { jest } from "@jest/globals";
import { render, screen, fireEvent } from "@testing-library/react";
import { BasicInfoForm } from "../basic-info-form";
import { useForm } from "react-hook-form";
import { ProjectFormValues } from "@/lib/validations/project";

// Mock the form hook
jest.mock("react-hook-form", () => ({
  useForm: jest.fn(),
}));

describe("BasicInfoForm", () => {
  const mockClients = [
    {
      id: "client1",
      type: "business",
      company_name: "Test Company",
      status: "active",
    },
    {
      id: "client2",
      type: "individual",
      full_name: "John Doe",
      status: "active",
    },
  ];

  const mockTemplates = [
    {
      id: "template1",
      name: "Tax Return Template",
      tasks: [],
    },
  ];

  const mockForm = {
    control: {
      register: jest.fn(),
      unregister: jest.fn(),
    },
    setValue: jest.fn(),
    watch: jest.fn(),
  };

  beforeEach(() => {
    (useForm as jest.Mock).mockReturnValue(mockForm);
  });

  it("renders project name input", () => {
    render(
      <BasicInfoForm
        form={mockForm as any}
        clients={mockClients as any}
        templates={mockTemplates as any}
      />,
    );
    expect(screen.getByLabelText(/Project Name/i)).toBeInTheDocument();
  });

  it("renders client selection dropdown", () => {
    render(
      <BasicInfoForm
        form={mockForm as any}
        clients={mockClients as any}
        templates={mockTemplates as any}
      />,
    );
    expect(screen.getByText(/Select a client/i)).toBeInTheDocument();
  });

  it("groups clients by type", () => {
    render(
      <BasicInfoForm
        form={mockForm as any}
        clients={mockClients as any}
        templates={mockTemplates as any}
      />,
    );
    expect(screen.getByText("Business Clients")).toBeInTheDocument();
    expect(screen.getByText("Individual Clients")).toBeInTheDocument();
  });

  it("displays template selection when templates are provided", () => {
    render(
      <BasicInfoForm
        form={mockForm as any}
        clients={mockClients as any}
        templates={mockTemplates as any}
      />,
    );
    expect(screen.getByText(/Project Template/i)).toBeInTheDocument();
    expect(screen.getByText(/Select a template/i)).toBeInTheDocument();
  });

  it("shows loading state for templates when templatesLoading is true", () => {
    render(
      <BasicInfoForm
        form={mockForm as any}
        clients={mockClients as any}
        templates={mockTemplates as any}
        templatesLoading={true}
      />,
    );
    expect(screen.getByText(/Loading templates/i)).toBeInTheDocument();
  });
});
```

### `src\components\forms\shared\date-picker-field.tsx`

```tsx
"use client";

import {
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Button } from "@/components/ui/button";
import { Calendar } from "@/components/ui/calendar";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { CalendarIcon } from "lucide-react";
import { format } from "date-fns";
import { cn } from "@/lib/utils";
import { UseFormReturn } from "react-hook-form";

interface DatePickerFieldProps {
  form: UseFormReturn<any>;
  name: string;
  label: string;
  placeholder?: string;
  disabled?: (date: Date) => boolean;
}

export function DatePickerField({
  form,
  name,
  label,
  placeholder = "Pick a date",
  disabled = (date) => date < new Date() || date < new Date("1900-01-01"),
}: DatePickerFieldProps) {
  return (
    <FormField
      control={form.control}
      name={name}
      render={({ field }) => (
        <FormItem className="flex flex-col">
          <FormLabel>{label}</FormLabel>
          <Popover>
            <PopoverTrigger asChild>
              <FormControl>
                <Button
                  variant="outline"
                  className={cn(
                    "w-full pl-3 text-left font-normal",
                    !field.value && "text-muted-foreground",
                  )}
                >
                  {field.value ? (
                    format(field.value, "PPP")
                  ) : (
                    <span>{placeholder}</span>
                  )}
                  <CalendarIcon className="ml-auto h-4 w-4 opacity-50" />
                </Button>
              </FormControl>
            </PopoverTrigger>
            <PopoverContent className="w-auto p-0" align="start">
              <Calendar
                mode="single"
                selected={field.value}
                onSelect={field.onChange}
                disabled={disabled}
                initialFocus
              />
            </PopoverContent>
          </Popover>
          <FormMessage />
        </FormItem>
      )}
    />
  );
}
```

### `src\components\forms\shared\multi-select-field.tsx`

```tsx
"use client";

import {
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { MultiSelect } from "@/components/ui/multi-select";
import { UseFormReturn } from "react-hook-form";

interface Option {
  value: string;
  label: string;
}

interface MultiSelectFieldProps {
  form: UseFormReturn<any>;
  name: string;
  label: string;
  options: Option[];
  placeholder?: string;
  description?: string;
}

export function MultiSelectField({
  form,
  name,
  label,
  options,
  placeholder = "Select options",
  description,
}: MultiSelectFieldProps) {
  return (
    <FormField
      control={form.control}
      name={name}
      render={({ field }) => (
        <FormItem>
          <FormLabel>{label}</FormLabel>
          <MultiSelect
            selected={field.value || []}
            options={options}
            onChange={field.onChange}
            placeholder={placeholder}
          />
          {description && (
            <p className="text-sm text-muted-foreground">{description}</p>
          )}
          <FormMessage />
        </FormItem>
      )}
    />
  );
}
```

### `src\components\forms\shared\select-field.tsx`

```tsx
"use client";

import {
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { UseFormReturn } from "react-hook-form";

interface Option {
  value: string;
  label: string;
}

interface SelectFieldProps {
  form: UseFormReturn<any>;
  name: string;
  label: string;
  options: Option[];
  placeholder?: string;
  defaultValue?: string;
  description?: string;
}

export function SelectField({
  form,
  name,
  label,
  options,
  placeholder = "Select an option",
  defaultValue,
  description,
}: SelectFieldProps) {
  return (
    <FormField
      control={form.control}
      name={name}
      render={({ field }) => (
        <FormItem>
          <FormLabel>{label}</FormLabel>
          <Select
            onValueChange={field.onChange}
            defaultValue={defaultValue || field.value}
          >
            <FormControl>
              <SelectTrigger>
                <SelectValue placeholder={placeholder} />
              </SelectTrigger>
            </FormControl>
            <SelectContent>
              {options.map((option) => (
                <SelectItem key={option.value} value={option.value}>
                  {option.label}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
          {description && (
            <p className="text-sm text-muted-foreground">{description}</p>
          )}
          <FormMessage />
        </FormItem>
      )}
    />
  );
}
```

### `src\components\layout\auth-layout.tsx`

```tsx
"use client";

import { useContext } from "react";
import { AuthContext } from "../providers/auth-provider";
import { usePathname } from "next/navigation";
import { Sidebar } from "./sidebar";
import { MainContentWrapper } from "./main-content-wrapper";
import { isAuthenticated, hasRole, type UserRole } from "@/types/auth";
import { LoadingSpinner } from "@/components/ui/loading-spinner";

interface AuthLayoutProps {
  children: React.ReactNode;
  requireAuth?: boolean;
  allowedRoles?: UserRole[];
  publicRoutes?: string[];
}

export function AuthLayout({
  children,
  requireAuth = true,
  allowedRoles,
  publicRoutes = ["/", "/login", "/auth/callback"],
}: AuthLayoutProps) {
  const { session, loading } = useContext(AuthContext);
  const pathname = usePathname();
  const isPublicRoute = pathname ? publicRoutes.includes(pathname) : false;

  // Show loading state with spinner
  if (loading) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <LoadingSpinner size="lg" />
      </div>
    );
  }

  // Allow public routes without authentication
  if (isPublicRoute) {
    return <>{children}</>;
  }

  // Check authentication and role requirements for protected routes
  if (requireAuth) {
    if (!isAuthenticated(session)) {
      return (
        <div className="flex items-center justify-center min-h-screen">
          <div className="text-center">
            <h2 className="text-2xl font-semibold mb-2">Access Denied</h2>
            <p>Please log in to access this page.</p>
          </div>
        </div>
      );
    }

    // Check role-based access if roles are specified
    if (allowedRoles && allowedRoles.length > 0) {
      const hasAllowedRole = allowedRoles.some(
        (role) => session.user && hasRole(session.user, role),
      );

      if (!hasAllowedRole) {
        return (
          <div className="flex items-center justify-center min-h-screen">
            <div className="text-center">
              <h2 className="text-2xl font-semibold mb-2">Access Restricted</h2>
              <p>You do not have permission to access this page.</p>
            </div>
          </div>
        );
      }
    }
  }

  return (
    <div className="relative flex min-h-screen" suppressHydrationWarning>
      <Sidebar />
      <MainContentWrapper>{children}</MainContentWrapper>
    </div>
  );
}
```

### `src\components\layout\main-content-wrapper.tsx`

```tsx
"use client";

import { cn } from "@/lib/utils";

interface MainContentWrapperProps {
  children: React.ReactNode;
  className?: string;
}

export function MainContentWrapper({
  children,
  className,
}: MainContentWrapperProps) {
  return (
    <div
      className={cn(
        "flex-1 overflow-auto p-4",
        "ml-16", // Account for sidebar width
        "transition-all duration-300 ease-in-out",
        className,
      )}
    >
      {children}
    </div>
  );
}
```

### `src\components\layout\main-content.tsx`

```tsx
"use client";

import { cn } from "@/lib/utils";
import { useSidebar } from "@/components/providers/sidebar-provider";

export function MainContent({ children }: { children: React.ReactNode }) {
  const { isCollapsed } = useSidebar();

  return (
    <main
      className={cn(
        "flex-1 p-8 transition-all duration-300 ease-in-out",
        isCollapsed ? "ml-16" : "ml-64",
      )}
    >
      {children}
    </main>
  );
}
```

### `src\components\layout\main-nav.tsx`

```tsx
"use client";

import Link from "next/link";
import { usePathname } from "next/navigation";
import { cn } from "@/lib/utils";
import { Users, LayoutGrid, Calendar, Settings, Layers } from "lucide-react";

const items = [
  {
    title: "Dashboard",
    href: "/dashboard",
    icon: LayoutGrid,
  },
  {
    title: "Clients",
    href: "/clients",
    icon: Users,
  },
  {
    title: "Tasks",
    href: "/tasks",
    icon: Layers,
  },
  {
    title: "Calendar",
    href: "/calendar",
    icon: Calendar,
  },
  {
    title: "Settings",
    href: "/settings",
    icon: Settings,
  },
];

export function MainNav() {
  const pathname = usePathname();

  return (
    <nav className="flex flex-col gap-2 p-4">
      {items.map((item) => {
        const Icon = item.icon;
        return (
          <Link
            key={item.href}
            href={item.href}
            className={cn(
              "flex items-center gap-3 rounded-lg px-3 py-2 text-sm font-medium hover:bg-accent transition-colors",
              pathname === item.href ? "bg-accent" : "transparent",
            )}
          >
            <Icon className="h-4 w-4" />
            {item.title}
          </Link>
        );
      })}
    </nav>
  );
}
```

### `src\components\layout\root-layout.tsx`

```tsx
"use client";

import { Sidebar } from "./sidebar";

interface RootLayoutProps {
  children: React.ReactNode;
}

export function RootLayout({ children }: RootLayoutProps) {
  return (
    <div className="relative flex min-h-screen">
      <Sidebar />
      <main className="flex-1 pl-64">
        <div className="container py-4">{children}</div>
      </main>
    </div>
  );
}
```

### `src\components\layout\sidebar.tsx`

```tsx
"use client";

import Link from "next/link";
import { usePathname } from "next/navigation";
import { cn } from "@/lib/utils";
import { Button } from "@/components/ui/button";
import {
  LayoutDashboard,
  Users,
  CheckSquare,
  FileText,
  Settings,
  FolderKanban,
  ChevronLeft,
  ChevronRight,
} from "lucide-react";
import { useSidebar } from "@/components/providers/sidebar-provider";
import { ThemeToggle } from "@/components/theme-toggle";

const sidebarNavItems = [
  {
    title: "Dashboard",
    href: "/dashboard",
    icon: LayoutDashboard,
  },
  {
    title: "Projects",
    href: "/projects",
    icon: FolderKanban,
  },
  {
    title: "Clients",
    href: "/clients",
    icon: Users,
  },
  {
    title: "Tasks",
    href: "/tasks",
    icon: CheckSquare,
  },
  {
    title: "Templates",
    href: "/templates",
    icon: FileText,
  },
  {
    title: "Settings",
    href: "/settings",
    icon: Settings,
  },
];

export function Sidebar() {
  const pathname = usePathname();
  const { isCollapsed, toggleCollapse } = useSidebar();

  return (
    <aside
      className={cn(
        "fixed left-0 top-0 z-40 h-full border-r bg-background transition-all duration-300 ease-in-out",
        isCollapsed ? "w-16" : "w-64",
      )}
      style={{ zIndex: 50 }}
    >
      {/* Collapse/Expand Button */}
      <button
        onClick={toggleCollapse}
        className="absolute -right-3 top-4 rounded-full border bg-background p-1 shadow-sm hover:bg-accent"
      >
        {isCollapsed ? (
          <ChevronRight className="h-4 w-4" />
        ) : (
          <ChevronLeft className="h-4 w-4" />
        )}
      </button>

      <div className="flex h-full flex-col">
        <div className="flex h-14 items-center border-b px-4">
          <Link href="/dashboard" className="flex items-center space-x-2">
            {!isCollapsed && (
              <span className="font-bold">American Dream Taxes Hub</span>
            )}
          </Link>
        </div>
        <div className="flex-1 overflow-auto py-2">
          <nav className="grid items-start px-2 py-2">
            {sidebarNavItems.map((item, index) => {
              const Icon = item.icon;
              return (
                <Link key={index} href={item.href} className="mb-1">
                  <Button
                    variant={pathname === item.href ? "secondary" : "ghost"}
                    className={cn(
                      "w-full justify-start gap-2",
                      pathname === item.href && "bg-muted",
                      isCollapsed && "justify-center",
                    )}
                  >
                    <Icon size={20} />
                    {!isCollapsed && item.title}
                  </Button>
                </Link>
              );
            })}
          </nav>
        </div>
        {/* Dark Mode Toggle at Bottom */}
        <div className="p-2">
          <ThemeToggle isCollapsed={isCollapsed} />
        </div>
      </div>
    </aside>
  );
}
```

### `src\components\project\project-view.tsx`

```tsx
"use client";

import { useState } from "react";
import { Button } from "@/components/ui/button";
import { Plus } from "lucide-react";
import { TaskDialog } from "@/components/tasks/task-dialog";
import { TaskList } from "@/components/tasks/task-list";
import { useTasks } from "@/hooks/useTasks";
import { toast } from "@/components/ui/use-toast";
import type { TaskFormData } from "@/types/tasks";

export function ProjectView({ projectId }: { projectId: string }) {
  const { tasks, isLoading, createTask, updateTask, deleteTask } = useTasks({
    projectId,
  });
  const [isDialogOpen, setIsDialogOpen] = useState(false);

  const handleAction = async (action: string, fn: () => Promise<unknown>) => {
    try {
      await fn();
      toast({
        title: "Success",
        description: `Task ${action} successfully.`,
      });
    } catch (error) {
      console.error(`Error ${action} task:`, error);
      toast({
        title: "Error",
        description: `Failed to ${action} task.`,
        variant: "destructive",
      });
    }
  };

  const handleCreateTask = async (data: TaskFormData) => {
    await handleAction("created", () => createTask(data));
    setIsDialogOpen(false);
  };

  const handleUpdateTask = async (taskId: string, data: TaskFormData) => {
    await handleAction("updated", () => updateTask(taskId, data));
  };

  const handleDeleteTask = async (taskId: string) => {
    await handleAction("deleted", () => deleteTask(taskId));
  };

  return (
    <div className="space-y-4">
      <div className="flex items-center justify-between">
        <h2 className="text-2xl font-bold">Project Tasks</h2>
        <Button onClick={() => setIsDialogOpen(true)}>
          <Plus className="mr-2 h-4 w-4" />
          New Task
        </Button>
      </div>

      <TaskList
        tasks={tasks}
        isLoading={isLoading}
        onUpdate={handleUpdateTask}
        onDelete={handleDeleteTask}
      />

      <TaskDialog
        open={isDialogOpen}
        onOpenChange={setIsDialogOpen}
        onSubmit={handleCreateTask}
      />
    </div>
  );
}
```

### `src\components\projects\create-project-dialog.tsx`

```tsx
"use client";

import { useState } from "react";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { projectSchema } from "@/lib/validations/project";
import { useToast } from "@/components/ui/use-toast";
import { ProjectFormData } from "@/types/projects";
import {
  Form,
  FormField,
  FormItem,
  FormLabel,
  FormControl,
  FormMessage,
} from "@/components/ui/form";

interface CreateProjectDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onSubmit: (data: ProjectFormData) => Promise<void>;
}

export function CreateProjectDialog({
  open,
  onOpenChange,
  onSubmit,
}: CreateProjectDialogProps) {
  const [isLoading, setIsLoading] = useState(false);
  const { toast } = useToast();

  const form = useForm<ProjectFormData>({
    resolver: zodResolver(projectSchema),
    defaultValues: {
      name: "",
      description: "",
      service_type: null,
      status: "not_started",
      template_tasks: [],
    },
  });

  const handleSubmit = async (data: ProjectFormData) => {
    try {
      setIsLoading(true);
      await onSubmit(data);
      form.reset();
      onOpenChange(false);
      toast({ title: "Success", description: "Project created successfully" });
    } catch (error) {
      console.error("Error creating project:", error);
      toast({
        title: "Error",
        description: "Failed to create project",
        variant: "destructive",
      });
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Create New Project</DialogTitle>
          <DialogDescription>
            Enter the details for your new project.
          </DialogDescription>
        </DialogHeader>

        <form onSubmit={form.handleSubmit(handleSubmit)} className="space-y-4">
          <FormField
            control={form.control}
            name="name"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Project Name</FormLabel>
                <FormControl>
                  <Input placeholder="Enter project name" {...field} />
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />

          <FormField
            control={form.control}
            name="description"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Description</FormLabel>
                <FormControl>
                  <Input placeholder="Enter project description" {...field} />
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />

          <FormField
            control={form.control}
            name="service_type"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Service Type</FormLabel>
                <Select onValueChange={field.onChange} value={field.value}>
                  <FormControl>
                    <SelectTrigger>
                      <SelectValue placeholder="Select service type" />
                    </SelectTrigger>
                  </FormControl>
                  <SelectContent>
                    <SelectItem value="tax_return">Tax Return</SelectItem>
                    <SelectItem value="bookkeeping">Bookkeeping</SelectItem>
                    <SelectItem value="payroll">Payroll</SelectItem>
                    <SelectItem value="advisory">Advisory</SelectItem>
                  </SelectContent>
                </Select>
                <FormMessage />
              </FormItem>
            )}
          />

          <div className="flex justify-end space-x-2">
            <Button
              type="button"
              variant="outline"
              onClick={() => onOpenChange(false)}
            >
              Cancel
            </Button>
            <Button type="submit" disabled={isLoading}>
              {isLoading ? "Creating..." : "Create Project"}
            </Button>
          </div>
        </form>
      </DialogContent>
    </Dialog>
  );
}
```

### `src\components\projects\new-project-button.tsx`

```tsx
"use client";

import { useState } from "react";
import { Button } from "@/components/ui/button";
import { PlusCircle } from "lucide-react";
import { CreateProjectDialog } from "./create-project-dialog";
import { useProjects } from "@/hooks/useProjects";
import { ProjectFormData } from "@/lib/validations/project";

export function NewProjectButton() {
  const [open, setOpen] = useState(false);
  const { fetchProjects, createProject } = useProjects();

  const handleSubmit = async (data: ProjectFormData) => {
    await createProject(data);
    await fetchProjects();
  };

  return (
    <>
      <Button
        onClick={() => setOpen(true)}
        className="bg-red-500 hover:bg-red-600 text-white"
      >
        <PlusCircle className="h-4 w-4 mr-2" />
        New Project
      </Button>

      <CreateProjectDialog
        open={open}
        onOpenChange={setOpen}
        onSubmit={handleSubmit}
      />
    </>
  );
}
```

### `src\components\projects\project-card.tsx`

```tsx
"use client";

import { useState } from "react";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardFooter,
  CardHeader,
} from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Skeleton } from "@/components/ui/skeleton";
import { formatDistanceToNow, isAfter, subDays } from "date-fns";
import { CreateProjectDialog } from "./create-project-dialog";
import {
  Building2,
  Clock,
  FileText,
  MoreHorizontal,
  Users2,
} from "lucide-react";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { cn } from "@/lib/utils";
import { useRouter } from "next/navigation";
import type { Database } from "@/types/database.types";
import { ProjectFormData } from "@/types/projects";
import { useToast } from "@/components/ui/use-toast";

type DbProject = Database["public"]["Views"]["project_dashboard"]["Row"];

interface ProjectCardProps {
  project: DbProject;
  onDelete?: (id: string) => void;
}

export function ProjectCard({ project, onDelete }: ProjectCardProps) {
  const router = useRouter();
  const [isDialogOpen, setIsDialogOpen] = useState(false);
  const { toast } = useToast();
  const supabase = createClientComponentClient<Database>();

  const isOverdue = project.due_date
    ? isAfter(new Date(), new Date(project.due_date))
    : false;
  const isDueSoon = project.due_date
    ? isAfter(new Date(project.due_date), new Date()) &&
      isAfter(new Date(project.due_date), subDays(new Date(), 7))
    : false;

  const handleUpdateProject = async (data: ProjectFormData) => {
    try {
      const { error } = await supabase
        .from("projects")
        .update({
          name: data.name,
          service_type: data.service_type,
          status: data.status,
        })
        .eq("id", project.id);

      if (error) throw error;
      router.refresh();
    } catch (error) {
      console.error("Error updating project:", error);
      toast({
        title: "Error",
        description: "Failed to update project",
        variant: "destructive",
      });
    }
  };

  return (
    <Card className="relative">
      <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
        <div className="space-y-1">
          <h3 className="font-semibold leading-none">{project.name}</h3>
          <p className="text-sm text-muted-foreground">
            {project.service_type?.replace("_", " ") || "No service type"}
          </p>
        </div>
        <DropdownMenu>
          <DropdownMenuTrigger asChild>
            <Button variant="ghost" className="h-8 w-8 p-0">
              <span className="sr-only">Open menu</span>
              <MoreHorizontal className="h-4 w-4" />
            </Button>
          </DropdownMenuTrigger>
          <DropdownMenuContent align="end">
            <DropdownMenuItem onClick={() => setIsDialogOpen(true)}>
              Edit
            </DropdownMenuItem>
            {onDelete && (
              <DropdownMenuItem
                className="text-red-600"
                onClick={() => onDelete(project.id)}
              >
                Delete
              </DropdownMenuItem>
            )}
          </DropdownMenuContent>
        </DropdownMenu>
      </CardHeader>
      <CardContent>
        <div className="grid gap-2">
          <div className="flex items-center gap-2">
            <Building2 className="h-4 w-4 text-muted-foreground" />
            <span className="text-sm">
              {project.client_name || "No client assigned"}
            </span>
          </div>
          <div className="flex items-center gap-2">
            <FileText className="h-4 w-4 text-muted-foreground" />
            <span className="text-sm capitalize">
              {project.service_type?.replace("_", " ") || "No service type"}
            </span>
          </div>
          <div className="flex items-center gap-2">
            <Users2 className="h-4 w-4 text-muted-foreground" />
            <span className="text-sm">
              {project.assigned_team_members || "No team members"}
            </span>
          </div>
          <div className="flex items-center gap-2">
            <Clock className="h-4 w-4 text-muted-foreground" />
            <span className="text-sm">
              {project.due_date
                ? formatDistanceToNow(new Date(project.due_date), {
                    addSuffix: true,
                  })
                : "No due date"}
            </span>
          </div>
        </div>
      </CardContent>
      <CardFooter className="flex items-center justify-between pt-2">
        <Badge
          variant="outline"
          className={cn(
            "capitalize",
            project.status === "completed" && "border-green-500 text-green-500",
            project.status === "in_progress" && "border-blue-500 text-blue-500",
            project.status === "blocked" && "border-red-500 text-red-500",
          )}
        >
          {project.status?.replace("_", " ")}
        </Badge>
        {(isOverdue || isDueSoon) && (
          <Badge
            variant="outline"
            className={cn(
              isOverdue && "border-red-500 text-red-500",
              isDueSoon && "border-yellow-500 text-yellow-500",
            )}
          >
            {isOverdue ? "Overdue" : "Due Soon"}
          </Badge>
        )}
      </CardFooter>

      <CreateProjectDialog
        open={isDialogOpen}
        onOpenChange={setIsDialogOpen}
        onSubmit={handleUpdateProject}
      />
    </Card>
  );
}

ProjectCard.Skeleton = function ProjectCardSkeleton() {
  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
        <div className="space-y-1">
          <Skeleton className="h-5 w-[200px]" />
          <Skeleton className="h-4 w-[150px]" />
        </div>
      </CardHeader>
      <CardContent>
        <div className="grid gap-2">
          <Skeleton className="h-4 w-[250px]" />
          <Skeleton className="h-4 w-[200px]" />
          <Skeleton className="h-4 w-[150px]" />
        </div>
      </CardContent>
      <CardFooter className="pt-2">
        <Skeleton className="h-5 w-[100px]" />
      </CardFooter>
    </Card>
  );
};
```

### `src\components\projects\project-details.tsx`

```tsx
"use client";

import type { Database } from "@/types/database.types";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { format } from "date-fns";
import { Calendar, Clock, Mail, Phone, Building, FileText } from "lucide-react";
import Link from "next/link";

type DbProject = Database["public"]["Views"]["project_dashboard"]["Row"];

interface ProjectDetailsProps {
  project: DbProject;
}

export function ProjectDetails({ project }: ProjectDetailsProps) {
  if (!project) return <div>No project data available</div>;

  return (
    <div className="grid gap-6 md:grid-cols-2">
      {/* Client Information */}
      <Card>
        <CardHeader>
          <CardTitle>Client Information</CardTitle>
          <CardDescription>
            Details about the client associated with this project
          </CardDescription>
        </CardHeader>
        <CardContent>
          {project.client_name ? (
            <div className="space-y-4">
              <div className="flex items-center gap-4">
                <Avatar className="h-10 w-10">
                  <AvatarFallback>
                    {project.client_name.charAt(0)}
                  </AvatarFallback>
                </Avatar>
                <div>
                  <div className="font-medium">{project.client_name}</div>
                  {project.company_name && (
                    <div className="text-sm text-muted-foreground">
                      {project.company_name}
                    </div>
                  )}
                </div>
              </div>

              <div className="pt-4">
                <Button variant="outline" size="sm" asChild>
                  <Link href={`/clients/${project.id}`}>
                    View Client Profile
                  </Link>
                </Button>
              </div>
            </div>
          ) : (
            <div className="text-center py-6 text-muted-foreground">
              No client associated with this project
            </div>
          )}
        </CardContent>
      </Card>

      {/* Project Details */}
      <Card>
        <CardHeader>
          <CardTitle>Project Details</CardTitle>
          <CardDescription>
            Important dates and project information
          </CardDescription>
        </CardHeader>
        <CardContent>
          <div className="space-y-4">
            <div className="grid gap-2">
              <div className="flex items-center gap-2 text-sm">
                <Clock className="h-4 w-4" />
                <span>
                  Due:{" "}
                  {project.due_date
                    ? format(new Date(project.due_date), "MMMM d, yyyy")
                    : "No due date"}
                </span>
              </div>
              <div className="flex items-center gap-2 text-sm">
                <FileText className="h-4 w-4" />
                <span>
                  Service Type:{" "}
                  {project.service_type?.replace("_", " ") || "Not specified"}
                </span>
              </div>
            </div>
          </div>
        </CardContent>
      </Card>

      {/* Task Progress */}
      <Card>
        <CardHeader>
          <CardTitle>Task Progress</CardTitle>
          <CardDescription>Overview of task completion</CardDescription>
        </CardHeader>
        <CardContent>
          <div className="space-y-4">
            <div className="grid grid-cols-2 gap-4">
              <div>
                <div className="text-2xl font-bold">
                  {Math.round(project.completion_percentage || 0)}%
                </div>
                <div className="text-sm text-muted-foreground">
                  Overall Progress
                </div>
              </div>
              <div>
                <div className="text-2xl font-bold">
                  {project.total_tasks || 0}
                </div>
                <div className="text-sm text-muted-foreground">Total Tasks</div>
              </div>
            </div>

            <div className="space-y-2">
              <div className="text-sm font-medium">Task Status</div>
              <div className="grid grid-cols-2 gap-2 text-sm">
                <div className="flex justify-between">
                  <span>Completed</span>
                  <span>{project.completed_tasks || 0}</span>
                </div>
              </div>
            </div>
          </div>
        </CardContent>
      </Card>

      {/* Team Members */}
      <Card>
        <CardHeader>
          <CardTitle>Team Members</CardTitle>
          <CardDescription>People working on this project</CardDescription>
        </CardHeader>
        <CardContent>
          <div className="flex items-center gap-2">
            {project.assigned_team_members ? (
              <span className="text-sm">{project.assigned_team_members}</span>
            ) : (
              <span className="text-sm text-muted-foreground">
                No team members assigned
              </span>
            )}
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
```

### `src\components\projects\project-filters-wrapper.tsx`

```tsx
"use client";

import { useState } from "react";
import { ProjectFilters as ProjectFiltersComponent } from "@/components/projects/project-filters";
import { ProjectFilters } from "@/hooks/useProjectFilters";

interface ProjectFiltersWrapperProps {
  clientOptions: Array<{ id: string; label: string }>;
}

export function ProjectFiltersWrapper({
  clientOptions,
}: ProjectFiltersWrapperProps) {
  const [filters, setFilters] = useState<ProjectFilters>({
    search: "",
    status: [],
    priority: [],
    service_category: [],
    clientId: "all",
    dateRange: undefined,
    sortBy: "due_date",
    sortOrder: "asc",
    groupBy: "status",
  });

  return (
    <ProjectFiltersComponent
      filters={filters}
      onChange={setFilters}
      clientOptions={clientOptions}
    />
  );
}
```

### `src\components\projects\project-filters.tsx`

```tsx
"use client";

import { useState } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Calendar } from "@/components/ui/calendar";
import type { Priority, ServiceCategory, ProjectStatus } from "@/types/hooks";
import {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import type { DateRange } from "react-day-picker";
import { format } from "date-fns";
import { cn } from "@/lib/utils";
import { CalendarIcon, Search, X, ArrowUpDown } from "lucide-react";
import type { ProjectFilters as ProjectFiltersType } from "@/hooks/useProjectFilters";
import { defaultFilters } from "@/hooks/useProjectFilters";
import { Badge } from "@/components/ui/badge";
import { ClientCombobox } from "@/components/clients/client-combobox";

interface ProjectFiltersProps {
  filters: ProjectFiltersType;
  onChange: (filters: ProjectFiltersType) => void;
  clientOptions?: Array<{ id: string; label: string }>;
}

export function ProjectFilters({
  filters,
  onChange,
  clientOptions = [],
}: ProjectFiltersProps) {
  const [date, setDate] = useState<DateRange | undefined>(filters.dateRange);

  const handleDateSelect = (range: DateRange | undefined) => {
    setDate(range);
    onChange({
      ...filters,
      dateRange: range,
    });
  };

  const clearFilters = () => {
    setDate(undefined);
    onChange(defaultFilters);
  };

  const hasActiveFilters =
    filters.search !== "" ||
    filters.status.length > 0 ||
    filters.priority.length > 0 ||
    filters.service_category.length > 0 ||
    filters.clientId !== "all" ||
    filters.dateRange !== undefined;

  const toggleSortOrder = () => {
    onChange({
      ...filters,
      sortOrder: filters.sortOrder === "asc" ? "desc" : "asc",
    });
  };

  return (
    <div className="space-y-4">
      <div className="flex flex-wrap gap-4 items-start">
        {/* Search Bar */}
        <div className="relative flex-1 min-w-[250px]">
          <Search className="absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-muted-foreground" />
          <Input
            placeholder="Search projects, clients..."
            value={filters.search}
            onChange={(e) => onChange({ ...filters, search: e.target.value })}
            className="pl-9"
          />
          {filters.search && (
            <Button
              variant="ghost"
              size="sm"
              className="absolute right-1 top-1/2 h-7 w-7 -translate-y-1/2 p-0"
              onClick={() => onChange({ ...filters, search: "" })}
            >
              <X className="h-4 w-4" />
            </Button>
          )}
        </div>

        {/* Main Filters Row */}
        <div className="flex flex-wrap gap-2 items-center">
          {/* Status Filter */}
          <Select
            value={filters.status.length > 0 ? filters.status[0] : "all"}
            onValueChange={(value) =>
              onChange({
                ...filters,
                status: value === "all" ? [] : [value as ProjectStatus],
              })
            }
          >
            <SelectTrigger className="w-[130px]">
              <SelectValue placeholder="Status" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="all">All Status</SelectItem>
              <SelectItem value="todo">To Do</SelectItem>
              <SelectItem value="in_progress">In Progress</SelectItem>
              <SelectItem value="completed">Completed</SelectItem>
              <SelectItem value="on_hold">On Hold</SelectItem>
              <SelectItem value="blocked">Blocked</SelectItem>
              <SelectItem value="review">Review</SelectItem>
              <SelectItem value="not_started">Not Started</SelectItem>
              <SelectItem value="cancelled">Cancelled</SelectItem>
              <SelectItem value="archived">Archived</SelectItem>
            </SelectContent>
          </Select>

          {/* Priority Filter */}
          <Select
            value={filters.priority.length > 0 ? filters.priority[0] : "all"}
            onValueChange={(value) =>
              onChange({
                ...filters,
                priority: value === "all" ? [] : [value as Priority],
              })
            }
          >
            <SelectTrigger className="w-[130px]">
              <SelectValue placeholder="Priority" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="all">All Priority</SelectItem>
              <SelectItem value="low">Low</SelectItem>
              <SelectItem value="medium">Medium</SelectItem>
              <SelectItem value="high">High</SelectItem>
              <SelectItem value="urgent">Urgent</SelectItem>
            </SelectContent>
          </Select>

          {/* Stage Filter */}
          <Select
            value={
              filters.service_category.length > 0
                ? filters.service_category[0]
                : "all"
            }
            onValueChange={(value) =>
              onChange({
                ...filters,
                service_category:
                  value === "all" ? [] : [value as ServiceCategory],
              })
            }
          >
            <SelectTrigger className="w-[130px]">
              <SelectValue placeholder="Stage" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="all">All Stages</SelectItem>
              <SelectItem value="tax_returns">Tax Returns</SelectItem>
              <SelectItem value="payroll">Payroll</SelectItem>
              <SelectItem value="accounting">Accounting</SelectItem>
              <SelectItem value="tax_planning">Tax Planning</SelectItem>
              <SelectItem value="compliance">Compliance</SelectItem>
              <SelectItem value="uncategorized">Uncategorized</SelectItem>
            </SelectContent>
          </Select>

          {/* Client Filter */}
          {clientOptions.length > 0 && (
            <div className="w-[180px]">
              <ClientCombobox
                value={filters.clientId === "all" ? null : filters.clientId}
                onChange={(value) =>
                  onChange({ ...filters, clientId: value || "all" })
                }
              />
            </div>
          )}
        </div>
      </div>

      {/* Secondary Row - Date and Sort */}
      <div className="flex flex-wrap gap-4 items-center justify-between">
        <div className="flex gap-2 items-center">
          {/* Date Range Picker */}
          <Popover>
            <PopoverTrigger asChild>
              <Button
                id="date"
                variant="outline"
                className={cn(
                  "w-[240px] justify-start text-left font-normal",
                  !date && "text-muted-foreground",
                )}
              >
                <CalendarIcon className="mr-2 h-4 w-4" />
                {date?.from ? (
                  date.to ? (
                    <>
                      {format(date.from, "LLL dd, y")} -{" "}
                      {format(date.to, "LLL dd, y")}
                    </>
                  ) : (
                    format(date.from, "LLL dd, y")
                  )
                ) : (
                  <span>Pick a date range</span>
                )}
              </Button>
            </PopoverTrigger>
            <PopoverContent className="w-auto p-0" align="start">
              <Calendar
                initialFocus
                mode="range"
                defaultMonth={date?.from}
                selected={date}
                onSelect={handleDateSelect}
                numberOfMonths={2}
              />
            </PopoverContent>
          </Popover>

          {/* Sort Options */}
          <Select
            value={filters.sortBy}
            onValueChange={(value) => onChange({ ...filters, sortBy: value })}
          >
            <SelectTrigger className="w-[160px]">
              <SelectValue placeholder="Sort by" />
            </SelectTrigger>
            <SelectContent>
              <SelectGroup>
                <SelectLabel>Time</SelectLabel>
                <SelectItem value="created">Created Date</SelectItem>
                <SelectItem value="due">Due Date</SelectItem>
              </SelectGroup>
              <SelectGroup>
                <SelectLabel>Properties</SelectLabel>
                <SelectItem value="name">Name</SelectItem>
                <SelectItem value="status">Status</SelectItem>
                <SelectItem value="priority">Priority</SelectItem>
                <SelectItem value="estimatedHours">Estimated Hours</SelectItem>
                <SelectItem value="completedTasks">Completion</SelectItem>
              </SelectGroup>
            </SelectContent>
          </Select>

          {/* Sort Direction Toggle */}
          <Button
            variant="outline"
            size="icon"
            onClick={toggleSortOrder}
            className={cn(
              "h-10 w-10",
              filters.sortOrder === "desc" && "bg-muted",
            )}
          >
            <ArrowUpDown className="h-4 w-4" />
          </Button>
        </div>

        {/* Clear Filters */}
        {hasActiveFilters && (
          <Button variant="ghost" onClick={clearFilters} className="gap-2">
            <X className="h-4 w-4" />
            Clear filters
          </Button>
        )}
      </div>
    </div>
  );
}
```

### `src\components\projects\project-form.tsx`

```tsx
"use client";

import { useState } from "react";
import { ProjectFormProvider } from "./form/ProjectFormContext";
import { ProjectFormTabs } from "./form/ProjectFormTabs";
import { useProjectForm } from "@/hooks/useProjectForm";
import { ProjectFormValues } from "@/lib/validations/project";
import { ProjectWithRelations } from "@/types/projects";
import { Database } from "@/types/database.types";

type Project = Database["public"]["Tables"]["projects"]["Row"];
type TaskPriority = Database["public"]["Enums"]["task_priority"];
type ServiceType = Database["public"]["Enums"]["service_type"];

interface ProjectFormProps {
  project?: ProjectWithRelations;
  onSuccess?: () => void;
}

export function ProjectForm({ project, onSuccess }: ProjectFormProps) {
  const [activeTab, setActiveTab] = useState("basic-info");
  const {
    form,
    isSubmitting,
    progress,
    onServiceTypeChange,
    onTemplateSelect,
    onSubmit,
    calculateProgress,
  } = useProjectForm({
    defaultValues: project
      ? {
          name: project.name,
          description: project.description,
          client_id: project.client_id,
          service_type: project.service_type as ServiceType | null,
          status: project.status,
          priority: project.priority as TaskPriority | undefined,
          due_date: project.due_date,
          start_date: project.start_date,
          end_date: project.end_date,
          tax_info: project.tax_info || null,
          accounting_info: project.accounting_info || null,
          payroll_info: project.payroll_info || null,
          service_info: project.service_info || null,
          template_id: project.template_id,
          tax_return_id: project.tax_return_id,
          parent_project_id: project.parent_project_id,
          primary_manager: project.primary_manager,
          stage: project.stage,
          completed_tasks: project.completed_tasks,
          completion_percentage: project.completion_percentage,
          task_count: project.task_count,
        }
      : undefined,
    onSubmit: async (data: ProjectFormValues) => {
      await onSuccess?.();
    },
  });

  return (
    <ProjectFormProvider
      form={form}
      isSubmitting={isSubmitting}
      progress={progress}
      onServiceTypeChange={onServiceTypeChange}
      onTemplateSelect={onTemplateSelect}
    >
      <ProjectFormTabs
        activeTab={activeTab}
        onTabChange={setActiveTab}
        getTabProgress={() => progress}
      />
    </ProjectFormProvider>
  );
}
```

### `src\components\projects\project-group.tsx`

```tsx
"use client";

import { useState } from "react";
import { ChevronRight, ChevronDown } from "lucide-react";
import { Button } from "@/components/ui/button";
import { cn } from "@/lib/utils";

interface ProjectGroupProps {
  title: string;
  count: number;
  children: React.ReactNode;
  defaultExpanded?: boolean;
}

export function ProjectGroup({
  title,
  count,
  children,
  defaultExpanded = true,
}: ProjectGroupProps) {
  // Initialize state with defaultExpanded prop
  const [isExpanded, setIsExpanded] = useState<boolean>(defaultExpanded);

  return (
    <div className="space-y-4">
      <div className="flex items-center gap-2">
        <Button
          variant="ghost"
          size="sm"
          className="p-0 h-6 w-6 hover:bg-secondary/80"
          onClick={() => setIsExpanded(!isExpanded)}
        >
          {isExpanded ? (
            <ChevronDown className="h-4 w-4" />
          ) : (
            <ChevronRight className="h-4 w-4" />
          )}
          <span className="sr-only">
            {isExpanded ? "Collapse" : "Expand"} {title}
          </span>
        </Button>
        <div className="flex items-center gap-2">
          <h2 className="text-lg font-semibold">{title}</h2>
          <span className="text-sm text-muted-foreground">({count})</span>
        </div>
      </div>
      <div
        className={cn(
          "grid transition-all duration-200",
          isExpanded
            ? "grid-rows-[1fr] opacity-100"
            : "grid-rows-[0fr] opacity-0",
        )}
      >
        <div
          className={cn(
            "overflow-hidden",
            isExpanded ? "visible" : "invisible",
          )}
        >
          {children}
        </div>
      </div>
    </div>
  );
}
```

### `src\components\projects\project-header.tsx`

```tsx
"use client";

import { Database } from "@/types/database.types";
import { Button } from "@/components/ui/button";
import { Calendar, Clock, Mail } from "lucide-react";
import { format } from "date-fns";
import { Badge } from "@/components/ui/badge";
import Link from "next/link";
import { useState } from "react";
import { CreateProjectDialog } from "./create-project-dialog";
import { ProjectFormData } from "@/types/projects";

type DbProject = Database["public"]["Tables"]["projects"]["Row"];
type DbClient = Database["public"]["Tables"]["clients"]["Row"];

interface ProjectHeaderProps {
  project: DbProject & {
    client?: DbClient | null;
  };
}

export function ProjectHeader({ project }: ProjectHeaderProps) {
  const [editDialogOpen, setEditDialogOpen] = useState(false);

  return (
    <div className="space-y-4">
      <div className="flex items-start justify-between">
        <div>
          <div className="flex items-center gap-4">
            <h1 className="text-2xl font-bold">{project.name}</h1>
            <Badge
              variant={
                project.status === "completed"
                  ? "default"
                  : project.status === "in_progress"
                    ? "secondary"
                    : "outline"
              }
            >
              {project.status}
            </Badge>
          </div>
          {project.description && (
            <p className="mt-1 text-muted-foreground">{project.description}</p>
          )}
          <div className="mt-2 flex flex-wrap items-center gap-4 text-sm text-muted-foreground">
            {project.client && (
              <Link
                href={`/clients/${project.client.id}`}
                className="flex items-center gap-1 hover:text-foreground"
              >
                {project.client.company_name || project.client.full_name}
              </Link>
            )}
            {project.start_date && (
              <div className="flex items-center gap-1">
                <Calendar className="h-4 w-4" />
                <span>
                  Started {format(new Date(project.start_date), "MMM d, yyyy")}
                </span>
              </div>
            )}
            {project.due_date && (
              <div className="flex items-center gap-1">
                <Clock className="h-4 w-4" />
                <span>
                  Due {format(new Date(project.due_date), "MMM d, yyyy")}
                </span>
              </div>
            )}
          </div>
        </div>
        <div className="flex gap-2">
          {project.client?.contact_email && (
            <Button variant="outline" size="sm" asChild>
              <Link href={`mailto:${project.client.contact_email}`}>
                <Mail className="mr-2 h-4 w-4" />
                Email Client
              </Link>
            </Button>
          )}
          <Button size="sm" onClick={() => setEditDialogOpen(true)}>
            Edit Project
          </Button>
        </div>
      </div>

      <div className="flex items-center gap-4 border-t border-b py-4">
        <div>
          <div className="text-sm font-medium">Status</div>
          <Badge
            className="mt-1"
            variant={
              project.status === "completed"
                ? "default"
                : project.status === "in_progress"
                  ? "secondary"
                  : "outline"
            }
          >
            {project.status}
          </Badge>
        </div>
        <div>
          <div className="text-sm font-medium">Priority</div>
          <Badge
            className="mt-1"
            variant={
              project.priority === "high"
                ? "destructive"
                : project.priority === "medium"
                  ? "default"
                  : "secondary"
            }
          >
            {project.priority}
          </Badge>
        </div>
        <div>
          <div className="text-sm font-medium">Progress</div>
          <div className="mt-1 text-2xl font-bold">
            {Math.round(project.completion_percentage || 0)}%
          </div>
        </div>
      </div>

      <CreateProjectDialog
        open={editDialogOpen}
        onOpenChange={setEditDialogOpen}
        onSubmit={async (data: ProjectFormData) => {
          // Handle project update
          console.log("Update project:", data);
        }}
      />
    </div>
  );
}
```

### `src\components\projects\project-list.tsx`

```tsx
"use client";

import React from "react";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import { formatDistanceToNow } from "date-fns";
import { cn } from "@/lib/utils";
import type { Database } from "@/types/database.types";

interface ProjectListProps {
  clientId?: string;
}

export default function ProjectList({ clientId }: ProjectListProps) {
  const [projects, setProjects] = React.useState<any[]>([]);
  const [loading, setLoading] = React.useState(true);
  const supabase = createClientComponentClient<Database>();

  React.useEffect(() => {
    async function fetchProjects() {
      try {
        let query = supabase
          .from("projects")
          .select("*")
          .order("created_at", { ascending: false });

        if (clientId) {
          query = query.eq("client_id", clientId);
        }

        const { data } = await query;
        setProjects(data || []);
      } catch {
        console.error("Error fetching projects");
      } finally {
        setLoading(false);
      }
    }

    fetchProjects();
  }, [clientId, supabase]);

  if (loading) {
    return <div>Loading projects...</div>;
  }

  if (projects.length === 0) {
    return <div>No projects found</div>;
  }

  return (
    <div className="space-y-4">
      {projects.map((project) => (
        <div key={project.id} className="p-4 border rounded-lg">
          <h3 className="font-semibold">{project.name}</h3>
          {project.description && (
            <p className="text-sm text-muted-foreground">
              {project.description}
            </p>
          )}
          <div className="mt-2 flex items-center gap-4 text-sm">
            <span>
              <span className="font-medium">Status:</span> {project.status}
            </span>
            {project.created_at && (
              <span className="text-muted-foreground">
                Created {formatDistanceToNow(new Date(project.created_at))} ago
              </span>
            )}
          </div>
        </div>
      ))}
    </div>
  );
}
```

### `src\components\projects\project-tasks.tsx`

```tsx
"use client";

import { ProjectWithRelations } from "@/types/projects";
import { TaskDialog } from "@/components/tasks/task-dialog";
import { TaskList } from "@/components/tasks/task-list";
import { useTasks } from "@/hooks/useTasks";
import { Button } from "@/components/ui/button";
import { Plus } from "lucide-react";
import { useState } from "react";
import { Database } from "@/types/database.types";
import { TaskWithRelations } from "@/types/tasks";

type DbTaskInsert = Database["public"]["Tables"]["tasks"]["Insert"];

interface ProjectTasksProps {
  project: ProjectWithRelations;
}

export function ProjectTasks({ project }: ProjectTasksProps) {
  const [dialogOpen, setDialogOpen] = useState(false);
  const { tasks, isLoading, error, mutate } = useTasks(project.id);

  const handleCreateTask = async (data: DbTaskInsert) => {
    // Handle task creation
    console.log("Create task:", data);
    setDialogOpen(false);
  };

  const handleUpdateTask = async (task: DbTaskInsert, taskId: string) => {
    // Handle task update
    console.log("Update task:", task);
    await mutate();
  };

  return (
    <div className="space-y-4">
      <div className="flex items-center justify-between">
        <h2 className="text-lg font-semibold">Tasks</h2>
        <Button size="sm" onClick={() => setDialogOpen(true)}>
          <Plus className="mr-2 h-4 w-4" />
          Add Task
        </Button>
      </div>

      {error ? (
        <div className="text-red-500">Error loading tasks: {error.message}</div>
      ) : (
        <TaskList
          tasks={tasks}
          isLoading={isLoading}
          onUpdate={handleUpdateTask}
        />
      )}

      <TaskDialog
        open={dialogOpen}
        onOpenChange={setDialogOpen}
        onSubmit={handleCreateTask}
        initialData={{
          project_id: project.id,
          status: "todo",
          priority: "medium",
        }}
      />
    </div>
  );
}
```

### `src\components\projects\service-fields.tsx`

```tsx

```

### `src\components\projects\task-dialog.tsx`

```tsx

```

### `src\components\projects\form\BasicInfoSection.tsx`

```tsx
"use client";

import { Card, CardContent } from "@/components/ui/card";
import { FormField } from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { useProjectFormContext } from "./ProjectFormContext";
import { ClientSelect } from "@/components/clients/client-select";
import { PrioritySelect } from "@/components/shared/priority-select";
import { useClients } from "@/hooks/useClients";

export function BasicInfoSection() {
  const { form } = useProjectFormContext();
  const { data: clients = [] } = useClients();

  return (
    <Card>
      <CardContent className="space-y-4 pt-6">
        <FormField
          control={form.control}
          name="name"
          render={({ field }) => (
            <div className="space-y-2">
              <label htmlFor={field.name} className="text-sm font-medium">
                Project Name
              </label>
              <Input
                id={field.name}
                placeholder="Enter project name"
                {...field}
              />
            </div>
          )}
        />

        <FormField
          control={form.control}
          name="description"
          render={({ field }) => (
            <div className="space-y-2">
              <label htmlFor={field.name} className="text-sm font-medium">
                Description
              </label>
              <Textarea
                id={field.name}
                placeholder="Enter project description"
                {...field}
                value={field.value || ""}
              />
            </div>
          )}
        />

        <FormField
          control={form.control}
          name="client_id"
          render={({ field }) => (
            <div className="space-y-2">
              <label htmlFor="client" className="text-sm font-medium">
                Client
              </label>
              <ClientSelect
                value={field.value}
                onSelect={field.onChange}
                clients={clients}
              />
            </div>
          )}
        />

        <FormField
          control={form.control}
          name="priority"
          render={({ field }) => (
            <div className="space-y-2">
              <label htmlFor={field.name} className="text-sm font-medium">
                Priority
              </label>
              <PrioritySelect
                id={field.name}
                value={field.value}
                onChange={field.onChange}
              />
            </div>
          )}
        />
      </CardContent>
    </Card>
  );
}
```

### `src\components\projects\form\ProjectForm.tsx`

```tsx
"use client";

import { useEffect } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Button } from "@/components/ui/button";
import { Form } from "@/components/ui/form";
import { ProjectFormProvider } from "./ProjectFormContext";
import { BasicInfoSection } from "./BasicInfoSection";
import { TaskSection } from "./TaskSection";
import { projectSchema } from "@/lib/validations/project";
import type {
  ProjectFormData,
  ProjectWithRelations,
  ServiceType,
} from "@/types/projects";

interface ProjectFormProps {
  initialData?: Partial<ProjectWithRelations>;
  onSubmit: (data: ProjectFormData) => Promise<void>;
  isSubmitting?: boolean;
}

export function ProjectForm({
  initialData,
  onSubmit,
  isSubmitting = false,
}: ProjectFormProps) {
  const form = useForm<ProjectFormData>({
    resolver: zodResolver(projectSchema),
    defaultValues: {
      name: initialData?.name || "",
      description: initialData?.description || "",
      status: initialData?.status || "not_started",
      service_type: (initialData?.service_type as ServiceType) || "tax_return",
      priority: initialData?.priority || "medium",
      start_date: initialData?.start_date || null,
      due_date: initialData?.due_date || null,
      client_id: initialData?.client_id || null,
    },
  });

  const handleSubmit = async (data: ProjectFormData) => {
    try {
      await onSubmit(data);
      form.reset();
    } catch (error) {
      form.setError("root", {
        message:
          error instanceof Error ? error.message : "Failed to submit project",
      });
    }
  };

  return (
    <ProjectFormProvider form={form}>
      <Form {...form}>
        <form onSubmit={form.handleSubmit(handleSubmit)} className="space-y-8">
          <Tabs defaultValue="basic" className="w-full">
            <TabsList>
              <TabsTrigger value="basic">Basic Info</TabsTrigger>
              <TabsTrigger value="tasks">Tasks</TabsTrigger>
            </TabsList>
            <TabsContent value="basic">
              <BasicInfoSection />
            </TabsContent>
            <TabsContent value="tasks">
              <TaskSection projectId={initialData?.id ?? ""} />
            </TabsContent>
          </Tabs>

          {form.formState.errors.root && (
            <div className="text-sm font-medium text-destructive">
              {form.formState.errors.root.message}
            </div>
          )}

          <div className="flex justify-end space-x-2">
            <Button type="submit" disabled={isSubmitting}>
              {isSubmitting ? "Saving..." : "Save Project"}
            </Button>
          </div>
        </form>
      </Form>
    </ProjectFormProvider>
  );
}
```

### `src\components\projects\form\ProjectFormContext.tsx`

```tsx
"use client";

import { createContext, useContext } from "react";
import type { UseFormReturn } from "react-hook-form";
import type { ProjectFormData } from "@/types/projects";

interface ProjectFormContextType {
  form: UseFormReturn<ProjectFormData>;
}

const ProjectFormContext = createContext<ProjectFormContextType | undefined>(
  undefined,
);

export function ProjectFormProvider({
  children,
  form,
}: {
  children: React.ReactNode;
  form: UseFormReturn<ProjectFormData>;
}) {
  return (
    <ProjectFormContext.Provider value={{ form }}>
      {children}
    </ProjectFormContext.Provider>
  );
}

export function useProjectFormContext() {
  const context = useContext(ProjectFormContext);
  if (!context) {
    throw new Error(
      "useProjectFormContext must be used within a ProjectFormProvider",
    );
  }
  return context;
}
```

### `src\components\projects\form\ProjectFormHeader.tsx`

```tsx
"use client";

import { Loader2 } from "lucide-react";
import { Button } from "@/components/ui/button";

interface ProjectFormHeaderProps {
  isEditing: boolean;
  isSubmitting: boolean;
}

export function ProjectFormHeader({
  isEditing,
  isSubmitting,
}: ProjectFormHeaderProps) {
  return (
    <div className="flex justify-between items-center">
      <h2 className="text-2xl font-bold">
        {isEditing ? "Edit Project" : "Create New Project"}
      </h2>
      <Button type="submit" disabled={isSubmitting} className="w-[150px]">
        {isSubmitting && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
        {isEditing ? "Update Project" : "Create Project"}
      </Button>
    </div>
  );
}
```

### `src\components\projects\form\ProjectFormTabs.tsx`

```tsx
"use client";

import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Progress } from "@/components/ui/progress";
import { BasicInfoSection } from "./BasicInfoSection";
import { ServiceDetailsSection } from "./ServiceDetailsSection";
import { TaskSection } from "./TaskSection";
import { useProjectFormContext } from "./ProjectFormContext";
import type { Database } from "@/types/database.types";

type DbTaskInsert = Database["public"]["Tables"]["tasks"]["Insert"];

interface ProjectFormTabsProps {
  activeTab: string;
  onTabChange: (value: string) => void;
  getTabProgress: (tab: string) => number;
}

export function ProjectFormTabs({
  activeTab,
  onTabChange,
  getTabProgress,
}: ProjectFormTabsProps) {
  const { form } = useProjectFormContext();

  const handleAddTask = (task: DbTaskInsert) => {
    const tasks = form.getValues("template_tasks") || [];
    form.setValue("template_tasks", [...tasks, task]);
  };

  const handleEditTask = (task: DbTaskInsert, taskId: string) => {
    const tasks = form.getValues("template_tasks") || [];
    const updatedTasks = tasks.map((t) => (t.id === taskId ? task : t));
    form.setValue("template_tasks", updatedTasks);
  };

  const handleDeleteTask = (taskId: string) => {
    const tasks = form.getValues("template_tasks") || [];
    form.setValue(
      "template_tasks",
      tasks.filter((t) => t.id !== taskId),
    );
  };

  return (
    <Tabs value={activeTab} onValueChange={onTabChange} className="w-full">
      <TabsList>
        <TabsTrigger value="basic">Basic Info</TabsTrigger>
        <TabsTrigger value="service">Service Details</TabsTrigger>
        <TabsTrigger value="tasks">Tasks</TabsTrigger>
      </TabsList>

      <div className="mt-4">
        <Progress value={getTabProgress(activeTab)} className="w-full" />
      </div>

      <TabsContent value="basic" className="mt-4">
        <BasicInfoSection />
      </TabsContent>

      <TabsContent value="service" className="mt-4">
        <ServiceDetailsSection />
      </TabsContent>

      <TabsContent value="tasks" className="mt-4">
        <TaskSection
          onAddTask={handleAddTask}
          onEditTask={handleEditTask}
          onDeleteTask={handleDeleteTask}
        />
      </TabsContent>
    </Tabs>
  );
}
```

### `src\components\projects\form\ServiceDetailsSection.tsx`

```tsx
"use client";

import { Card, CardContent } from "@/components/ui/card";
import { useProjectFormContext } from "./ProjectFormContext";
import { TaxInfoFields } from "./service-fields/TaxInfoFields";
import { AccountingInfoFields } from "./service-fields/AccountingInfoFields";
import { PayrollInfoFields } from "./service-fields/PayrollInfoFields";
import { TaxInfo, AccountingInfo, PayrollInfo } from "@/types/projects";
import { ProjectFormValues } from "@/lib/validations/project";

export function ServiceDetailsSection() {
  const { form } = useProjectFormContext();
  const serviceType = form.watch("service_type");

  const renderServiceFields = () => {
    switch (serviceType) {
      case "tax_return":
        return (
          <Card>
            <CardContent className="p-6">
              <TaxInfoFields
                value={
                  (form.watch("tax_info") as ProjectFormValues["tax_info"]) ||
                  {}
                }
                onChange={(value) =>
                  form.setValue(
                    "tax_info",
                    value as ProjectFormValues["tax_info"],
                  )
                }
              />
            </CardContent>
          </Card>
        );
      case "bookkeeping":
        return (
          <Card>
            <CardContent className="p-6">
              <AccountingInfoFields
                value={
                  (form.watch(
                    "accounting_info",
                  ) as ProjectFormValues["accounting_info"]) || {}
                }
                onChange={(value) =>
                  form.setValue(
                    "accounting_info",
                    value as ProjectFormValues["accounting_info"],
                  )
                }
              />
            </CardContent>
          </Card>
        );
      case "payroll":
        return (
          <Card>
            <CardContent className="p-6">
              <PayrollInfoFields
                value={
                  (form.watch(
                    "payroll_info",
                  ) as ProjectFormValues["payroll_info"]) || {}
                }
                onChange={(value) =>
                  form.setValue(
                    "payroll_info",
                    value as ProjectFormValues["payroll_info"],
                  )
                }
              />
            </CardContent>
          </Card>
        );
      default:
        return null;
    }
  };

  return <div className="space-y-4">{renderServiceFields()}</div>;
}
```

### `src\components\projects\form\TaskSection.tsx`

```tsx
"use client";

import { useState } from "react";
import { Button } from "@/components/ui/button";
import { Plus } from "lucide-react";
import { TaskDialog } from "@/components/tasks/task-dialog";
import { TaskList } from "@/components/tasks/task-list";
import { useTasks } from "@/hooks/useTasks";
import { toast } from "@/components/ui/use-toast";
import type { TaskFormData, TaskWithRelations } from "@/types/tasks";

interface TaskSectionProps {
  projectId: string;
}

export function TaskSection({ projectId }: TaskSectionProps) {
  const [isDialogOpen, setIsDialogOpen] = useState(false);
  const { tasks, isLoading, createTask, updateTask, deleteTask } = useTasks({
    projectId,
  });

  const handleCreateTask = async (data: TaskFormData) => {
    try {
      await createTask(data);
      setIsDialogOpen(false);
      toast({
        title: "Success",
        description: "Task created successfully.",
      });
    } catch (error) {
      console.error("Error creating task:", error);
      toast({
        title: "Error",
        description: "Failed to create task.",
        variant: "destructive",
      });
    }
  };

  const handleUpdateTask = async (taskId: string, data: TaskFormData) => {
    try {
      await updateTask(taskId, data);
      toast({
        title: "Success",
        description: "Task updated successfully.",
      });
    } catch (error) {
      console.error("Error updating task:", error);
      toast({
        title: "Error",
        description: "Failed to update task.",
        variant: "destructive",
      });
    }
  };

  const handleDeleteTask = async (taskId: string) => {
    try {
      await deleteTask(taskId);
      toast({
        title: "Success",
        description: "Task deleted successfully.",
      });
    } catch (error) {
      console.error("Error deleting task:", error);
      toast({
        title: "Error",
        description: "Failed to delete task.",
        variant: "destructive",
      });
    }
  };

  return (
    <div className="space-y-4">
      <div className="flex items-center justify-between">
        <h3 className="text-lg font-medium">Tasks</h3>
        <Button onClick={() => setIsDialogOpen(true)}>
          <Plus className="mr-2 h-4 w-4" />
          Add Task
        </Button>
      </div>

      <TaskList
        tasks={tasks}
        isLoading={isLoading}
        onUpdate={handleUpdateTask}
        onDelete={handleDeleteTask}
      />

      <TaskDialog
        open={isDialogOpen}
        onOpenChange={setIsDialogOpen}
        onSubmit={handleCreateTask}
      />
    </div>
  );
}
```

### `src\components\projects\form\service-fields\AccountingInfoFields.tsx`

```tsx
"use client";

import { Label } from "@/components/ui/label";
import { Input } from "@/components/ui/input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { AccountingInfo } from "@/types/projects";

interface AccountingInfoFieldsProps {
  value: AccountingInfo;
  onChange: (value: AccountingInfo) => void;
}

export function AccountingInfoFields({
  value,
  onChange,
}: AccountingInfoFieldsProps) {
  const handleChange = (field: keyof AccountingInfo, newValue: string) => {
    onChange({
      ...value,
      [field]: newValue,
    });
  };

  return (
    <div className="space-y-4">
      <div className="grid grid-cols-2 gap-4">
        <div className="space-y-2">
          <Label>Period Start</Label>
          <Input
            type="date"
            value={value.period_start || ""}
            onChange={(e) => handleChange("period_start", e.target.value)}
          />
        </div>
        <div className="space-y-2">
          <Label>Period End</Label>
          <Input
            type="date"
            value={value.period_end || ""}
            onChange={(e) => handleChange("period_end", e.target.value)}
          />
        </div>
      </div>

      <div className="space-y-2">
        <Label>Accounting Method</Label>
        <Select
          value={value.accounting_method || ""}
          onValueChange={(newValue) =>
            handleChange("accounting_method", newValue)
          }
        >
          <SelectTrigger>
            <SelectValue placeholder="Select accounting method" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="cash">Cash</SelectItem>
            <SelectItem value="accrual">Accrual</SelectItem>
            <SelectItem value="hybrid">Hybrid</SelectItem>
          </SelectContent>
        </Select>
      </div>

      <div className="space-y-2">
        <Label>Fiscal Year End</Label>
        <Input
          type="date"
          value={value.fiscal_year_end || ""}
          onChange={(e) => handleChange("fiscal_year_end", e.target.value)}
        />
      </div>

      <div className="space-y-2">
        <Label>Last Reconciliation Date</Label>
        <Input
          type="date"
          value={value.last_reconciliation_date || ""}
          onChange={(e) =>
            handleChange("last_reconciliation_date", e.target.value)
          }
        />
      </div>

      <div className="space-y-2">
        <Label>Software Used</Label>
        <Input
          value={value.software_used || ""}
          onChange={(e) => handleChange("software_used", e.target.value)}
          placeholder="e.g., QuickBooks Online"
        />
      </div>

      <div className="space-y-2">
        <Label>Frequency</Label>
        <Select
          value={value.frequency || ""}
          onValueChange={(newValue) => handleChange("frequency", newValue)}
        >
          <SelectTrigger>
            <SelectValue placeholder="Select frequency" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="monthly">Monthly</SelectItem>
            <SelectItem value="quarterly">Quarterly</SelectItem>
            <SelectItem value="annually">Annually</SelectItem>
          </SelectContent>
        </Select>
      </div>

      <div className="space-y-2">
        <Label>Notes</Label>
        <Input
          value={value.notes || ""}
          onChange={(e) => handleChange("notes", e.target.value)}
          placeholder="Additional notes..."
        />
      </div>
    </div>
  );
}
```

### `src\components\projects\form\service-fields\PayrollInfoFields.tsx`

```tsx
"use client";

import { Label } from "@/components/ui/label";
import { Input } from "@/components/ui/input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { PayrollInfo } from "@/types/projects";

type PayrollSchedule = "weekly" | "bi-weekly" | "semi-monthly" | "monthly";

interface PayrollInfoFieldsProps {
  value: PayrollInfo;
  onChange: (value: PayrollInfo) => void;
}

export function PayrollInfoFields({ value, onChange }: PayrollInfoFieldsProps) {
  const handleChange = (
    field: keyof PayrollInfo,
    newValue: string | number,
  ) => {
    onChange({
      ...value,
      [field]: newValue,
    });
  };

  return (
    <div className="space-y-4">
      <div className="space-y-2">
        <Label>Payroll Schedule</Label>
        <Select
          value={value.payroll_schedule || ""}
          onValueChange={(newValue) =>
            handleChange("payroll_schedule", newValue)
          }
        >
          <SelectTrigger>
            <SelectValue placeholder="Select payroll schedule" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="weekly">Weekly</SelectItem>
            <SelectItem value="bi-weekly">Bi-Weekly</SelectItem>
            <SelectItem value="semi-monthly">Semi-Monthly</SelectItem>
            <SelectItem value="monthly">Monthly</SelectItem>
          </SelectContent>
        </Select>
      </div>

      <div className="space-y-2">
        <Label>Employee Count</Label>
        <Input
          type="number"
          value={value.employee_count || ""}
          onChange={(e) =>
            handleChange("employee_count", parseInt(e.target.value, 10))
          }
          placeholder="Number of employees"
        />
      </div>

      <div className="space-y-2">
        <Label>Last Payroll Date</Label>
        <Input
          type="date"
          value={value.last_payroll_date || ""}
          onChange={(e) => handleChange("last_payroll_date", e.target.value)}
        />
      </div>

      <div className="space-y-2">
        <Label>Next Payroll Date</Label>
        <Input
          type="date"
          value={value.next_payroll_date || ""}
          onChange={(e) => handleChange("next_payroll_date", e.target.value)}
        />
      </div>

      <div className="space-y-2">
        <Label>Payroll Provider</Label>
        <Input
          value={value.payroll_provider || ""}
          onChange={(e) => handleChange("payroll_provider", e.target.value)}
          placeholder="e.g., ADP, Paychex"
        />
      </div>

      <div className="space-y-2">
        <Label>Notes</Label>
        <Input
          value={value.notes || ""}
          onChange={(e) => handleChange("notes", e.target.value)}
          placeholder="Additional notes..."
        />
      </div>
    </div>
  );
}
```

### `src\components\projects\form\service-fields\TaxInfoFields.tsx`

```tsx
"use client";

import { Label } from "@/components/ui/label";
import { Input } from "@/components/ui/input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { TaxInfo } from "@/types/projects";

interface TaxInfoFieldsProps {
  value: TaxInfo;
  onChange: (value: TaxInfo) => void;
}

export function TaxInfoFields({ value, onChange }: TaxInfoFieldsProps) {
  const handleChange = (field: keyof TaxInfo, newValue: string | number) => {
    onChange({
      ...value,
      [field]: newValue,
    });
  };

  return (
    <div className="space-y-4">
      <div className="space-y-2">
        <Label>Return Type</Label>
        <Select
          value={value.return_type || ""}
          onValueChange={(newValue) => handleChange("return_type", newValue)}
        >
          <SelectTrigger>
            <SelectValue placeholder="Select return type" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="1040">1040 - Individual</SelectItem>
            <SelectItem value="1120">1120 - Corporation</SelectItem>
            <SelectItem value="1120s">1120S - S Corporation</SelectItem>
            <SelectItem value="1065">1065 - Partnership</SelectItem>
            <SelectItem value="990">990 - Non-Profit</SelectItem>
          </SelectContent>
        </Select>
      </div>

      <div className="space-y-2">
        <Label>Filing Status</Label>
        <Select
          value={value.filing_status || ""}
          onValueChange={(newValue) => handleChange("filing_status", newValue)}
        >
          <SelectTrigger>
            <SelectValue placeholder="Select filing status" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="single">Single</SelectItem>
            <SelectItem value="married_joint">
              Married Filing Jointly
            </SelectItem>
            <SelectItem value="married_separate">
              Married Filing Separately
            </SelectItem>
            <SelectItem value="head_household">Head of Household</SelectItem>
            <SelectItem value="qualifying_widow">
              Qualifying Widow(er)
            </SelectItem>
          </SelectContent>
        </Select>
      </div>

      <div className="space-y-2">
        <Label>Tax Year</Label>
        <Input
          type="number"
          value={value.tax_year || ""}
          onChange={(e) =>
            handleChange("tax_year", parseInt(e.target.value, 10))
          }
          placeholder="Enter tax year"
        />
      </div>

      <div className="space-y-2">
        <Label>Due Date</Label>
        <Input
          type="date"
          value={value.due_date || ""}
          onChange={(e) => handleChange("due_date", e.target.value)}
        />
      </div>

      <div className="space-y-2">
        <Label>Extension Date</Label>
        <Input
          type="date"
          value={value.extension_date || ""}
          onChange={(e) => handleChange("extension_date", e.target.value)}
        />
      </div>

      <div className="space-y-2">
        <Label>Estimated Refund</Label>
        <Input
          type="number"
          value={value.estimated_refund || ""}
          onChange={(e) =>
            handleChange("estimated_refund", parseFloat(e.target.value))
          }
          placeholder="Enter estimated refund amount"
        />
      </div>

      <div className="space-y-2">
        <Label>Estimated Liability</Label>
        <Input
          type="number"
          value={value.estimated_liability || ""}
          onChange={(e) =>
            handleChange("estimated_liability", parseFloat(e.target.value))
          }
          placeholder="Enter estimated liability amount"
        />
      </div>

      <div className="space-y-2">
        <Label>Notes</Label>
        <Input
          value={value.notes || ""}
          onChange={(e) => handleChange("notes", e.target.value)}
          placeholder="Additional notes..."
        />
      </div>
    </div>
  );
}
```

### `src\components\providers\sidebar-provider.tsx`

```tsx
"use client";

import { createContext, useContext, useState } from "react";

type SidebarContextType = {
  isCollapsed: boolean;
  toggleCollapse: () => void;
};

const SidebarContext = createContext<SidebarContextType | undefined>(undefined);

export function SidebarProvider({ children }: { children: React.ReactNode }) {
  const [isCollapsed, setIsCollapsed] = useState(false);

  const toggleCollapse = () => {
    setIsCollapsed((prev) => !prev);
  };

  return (
    <SidebarContext.Provider value={{ isCollapsed, toggleCollapse }}>
      {children}
    </SidebarContext.Provider>
  );
}

export function useSidebar() {
  const context = useContext(SidebarContext);
  if (!context) {
    throw new Error("useSidebar must be used within a SidebarProvider");
  }
  return context;
}
```

### `src\components\providers\supabase-provider.tsx`

```tsx
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import { useEffect, useState } from "react";

export const SupabaseProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const supabase = createClientComponentClient();

  useEffect(() => {
    const getUser = async () => {
      const {
        data: { user },
      } = await supabase.auth.getUser();
      setUser(user);
    };

    getUser();

    const {
      data: { subscription },
    } = supabase.auth.onAuthStateChange(async (event, session) => {
      if (session?.user) {
        const {
          data: { user },
        } = await supabase.auth.getUser();
        setUser(user);
      } else {
        setUser(null);
      }
    });

    return () => {
      subscription.unsubscribe();
    };
  }, []);

  return children;
};
```

### `src\components\shared\DataGrid.tsx`

```tsx
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";

interface Column {
  field: string;
  header: string;
  render?: (row: any) => React.ReactNode;
}

interface DataGridProps {
  data: any[];
  columns: Column[];
}

export function DataGrid({ data, columns }: DataGridProps) {
  return (
    <div className="rounded-md border">
      <Table>
        <TableHeader>
          <TableRow>
            {columns.map((column) => (
              <TableHead key={column.field}>{column.header}</TableHead>
            ))}
          </TableRow>
        </TableHeader>
        <TableBody>
          {data.map((row, rowIndex) => (
            <TableRow key={rowIndex}>
              {columns.map((column) => (
                <TableCell key={column.field}>
                  {column.render ? column.render(row) : row[column.field]}
                </TableCell>
              ))}
            </TableRow>
          ))}
        </TableBody>
      </Table>
    </div>
  );
}
```

### `src\components\shared\DropZone.tsx`

```tsx
"use client";

import { useRef, useState } from "react";

interface DropZoneProps {
  onDrop: (files: FileList) => void;
  children: React.ReactNode;
}

const ACCEPTED_TYPES = ["application/pdf", "image/jpeg", "image/png"];

export function DropZone({ onDrop, children }: DropZoneProps) {
  const [isDragging, setIsDragging] = useState(false);
  const inputRef = useRef<HTMLInputElement>(null);

  const validateFiles = (files: FileList): boolean => {
    return Array.from(files).every((file) =>
      ACCEPTED_TYPES.includes(file.type),
    );
  };

  const handleDragOver = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragging(true);
  };

  const handleDragLeave = () => {
    setIsDragging(false);
  };

  const handleDrop = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragging(false);
    if (e.dataTransfer.files && validateFiles(e.dataTransfer.files)) {
      onDrop(e.dataTransfer.files);
    }
  };

  const handleClick = () => {
    inputRef.current?.click();
  };

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (e.target.files && validateFiles(e.target.files)) {
      onDrop(e.target.files);
    }
  };

  return (
    <div
      onClick={handleClick}
      onDragOver={handleDragOver}
      onDragLeave={handleDragLeave}
      onDrop={handleDrop}
      className={`border-2 border-dashed rounded-lg p-4 cursor-pointer transition-colors ${
        isDragging
          ? "border-primary bg-primary/5"
          : "border-muted-foreground/25"
      }`}
    >
      <input
        ref={inputRef}
        type="file"
        className="hidden"
        onChange={handleChange}
        accept={ACCEPTED_TYPES.join(",")}
        multiple
      />
      {children}
    </div>
  );
}
```

### `src\components\shared\priority-select.tsx`

```tsx
"use client";

import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Database } from "@/types/database.types";

type TaskPriority = Database["public"]["Enums"]["task_priority"];

const PRIORITY_OPTIONS: { value: TaskPriority; label: string }[] = [
  { value: "low", label: "Low" },
  { value: "medium", label: "Medium" },
  { value: "high", label: "High" },
  { value: "urgent", label: "Urgent" },
];

interface PrioritySelectProps {
  id?: string;
  value: TaskPriority | null;
  onChange: (value: TaskPriority) => void;
}

export function PrioritySelect({ id, value, onChange }: PrioritySelectProps) {
  return (
    <Select value={value || undefined} onValueChange={onChange}>
      <SelectTrigger id={id}>
        <SelectValue placeholder="Select priority" />
      </SelectTrigger>
      <SelectContent>
        {PRIORITY_OPTIONS.map((option) => (
          <SelectItem key={option.value} value={option.value}>
            {option.label}
          </SelectItem>
        ))}
      </SelectContent>
    </Select>
  );
}
```

### `src\components\shared\service-type-select.tsx`

```tsx
"use client";

import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { ServiceType } from "@/types/projects";

interface ServiceTypeSelectProps {
  id?: string;
  value: ServiceType;
  onChange: (value: ServiceType) => void;
}

export function ServiceTypeSelect({
  id,
  value,
  onChange,
}: ServiceTypeSelectProps) {
  return (
    <Select value={value} onValueChange={onChange}>
      <SelectTrigger id={id}>
        <SelectValue placeholder="Select service type" />
      </SelectTrigger>
      <SelectContent>
        <SelectItem value="tax_return">Tax Return</SelectItem>
        <SelectItem value="bookkeeping">Bookkeeping</SelectItem>
        <SelectItem value="payroll">Payroll</SelectItem>
        <SelectItem value="advisory">Advisory</SelectItem>
      </SelectContent>
    </Select>
  );
}
```

### `src\components\tasks\progress-tracker.tsx`

```tsx
"use client";

import { useState } from "react";
import { Slider } from "@/components/ui/slider";
import { Progress } from "@/components/ui/progress";
import { Button } from "@/components/ui/button";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { Clock, Minus, Plus } from "lucide-react";

interface ProgressTrackerProps {
  progress: number;
  estimatedHours?: number;
  actualHours?: number;
  onProgressChange?: (value: number) => void;
  onActualHoursChange?: (hours: number) => void;
  showTimeTracking?: boolean;
  readOnly?: boolean;
}

export function ProgressTracker({
  progress,
  estimatedHours,
  actualHours,
  onProgressChange,
  onActualHoursChange,
  showTimeTracking = false,
  readOnly = false,
}: ProgressTrackerProps) {
  const [isTracking, setIsTracking] = useState(false);
  const [trackingStartTime, setTrackingStartTime] = useState<Date | null>(null);

  const handleTrackingToggle = () => {
    if (isTracking) {
      // Stop tracking
      if (trackingStartTime && onActualHoursChange) {
        const elapsedHours =
          (new Date().getTime() - trackingStartTime.getTime()) /
          (1000 * 60 * 60);
        onActualHoursChange((actualHours || 0) + elapsedHours);
      }
      setIsTracking(false);
      setTrackingStartTime(null);
    } else {
      // Start tracking
      setIsTracking(true);
      setTrackingStartTime(new Date());
    }
  };

  const adjustActualHours = (increment: boolean) => {
    if (!onActualHoursChange) return;
    const change = increment ? 0.5 : -0.5;
    const newHours = Math.max(0, (actualHours || 0) + change);
    onActualHoursChange(newHours);
  };

  return (
    <div className="space-y-2">
      <div className="flex items-center gap-4">
        <div className="flex-1">
          {readOnly ? (
            <Progress value={progress} className="h-2" />
          ) : (
            <Slider
              value={[progress]}
              onValueChange={([value]) => onProgressChange?.(value)}
              max={100}
              step={5}
              className="h-2"
            />
          )}
        </div>
        <div className="w-12 text-sm text-muted-foreground">{progress}%</div>
      </div>

      {showTimeTracking && (
        <div className="flex items-center gap-2 text-sm">
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger>
                <div className="flex items-center gap-1">
                  <Clock className="h-4 w-4 text-muted-foreground" />
                  <span>
                    {actualHours?.toFixed(1) || 0}/{estimatedHours || 0}h
                  </span>
                </div>
              </TooltipTrigger>
              <TooltipContent>
                <p>Actual / Estimated Hours</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>

          {!readOnly && (
            <div className="flex items-center gap-1">
              <Button
                variant="ghost"
                size="icon"
                className="h-6 w-6"
                onClick={() => adjustActualHours(false)}
              >
                <Minus className="h-4 w-4" />
              </Button>
              <Button
                variant="ghost"
                size="icon"
                className="h-6 w-6"
                onClick={() => adjustActualHours(true)}
              >
                <Plus className="h-4 w-4" />
              </Button>
              <Button
                variant={isTracking ? "destructive" : "secondary"}
                size="sm"
                onClick={handleTrackingToggle}
              >
                {isTracking ? "Stop" : "Start"} Timer
              </Button>
            </div>
          )}
        </div>
      )}
    </div>
  );
}
```

### `src\components\tasks\project-tasks.tsx`

```tsx
import { useState } from "react";
import { TaskDialog } from "./task-dialog";
import { TaskCard } from "./task-card";
import { TaskFormData, TaskWithRelations, toDbTaskInsert } from "@/types/tasks";

interface ProjectTasksProps {
  project: {
    id: string;
    name: string;
  };
  tasks: TaskWithRelations[];
  onTaskCreate: (task: TaskFormData) => Promise<void>;
  onTaskUpdate: (taskId: string, task: TaskFormData) => Promise<void>;
  onTaskDelete: (taskId: string) => Promise<void>;
}

export function ProjectTasks({
  project,
  tasks,
  onTaskCreate,
  onTaskUpdate,
  onTaskDelete,
}: ProjectTasksProps) {
  const [dialogOpen, setDialogOpen] = useState(false);
  const [editingTask, setEditingTask] = useState<TaskWithRelations | null>(
    null,
  );

  const handleCreateTask = async (data: TaskFormData) => {
    await onTaskCreate(data);
    setDialogOpen(false);
  };

  const handleEditTask = async (data: TaskFormData) => {
    if (editingTask) {
      await onTaskUpdate(editingTask.id, data);
      setEditingTask(null);
    }
  };

  return (
    <div className="space-y-4">
      <button onClick={() => setDialogOpen(true)}>Add Task</button>

      <div className="grid gap-4">
        {tasks.map((task) => (
          <TaskCard
            key={task.id}
            task={task}
            onEdit={(task) => setEditingTask(task)}
            onDelete={onTaskDelete}
          />
        ))}
      </div>

      <TaskDialog
        open={dialogOpen}
        onOpenChange={setDialogOpen}
        onSubmit={handleCreateTask}
        initialData={{
          project_id: project.id,
          status: "todo",
          priority: "medium",
        }}
      />

      {editingTask && (
        <TaskDialog
          open={!!editingTask}
          onOpenChange={() => setEditingTask(null)}
          onSubmit={handleEditTask}
          initialData={editingTask}
        />
      )}
    </div>
  );
}
```

### `src\components\tasks\task-card.tsx`

```tsx
"use client";

import { TaskWithRelations } from "@/types/tasks";

interface TaskCardProps {
  task: TaskWithRelations;
  onEdit: (task: TaskWithRelations) => void;
  onDelete: (taskId: string) => void;
}

export function TaskCard({ task, onEdit, onDelete }: TaskCardProps) {
  return (
    <div className="border rounded-lg p-4">
      <h3 className="font-medium">{task.title}</h3>
      {task.description && (
        <p className="text-sm text-gray-600">{task.description}</p>
      )}
      <div className="flex justify-between mt-4">
        <div className="flex items-center space-x-2">
          <span className="text-sm">{task.status}</span>
          {task.priority && (
            <span className="text-sm text-gray-500">{task.priority}</span>
          )}
        </div>
        <div className="flex items-center space-x-2">
          <button onClick={() => onEdit(task)}>Edit</button>
          <button onClick={() => onDelete(task.id)}>Delete</button>
        </div>
      </div>
    </div>
  );
}
```

### `src\components\tasks\task-container.tsx`

```tsx
"use client";

import { useState } from "react";
import { useTasks } from "@/hooks/useTasks";
import { TaskDialog } from "./task-dialog";
import { TaskItem } from "./task-item";
import { Button } from "@/components/ui/button";
import { Pagination } from "@/components/ui/pagination";
import { Spinner } from "@/components/ui/spinner";
import { ErrorBoundary } from "@/components/error-boundary";

interface TaskContainerProps {
  projectId?: string;
}

export function TaskContainer({ projectId }: TaskContainerProps) {
  const [isCreateDialogOpen, setIsCreateDialogOpen] = useState(false);
  const [currentPage, setCurrentPage] = useState(1);
  const [showDetails, setShowDetails] = useState(false);

  const {
    tasks,
    totalTasks,
    totalPages,
    isLoading,
    error,
    createTask,
    updateTask,
    deleteTask,
    isCreating,
    isUpdating,
    isDeleting,
    prefetchNextPage,
  } = useTasks({
    projectId,
    page: currentPage,
    includeRelations: showDetails,
  });

  if (error) {
    throw error;
  }

  const handlePageChange = (page: number) => {
    setCurrentPage(page);
  };

  const handleShowDetailsToggle = () => {
    setShowDetails(!showDetails);
  };

  return (
    <ErrorBoundary>
      <div className="space-y-4">
        <div className="flex justify-between items-center">
          <div className="flex gap-4">
            <Button onClick={() => setIsCreateDialogOpen(true)}>
              Create Task
            </Button>
            <Button variant="outline" onClick={handleShowDetailsToggle}>
              {showDetails ? "Hide Details" : "Show Details"}
            </Button>
          </div>
          {(isCreating || isUpdating || isDeleting) && (
            <div className="flex items-center gap-2">
              <Spinner size="sm" />
              <span className="text-sm text-muted-foreground">
                {isCreating && "Creating task..."}
                {isUpdating && "Updating task..."}
                {isDeleting && "Deleting task..."}
              </span>
            </div>
          )}
        </div>

        {isLoading ? (
          <div className="flex justify-center p-8">
            <Spinner size="lg" />
          </div>
        ) : tasks.length > 0 ? (
          <div className="space-y-4">
            <div className="grid gap-4">
              {tasks.map((task) => (
                <TaskItem
                  key={task.id}
                  task={task}
                  onUpdate={updateTask}
                  onDelete={deleteTask}
                  showDetails={showDetails}
                />
              ))}
            </div>
            {totalPages > 1 && (
              <Pagination
                currentPage={currentPage}
                totalPages={totalPages}
                onPageChange={handlePageChange}
                onNextPage={prefetchNextPage}
              />
            )}
          </div>
        ) : (
          <div className="text-center p-8 text-muted-foreground">
            No tasks found. Create one to get started.
          </div>
        )}

        <TaskDialog
          open={isCreateDialogOpen}
          onOpenChange={setIsCreateDialogOpen}
          onSubmit={createTask}
          projectId={projectId}
        />
      </div>
    </ErrorBoundary>
  );
}
```

### `src\components\tasks\task-dialog.tsx`

```tsx
"use client";

import { useState } from "react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import {
  TaskWithRelations,
  TaskFormData,
  taskSchema,
  TASK_STATUS,
  TASK_PRIORITY,
} from "@/types/tasks";
import { ErrorBoundary } from "@/components/error-boundary";
import { useToast } from "@/components/ui/use-toast";

interface TaskDialogProps {
  isOpen: boolean;
  setIsOpen: (open: boolean) => void;
  taskData?: TaskWithRelations | null;
  onSubmit: (data: TaskFormData) => Promise<void>;
  isSubmitting?: boolean;
}

export function TaskDialog({
  isOpen,
  setIsOpen,
  taskData,
  onSubmit,
  isSubmitting = false,
}: TaskDialogProps) {
  const { toast } = useToast();
  const [error, setError] = useState<Error | null>(null);

  const form = useForm<TaskFormData>({
    resolver: zodResolver(taskSchema),
    defaultValues: {
      title: taskData?.title || "",
      description: taskData?.description || "",
      status: taskData?.status || TASK_STATUS.TODO,
      priority: taskData?.priority || TASK_PRIORITY.MEDIUM,
      project_id: taskData?.project_id || null,
      assignee_id: taskData?.assignee_id || null,
      due_date: taskData?.due_date || null,
      start_date: taskData?.start_date || null,
      tax_form_type: taskData?.tax_form_type || null,
      category: taskData?.category || null,
    },
  });

  const handleSubmit = async (data: TaskFormData) => {
    try {
      setError(null);
      await onSubmit(data);
      setIsOpen(false);
      form.reset();
      toast({
        title: `Task ${taskData ? "updated" : "created"} successfully`,
        variant: "default",
      });
    } catch (err) {
      setError(err as Error);
      toast({
        title: "Error",
        description:
          (err as Error).message ||
          `Failed to ${taskData ? "update" : "create"} task`,
        variant: "destructive",
      });
    }
  };

  return (
    <Dialog open={isOpen} onOpenChange={setIsOpen}>
      <DialogContent className="sm:max-w-[425px]">
        <ErrorBoundary>
          <DialogHeader>
            <DialogTitle>{taskData ? "Edit Task" : "Create Task"}</DialogTitle>
          </DialogHeader>

          <Form {...form}>
            <form
              onSubmit={form.handleSubmit(handleSubmit)}
              className="space-y-4"
            >
              <FormField
                control={form.control}
                name="title"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Title</FormLabel>
                    <FormControl>
                      <Input {...field} placeholder="Enter task title" />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <FormField
                control={form.control}
                name="description"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Description</FormLabel>
                    <FormControl>
                      <Textarea
                        {...field}
                        placeholder="Enter task description"
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <FormField
                control={form.control}
                name="status"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Status</FormLabel>
                    <Select
                      onValueChange={field.onChange}
                      defaultValue={field.value}
                    >
                      <FormControl>
                        <SelectTrigger>
                          <SelectValue placeholder="Select status" />
                        </SelectTrigger>
                      </FormControl>
                      <SelectContent>
                        {Object.entries(TASK_STATUS).map(([key, value]) => (
                          <SelectItem key={key} value={value}>
                            {key.replace(/_/g, " ")}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <FormField
                control={form.control}
                name="priority"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Priority</FormLabel>
                    <Select
                      onValueChange={field.onChange}
                      defaultValue={field.value || undefined}
                    >
                      <FormControl>
                        <SelectTrigger>
                          <SelectValue placeholder="Select priority" />
                        </SelectTrigger>
                      </FormControl>
                      <SelectContent>
                        {Object.entries(TASK_PRIORITY).map(([key, value]) => (
                          <SelectItem key={key} value={value}>
                            {key.replace(/_/g, " ")}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                    <FormMessage />
                  </FormItem>
                )}
              />

              {error && (
                <div className="text-sm text-destructive">{error.message}</div>
              )}

              <div className="flex justify-end space-x-2">
                <Button
                  type="button"
                  variant="outline"
                  onClick={() => setIsOpen(false)}
                  disabled={isSubmitting}
                >
                  Cancel
                </Button>
                <Button type="submit" disabled={isSubmitting}>
                  {isSubmitting ? "Saving..." : taskData ? "Update" : "Create"}
                </Button>
              </div>
            </form>
          </Form>
        </ErrorBoundary>
      </DialogContent>
    </Dialog>
  );
}
```

### `src\components\tasks\task-error-boundary.tsx`

```tsx
"use client";

import { ReactNode } from "react";
import { ErrorBoundary } from "@/components/error-boundary";

interface TaskErrorBoundaryProps {
  children: ReactNode;
}

export function TaskErrorBoundary({ children }: TaskErrorBoundaryProps) {
  return (
    <ErrorBoundary
      fallback={
        <div className="p-4">
          <h2 className="text-lg font-semibold mb-2">Task Error</h2>
          <p className="text-muted-foreground">
            An error occurred while managing tasks. Please try again or contact
            support if the issue persists.
          </p>
        </div>
      }
    >
      {children}
    </ErrorBoundary>
  );
}
```

### `src\components\tasks\task-form.tsx`

```tsx
"use client";

import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import {
  TaskFormData,
  taskSchema,
  taskStatusOptions,
  taskPriorityOptions,
} from "@/types/tasks";
import { Button } from "@/components/ui/button";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { DatePicker } from "@/components/ui/date-picker";

interface TaskFormProps {
  initialData?: Partial<TaskFormData>;
  onSubmit: (data: TaskFormData) => Promise<void>;
  isSubmitting?: boolean;
}

export function TaskForm({
  initialData,
  onSubmit,
  isSubmitting,
}: TaskFormProps) {
  const form = useForm<TaskFormData>({
    resolver: zodResolver(taskSchema),
    defaultValues: {
      title: initialData?.title || "",
      description: initialData?.description || "",
      status: initialData?.status || "todo",
      priority: initialData?.priority || "medium",
      project_id: initialData?.project_id || null,
      assignee_id: initialData?.assignee_id || null,
      due_date: initialData?.due_date || null,
      start_date: initialData?.start_date || null,
      tax_form_type: initialData?.tax_form_type || null,
      category: initialData?.category || null,
    },
  });

  const handleSubmit = async (values: TaskFormData) => {
    try {
      await onSubmit(values);
      form.reset();
    } catch (error) {
      // Error will be handled by the parent component
      form.setError("root", {
        message:
          error instanceof Error ? error.message : "Failed to submit task",
      });
    }
  };

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(handleSubmit)} className="space-y-4">
        <FormField
          control={form.control}
          name="title"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Title</FormLabel>
              <FormControl>
                <Input {...field} placeholder="Task title" />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={form.control}
          name="description"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Description</FormLabel>
              <FormControl>
                <Textarea {...field} placeholder="Task description" />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <div className="grid grid-cols-2 gap-4">
          <FormField
            control={form.control}
            name="status"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Status</FormLabel>
                <Select
                  onValueChange={field.onChange}
                  defaultValue={field.value}
                >
                  <FormControl>
                    <SelectTrigger>
                      <SelectValue placeholder="Select status" />
                    </SelectTrigger>
                  </FormControl>
                  <SelectContent>
                    {taskStatusOptions.map((status) => (
                      <SelectItem key={status} value={status}>
                        {status.charAt(0).toUpperCase() + status.slice(1)}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
                <FormMessage />
              </FormItem>
            )}
          />

          <FormField
            control={form.control}
            name="priority"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Priority</FormLabel>
                <Select
                  onValueChange={field.onChange}
                  defaultValue={field.value || undefined}
                >
                  <FormControl>
                    <SelectTrigger>
                      <SelectValue placeholder="Select priority" />
                    </SelectTrigger>
                  </FormControl>
                  <SelectContent>
                    {taskPriorityOptions.map((priority) => (
                      <SelectItem key={priority} value={priority}>
                        {priority.charAt(0).toUpperCase() + priority.slice(1)}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
                <FormMessage />
              </FormItem>
            )}
          />
        </div>

        <div className="grid grid-cols-2 gap-4">
          <FormField
            control={form.control}
            name="start_date"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Start Date</FormLabel>
                <FormControl>
                  <DatePicker
                    value={field.value ? new Date(field.value) : undefined}
                    onChange={(date) => field.onChange(date?.toISOString())}
                  />
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />

          <FormField
            control={form.control}
            name="due_date"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Due Date</FormLabel>
                <FormControl>
                  <DatePicker
                    value={field.value ? new Date(field.value) : undefined}
                    onChange={(date) => field.onChange(date?.toISOString())}
                  />
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />
        </div>

        {form.formState.errors.root && (
          <div className="text-sm font-medium text-destructive">
            {form.formState.errors.root.message}
          </div>
        )}

        <div className="flex justify-end space-x-2">
          <Button type="submit" disabled={isSubmitting}>
            {isSubmitting ? "Saving..." : "Save Task"}
          </Button>
        </div>
      </form>
    </Form>
  );
}
```

### `src\components\tasks\task-item.tsx`

```tsx
"use client";

import { useState, useRef, KeyboardEvent } from "react";
import { TaskWithRelations } from "@/types/tasks";
import { TaskDialog } from "./task-dialog";
import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Skeleton } from "@/components/ui/skeleton";
import { formatDistanceToNow } from "date-fns";
import { CheckCircle2, Circle, MoreVertical, Trash2 } from "lucide-react";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";

interface TaskItemProps {
  task: TaskWithRelations;
  onUpdate: (task: Partial<TaskWithRelations>) => Promise<void>;
  onDelete: (taskId: string) => Promise<void>;
  showDetails?: boolean;
}

export function TaskItem({
  task,
  onUpdate,
  onDelete,
  showDetails = false,
}: TaskItemProps) {
  const [isEditDialogOpen, setIsEditDialogOpen] = useState(false);
  const [isDeleting, setIsDeleting] = useState(false);
  const dropdownTriggerRef = useRef<HTMLButtonElement>(null);

  const handleStatusToggle = async () => {
    await onUpdate({
      id: task.id,
      status: task.status === "completed" ? "in_progress" : "completed",
      completed_at:
        task.status === "completed" ? null : new Date().toISOString(),
    });
  };

  const handleDelete = async () => {
    setIsDeleting(true);
    try {
      await onDelete(task.id);
    } finally {
      setIsDeleting(false);
    }
  };

  const handleKeyDown = (e: KeyboardEvent<HTMLDivElement>) => {
    switch (e.key) {
      case "Enter":
      case " ":
        e.preventDefault();
        handleStatusToggle();
        break;
      case "e":
        if (e.ctrlKey || e.metaKey) {
          e.preventDefault();
          setIsEditDialogOpen(true);
        }
        break;
      case "Delete":
        if (e.ctrlKey || e.metaKey) {
          e.preventDefault();
          handleDelete();
        }
        break;
    }
  };

  return (
    <>
      <Card
        className="p-4 hover:shadow-md transition-shadow"
        role="listitem"
        aria-label={`Task: ${task.title}`}
        tabIndex={0}
        onKeyDown={handleKeyDown}
      >
        <div className="flex items-start gap-4">
          <Button
            variant="ghost"
            size="icon"
            className="mt-0.5"
            onClick={handleStatusToggle}
            aria-label={`Mark task as ${task.status === "completed" ? "incomplete" : "complete"}`}
          >
            {task.status === "completed" ? (
              <CheckCircle2
                className="h-5 w-5 text-green-500"
                aria-hidden="true"
              />
            ) : (
              <Circle
                className="h-5 w-5 text-muted-foreground"
                aria-hidden="true"
              />
            )}
          </Button>

          <div className="flex-1 min-w-0">
            <div className="flex items-start justify-between gap-4">
              <div className="space-y-1">
                <h3
                  className={`font-medium ${task.status === "completed" ? "line-through text-muted-foreground" : ""}`}
                  aria-label={
                    task.status === "completed"
                      ? "Completed task"
                      : "Active task"
                  }
                >
                  {task.title}
                </h3>
                {task.description && (
                  <p className="text-sm text-muted-foreground line-clamp-2">
                    {task.description}
                  </p>
                )}
              </div>

              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <Button
                    variant="ghost"
                    size="icon"
                    disabled={isDeleting}
                    ref={dropdownTriggerRef}
                    aria-label="Task actions"
                  >
                    <MoreVertical className="h-4 w-4" aria-hidden="true" />
                  </Button>
                </DropdownMenuTrigger>
                <DropdownMenuContent align="end">
                  <DropdownMenuItem
                    onClick={() => setIsEditDialogOpen(true)}
                    onSelect={() => dropdownTriggerRef.current?.focus()}
                  >
                    Edit
                  </DropdownMenuItem>
                  <DropdownMenuItem
                    className="text-destructive"
                    onClick={handleDelete}
                    disabled={isDeleting}
                    onSelect={() => dropdownTriggerRef.current?.focus()}
                  >
                    <Trash2 className="h-4 w-4 mr-2" aria-hidden="true" />
                    {isDeleting ? "Deleting..." : "Delete"}
                  </DropdownMenuItem>
                </DropdownMenuContent>
              </DropdownMenu>
            </div>

            {showDetails && (
              <div
                className="mt-4 space-y-2"
                role="region"
                aria-label="Task details"
              >
                <div className="flex flex-wrap gap-2">
                  {task.priority && (
                    <Badge
                      variant={
                        task.priority === "high" ? "destructive" : "secondary"
                      }
                      aria-label={`Priority: ${task.priority}`}
                    >
                      {task.priority.charAt(0).toUpperCase() +
                        task.priority.slice(1)}{" "}
                      Priority
                    </Badge>
                  )}
                  {task.status && (
                    <Badge
                      variant="outline"
                      aria-label={`Status: ${task.status}`}
                    >
                      {task.status.charAt(0).toUpperCase() +
                        task.status.slice(1)}
                    </Badge>
                  )}
                </div>

                <div className="text-sm text-muted-foreground space-y-1">
                  {task.project && (
                    <p aria-label={`Project: ${task.project.name}`}>
                      Project: {task.project.name}
                    </p>
                  )}
                  {task.assignee && (
                    <p
                      aria-label={`Assigned to: ${task.assignee.full_name || task.assignee.email}`}
                    >
                      Assigned to:{" "}
                      {task.assignee.full_name || task.assignee.email}
                    </p>
                  )}
                  {task.parent_task && (
                    <p aria-label={`Parent task: ${task.parent_task.title}`}>
                      Parent task: {task.parent_task.title}
                    </p>
                  )}
                  {task.created_at && (
                    <p
                      aria-label={`Created ${formatDistanceToNow(new Date(task.created_at))} ago`}
                    >
                      Created {formatDistanceToNow(new Date(task.created_at))}{" "}
                      ago
                    </p>
                  )}
                  {task.checklist_items && task.checklist_items.length > 0 && (
                    <p
                      aria-label={`Checklist: ${task.checklist_items.filter((item) => item.completed).length} of ${task.checklist_items.length} items completed`}
                    >
                      Checklist:{" "}
                      {
                        task.checklist_items.filter((item) => item.completed)
                          .length
                      }
                      /{task.checklist_items.length} completed
                    </p>
                  )}
                </div>
              </div>
            )}
          </div>
        </div>
      </Card>

      <TaskDialog
        open={isEditDialogOpen}
        onOpenChange={setIsEditDialogOpen}
        onSubmit={async (data) => {
          await onUpdate({ id: task.id, ...data });
          setIsEditDialogOpen(false);
        }}
        taskData={task}
      />
    </>
  );
}

export function TaskItemSkeleton() {
  return (
    <Card className="p-4" role="listitem" aria-label="Loading task item">
      <div className="flex items-start gap-4">
        <Skeleton className="h-8 w-8 rounded-full" />
        <div className="flex-1 space-y-2">
          <Skeleton className="h-5 w-1/3" />
          <Skeleton className="h-4 w-2/3" />
        </div>
      </div>
    </Card>
  );
}
```

### `src\components\tasks\task-list.tsx`

```tsx
"use client";

import { useState, useEffect } from "react";
import {
  Card,
  CardHeader,
  CardTitle,
  CardDescription,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Skeleton } from "@/components/ui/skeleton";
import { TaskDialog } from "./task-dialog";
import { TaskWithRelations, TaskFormData, toTaskFormData } from "@/types/tasks";
import { ErrorBoundary } from "@/components/error-boundary";

interface TaskListProps {
  tasks: TaskWithRelations[];
  isLoading?: boolean;
  totalTasks: number;
  currentPage: number;
  totalPages: number;
  onUpdate: (taskId: string, data: TaskFormData) => Promise<void>;
  onDelete: (taskId: string) => Promise<void>;
  onCreate?: (data: TaskFormData) => Promise<void>;
  onPageChange: (page: number) => void;
}

export function TaskList({
  tasks,
  isLoading = false,
  totalTasks,
  currentPage,
  totalPages,
  onUpdate,
  onDelete,
  onCreate,
  onPageChange,
}: TaskListProps) {
  const [dialogOpen, setDialogOpen] = useState(false);
  const [selectedTask, setSelectedTask] = useState<TaskWithRelations | null>(
    null,
  );

  const handleSubmit = async (data: TaskFormData) => {
    if (selectedTask) {
      await onUpdate(selectedTask.id, data);
    } else if (onCreate) {
      await onCreate(data);
    }
    setDialogOpen(false);
    setSelectedTask(null);
  };

  // Prefetch next page when near the end of the list
  useEffect(() => {
    const observer = new IntersectionObserver(
      (entries) => {
        if (entries[0].isIntersecting && currentPage < totalPages) {
          onPageChange(currentPage + 1);
        }
      },
      { threshold: 0.5 },
    );

    const sentinel = document.getElementById("task-list-sentinel");
    if (sentinel) {
      observer.observe(sentinel);
    }

    return () => observer.disconnect();
  }, [currentPage, totalPages, onPageChange]);

  if (isLoading && tasks.length === 0) {
    return (
      <div className="space-y-4">
        {[...Array(3)].map((_, i) => (
          <Card key={i} className="p-4">
            <Skeleton className="h-6 w-2/3 mb-2" />
            <Skeleton className="h-4 w-1/2" />
          </Card>
        ))}
      </div>
    );
  }

  return (
    <ErrorBoundary>
      <div className="space-y-4">
        {tasks.length === 0 ? (
          <Card className="p-4">
            <CardHeader>
              <CardTitle>No tasks found</CardTitle>
              <CardDescription>
                {onCreate
                  ? "Create a new task to get started."
                  : "No tasks match your criteria."}
              </CardDescription>
            </CardHeader>
          </Card>
        ) : (
          <>
            {tasks.map((task) => (
              <Card key={task.id} className="p-4">
                <div className="flex items-center justify-between">
                  <div>
                    <h3 className="font-medium">{task.title}</h3>
                    {task.description && (
                      <p className="text-sm text-gray-500">
                        {task.description}
                      </p>
                    )}
                    <div className="mt-2 flex gap-2">
                      <span className="text-xs px-2 py-1 rounded-full bg-gray-100">
                        {task.status}
                      </span>
                      {task.priority && (
                        <span className="text-xs px-2 py-1 rounded-full bg-gray-100">
                          {task.priority}
                        </span>
                      )}
                    </div>
                  </div>
                  <div className="flex gap-2">
                    <Button
                      variant="ghost"
                      size="sm"
                      onClick={() => {
                        setSelectedTask(task);
                        setDialogOpen(true);
                      }}
                    >
                      Edit
                    </Button>
                    <Button
                      variant="ghost"
                      size="sm"
                      onClick={() => onDelete(task.id)}
                    >
                      Delete
                    </Button>
                  </div>
                </div>
              </Card>
            ))}
            {currentPage < totalPages && (
              <div id="task-list-sentinel" className="h-4" />
            )}
            {isLoading && (
              <Card className="p-4">
                <Skeleton className="h-6 w-2/3 mb-2" />
                <Skeleton className="h-4 w-1/2" />
              </Card>
            )}
          </>
        )}

        <TaskDialog
          isOpen={dialogOpen}
          setIsOpen={setDialogOpen}
          taskData={selectedTask}
          onSubmit={handleSubmit}
        />
      </div>
    </ErrorBoundary>
  );
}
```

### `src\components\tasks\task-side-panel.tsx`

```tsx
"use client";

import { useState } from "react";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import { Button } from "@/components/ui/button";
import {
  Sheet,
  SheetContent,
  SheetHeader,
  SheetTitle,
  SheetDescription,
} from "@/components/ui/sheet";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { useForm, FormProvider } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import * as z from "zod";
import { useToast } from "@/components/ui/use-toast";
import type { Json } from "@/types/database.types";
import {
  TaskWithRelations,
  TaskStatus,
  TaskPriority,
  taskStatusOptions,
  taskPriorityOptions,
} from "@/types/tasks";
import { Database } from "@/types/database.types";
import { taskSchema } from "@/lib/validations/task";
import type { TaskFormSchema } from "@/lib/validations/task";

type ActivityLogEntry =
  Database["public"]["Tables"]["activity_log_entries"]["Insert"];

type TaskWithRelationsResponse =
  Database["public"]["Tables"]["tasks"]["Row"] & {
    assignee: {
      id: string;
      email: string;
      full_name: string;
      role: Database["public"]["Enums"]["user_role"];
    } | null;
    project: {
      id: string;
      name: string;
    } | null;
    parent_task: {
      id: string;
      title: string;
    } | null;
    activity_log_entries: Database["public"]["Tables"]["activity_log_entries"]["Row"][];
  };

type DbTask = Database["public"]["Tables"]["tasks"]["Row"];
type DbTaskInsert = Database["public"]["Tables"]["tasks"]["Insert"];
type DbTaskUpdate = Database["public"]["Tables"]["tasks"]["Update"];

type FormData = TaskFormSchema;

interface TaskSidePanelProps {
  isOpen: boolean;
  onClose: () => void;
  task: TaskWithRelations | null;
  projectId?: string;
  onTaskUpdate?: (task: TaskWithRelations) => void;
}

export function TaskSidePanel({
  isOpen,
  onClose,
  task,
  projectId,
  onTaskUpdate,
}: TaskSidePanelProps) {
  const { toast } = useToast();
  const [loading, setLoading] = useState(false);
  const supabase = createClientComponentClient<Database>();

  const form = useForm<FormData>({
    resolver: zodResolver(taskSchema),
    defaultValues: task
      ? {
          title: task.title,
          description: task.description || "",
          project_id: task.project_id,
          assignee_id: task.assignee_id || undefined,
          status: (task.status as TaskStatus) || "todo",
          priority: (task.priority as TaskPriority) || "medium",
          due_date: task.due_date || null,
          start_date: task.start_date || null,
          checklist: {
            items:
              task.checklist_items?.map((item) => ({
                id: item.id,
                title: item.title,
                completed: item.completed,
                description: item.description || null,
                task_id: item.task_id,
              })) || null,
            completed_count:
              task.checklist_items?.filter((item) => item.completed).length ||
              0,
            total_count: task.checklist_items?.length || 0,
          },
          activity_log:
            task.activity_log_entries?.map((entry) => ({
              action: entry.action,
              timestamp: entry.created_at || "",
              user_id: entry.performed_by,
              details: entry.details?.toString() || "",
            })) || null,
          recurring_config: task.recurring_config,
        }
      : {
          title: "",
          description: "",
          project_id: "", // This should be provided by the parent component
          status: "todo" as TaskStatus,
          priority: "medium" as TaskPriority,
          due_date: null,
          start_date: null,
          checklist: null,
          activity_log: null,
          recurring_config: null,
        },
  });

  const onSubmit = async (data: FormData) => {
    setLoading(true);
    try {
      const taskData = {
        title: data.title,
        description: data.description,
        project_id: data.project_id,
        assignee_id: data.assignee_id,
        status: data.status,
        priority: data.priority,
        due_date: data.due_date,
        start_date: data.start_date,
        recurring_config: data.recurring_config,
        updated_at: new Date().toISOString(),
      } satisfies DbTaskUpdate;

      if (task?.id) {
        const { error } = await supabase
          .from("tasks")
          .update(taskData)
          .eq("id", task.id);

        if (error) throw error;

        // Update checklist items
        if (data.checklist?.items) {
          const checklistItems = data.checklist.items.map((item) => ({
            id: item.id,
            title: item.title,
            completed: item.completed,
            description: item.description,
            task_id: task.id,
            updated_at: new Date().toISOString(),
          })) satisfies Database["public"]["Tables"]["checklist_items"]["Insert"][];

          const { error: checklistError } = await supabase
            .from("checklist_items")
            .upsert(checklistItems);

          if (checklistError) throw checklistError;
        }

        // Add activity log entry
        const { error: activityError } = await supabase
          .from("activity_log_entries")
          .insert({
            task_id: task.id,
            action: "updated",
            details: taskData,
            created_at: new Date().toISOString(),
          });

        if (activityError) throw activityError;
      } else {
        const insertData = {
          ...taskData,
          title: data.title, // Explicitly include required fields
          created_at: new Date().toISOString(),
        } satisfies DbTaskInsert;

        const { data: newTask, error } = await supabase
          .from("tasks")
          .insert([insertData])
          .select()
          .single();

        if (error) throw error;

        // Create checklist items
        if (data.checklist?.items && newTask) {
          const checklistItems = data.checklist.items.map((item) => ({
            title: item.title,
            completed: item.completed,
            description: item.description,
            task_id: newTask.id,
            created_at: new Date().toISOString(),
            updated_at: new Date().toISOString(),
          })) satisfies Database["public"]["Tables"]["checklist_items"]["Insert"][];

          const { error: checklistError } = await supabase
            .from("checklist_items")
            .insert(checklistItems);

          if (checklistError) throw checklistError;
        }

        // Add initial activity log entry
        if (newTask) {
          const { error: activityError } = await supabase
            .from("activity_log_entries")
            .insert({
              task_id: newTask.id,
              action: "created",
              details: { status: newTask.status },
              created_at: new Date().toISOString(),
            });

          if (activityError) throw activityError;
        }
      }

      onClose();
    } catch (error) {
      console.error("Error saving task:", error);
      toast({
        title: "Error",
        description: "Failed to save task. Please try again.",
        variant: "destructive",
      });
    } finally {
      setLoading(false);
    }
  };

  return (
    <Sheet open={isOpen} onOpenChange={onClose}>
      <SheetContent>
        <SheetHeader>
          <SheetTitle>{task ? "Edit Task" : "New Task"}</SheetTitle>
          <SheetDescription>
            {task
              ? "Update the task details below."
              : "Create a new task by filling out the form below."}
          </SheetDescription>
        </SheetHeader>

        <div className="space-y-4 mt-4">
          <Form form={form}>
            <form onSubmit={form.handleSubmit(onSubmit)}>
              <FormField
                control={form.control}
                name="title"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Title</FormLabel>
                    <FormControl>
                      <Input {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <FormField
                control={form.control}
                name="description"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Description</FormLabel>
                    <FormControl>
                      <Textarea {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <FormField
                control={form.control}
                name="status"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel id="status-label">Status</FormLabel>
                    <Select
                      onValueChange={field.onChange}
                      defaultValue={field.value}
                    >
                      <SelectTrigger aria-labelledby="status-label">
                        <SelectValue placeholder="Select status" />
                      </SelectTrigger>
                      <SelectContent>
                        {taskStatusOptions.map((status) => (
                          <SelectItem key={status} value={status}>
                            {status}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <FormField
                control={form.control}
                name="priority"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel id="priority-label">Priority</FormLabel>
                    <Select
                      onValueChange={field.onChange}
                      defaultValue={field.value}
                    >
                      <SelectTrigger aria-labelledby="priority-label">
                        <SelectValue placeholder="Select priority" />
                      </SelectTrigger>
                      <SelectContent>
                        {taskPriorityOptions.map((priority) => (
                          <SelectItem key={priority} value={priority}>
                            {priority}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <div className="flex justify-end space-x-2 mt-4">
                <Button type="button" variant="outline" onClick={onClose}>
                  Cancel
                </Button>
                <Button type="submit" disabled={loading}>
                  {loading ? "Saving..." : task ? "Update" : "Create"}
                </Button>
              </div>
            </form>
          </Form>
        </div>
      </SheetContent>
    </Sheet>
  );
}
```

### `src\components\tasks\__tests__\task-dialog.test.tsx`

```tsx
import { render, screen, fireEvent, waitFor } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import { TaskDialog } from "../task-dialog";
import type { TaskWithRelations } from "@/types/tasks";

const mockTask: TaskWithRelations = {
  id: "1",
  title: "Test Task",
  description: "Test Description",
  status: "todo",
  priority: "medium",
  project_id: null,
  assignee_id: null,
  due_date: null,
  start_date: null,
  tax_form_type: null,
  category: null,
  created_at: new Date().toISOString(),
  updated_at: new Date().toISOString(),
  assigned_team: null,
  completed_at: null,
  dependencies: null,
  parent_task_id: null,
  progress: null,
  recurring_config: null,
  tax_return_id: null,
  template_id: null,
};

describe("TaskDialog", () => {
  const mockOnSubmit = jest.fn();
  const mockSetIsOpen = jest.fn();

  beforeEach(() => {
    jest.clearAllMocks();
  });

  it("renders create task dialog correctly", () => {
    render(
      <TaskDialog
        isOpen={true}
        setIsOpen={mockSetIsOpen}
        onSubmit={mockOnSubmit}
      />,
    );

    expect(screen.getByText("Create Task")).toBeInTheDocument();
    expect(screen.getByRole("textbox", { name: /title/i })).toBeInTheDocument();
    expect(
      screen.getByRole("textbox", { name: /description/i }),
    ).toBeInTheDocument();
    expect(screen.getByRole("button", { name: /create/i })).toBeInTheDocument();
  });

  it("renders edit task dialog correctly", () => {
    render(
      <TaskDialog
        isOpen={true}
        setIsOpen={mockSetIsOpen}
        taskData={mockTask}
        onSubmit={mockOnSubmit}
      />,
    );

    expect(screen.getByText("Edit Task")).toBeInTheDocument();
    expect(screen.getByDisplayValue(mockTask.title)).toBeInTheDocument();
    expect(screen.getByDisplayValue(mockTask.description!)).toBeInTheDocument();
    expect(screen.getByRole("button", { name: /update/i })).toBeInTheDocument();
  });

  it("submits form with correct data for new task", async () => {
    const user = userEvent.setup();

    render(
      <TaskDialog
        isOpen={true}
        setIsOpen={mockSetIsOpen}
        onSubmit={mockOnSubmit}
      />,
    );

    await user.type(
      screen.getByRole("textbox", { name: /title/i }),
      "New Task",
    );
    await user.type(
      screen.getByRole("textbox", { name: /description/i }),
      "New Description",
    );

    await user.click(screen.getByRole("button", { name: /create/i }));

    await waitFor(() => {
      expect(mockOnSubmit).toHaveBeenCalledWith(
        expect.objectContaining({
          title: "New Task",
          description: "New Description",
          status: "todo",
        }),
      );
    });
  });

  it("submits form with correct data for edit task", async () => {
    const user = userEvent.setup();

    render(
      <TaskDialog
        isOpen={true}
        setIsOpen={mockSetIsOpen}
        taskData={mockTask}
        onSubmit={mockOnSubmit}
      />,
    );

    const titleInput = screen.getByDisplayValue(mockTask.title);
    await user.clear(titleInput);
    await user.type(titleInput, "Updated Task");

    await user.click(screen.getByRole("button", { name: /update/i }));

    await waitFor(() => {
      expect(mockOnSubmit).toHaveBeenCalledWith(
        expect.objectContaining({
          title: "Updated Task",
          description: mockTask.description,
          status: mockTask.status,
        }),
      );
    });
  });

  it("validates required fields", async () => {
    const user = userEvent.setup();

    render(
      <TaskDialog
        isOpen={true}
        setIsOpen={mockSetIsOpen}
        onSubmit={mockOnSubmit}
      />,
    );

    await user.click(screen.getByRole("button", { name: /create/i }));

    expect(await screen.findByText("Title is required")).toBeInTheDocument();
    expect(mockOnSubmit).not.toHaveBeenCalled();
  });

  it("closes dialog when cancel is clicked", async () => {
    const user = userEvent.setup();

    render(
      <TaskDialog
        isOpen={true}
        setIsOpen={mockSetIsOpen}
        onSubmit={mockOnSubmit}
      />,
    );

    await user.click(screen.getByRole("button", { name: /cancel/i }));

    expect(mockSetIsOpen).toHaveBeenCalledWith(false);
  });

  it("disables submit button when isSubmitting is true", () => {
    render(
      <TaskDialog
        isOpen={true}
        setIsOpen={mockSetIsOpen}
        onSubmit={mockOnSubmit}
        isSubmitting={true}
      />,
    );

    expect(screen.getByRole("button", { name: /saving/i })).toBeDisabled();
  });
});
```

### `src\components\tax\DocumentUpload.tsx`

```tsx
"use client";

import { DropZone } from "@/components/shared/DropZone";
import { ProcessingStatus } from "@/components/ai/ProcessingStatus";

function UploadInstructions() {
  return (
    <div className="text-center p-4">
      <p>Drop your tax documents here or click to browse</p>
      <p className="text-sm text-muted-foreground">
        Supported formats: PDF, JPG, PNG
      </p>
    </div>
  );
}

export function DocumentUpload({ taxReturnId }: { taxReturnId: string }) {
  const handleUpload = async (files: FileList) => {
    // Implementation will be handled by the AI processing service
  };

  return (
    <DropZone onDrop={handleUpload}>
      <UploadInstructions />
      <ProcessingStatus documentId={taxReturnId} />
    </DropZone>
  );
}
```

### `src\components\tax\TaxReturnForm.tsx`

```tsx
"use client";

import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import {
  Form,
  FormField,
  FormItem,
  FormLabel,
  FormControl,
  FormMessage,
} from "@/components/ui/form";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Button } from "@/components/ui/button";
import { createClient } from "@/lib/supabase/browser";
import { useRouter } from "next/navigation";
import type { Database } from "@/types/database.types";

type TaxReturn = Database["public"]["Tables"]["tax_returns"]["Row"];

const taxReturnSchema = z.object({
  tax_year: z
    .number()
    .min(2000)
    .max(new Date().getFullYear() + 1),
  status: z.enum(["draft", "in_progress", "review", "completed"]),
  client_id: z.string().uuid(),
  due_date: z.string().optional(),
  assigned_to: z.string().uuid().optional(),
});

type FormValues = z.infer<typeof taxReturnSchema>;

function getTaxYears() {
  const currentYear = new Date().getFullYear();
  return Array.from({ length: 5 }, (_, i) => currentYear - i);
}

interface TaxReturnFormProps {
  clientId: string;
  initialData?: Partial<TaxReturn>;
}

export function TaxReturnForm({ clientId, initialData }: TaxReturnFormProps) {
  const router = useRouter();
  const supabase = createClient();

  const form = useForm<FormValues>({
    resolver: zodResolver(taxReturnSchema),
    defaultValues: {
      tax_year: initialData?.tax_year || new Date().getFullYear(),
      status: (initialData?.status as FormValues["status"]) || "draft",
      client_id: clientId,
      due_date: initialData?.due_date,
      assigned_to: initialData?.assigned_to,
    },
  });

  const onSubmit = async (values: FormValues) => {
    try {
      const { error } = initialData?.id
        ? await supabase
            .from("tax_returns")
            .update(values)
            .eq("id", initialData.id)
        : await supabase.from("tax_returns").insert(values);

      if (error) throw error;

      router.refresh();
      router.push(`/dashboard/tax-returns`);
    } catch (error) {
      console.error("Error saving tax return:", error);
    }
  };

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
        <FormField
          control={form.control}
          name="tax_year"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Tax Year</FormLabel>
              <Select
                onValueChange={(value) => field.onChange(parseInt(value))}
                defaultValue={field.value?.toString()}
              >
                <FormControl>
                  <SelectTrigger>
                    <SelectValue placeholder="Select tax year" />
                  </SelectTrigger>
                </FormControl>
                <SelectContent>
                  {getTaxYears().map((year) => (
                    <SelectItem key={year} value={year.toString()}>
                      {year}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={form.control}
          name="status"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Status</FormLabel>
              <Select onValueChange={field.onChange} defaultValue={field.value}>
                <FormControl>
                  <SelectTrigger>
                    <SelectValue placeholder="Select status" />
                  </SelectTrigger>
                </FormControl>
                <SelectContent>
                  <SelectItem value="draft">Draft</SelectItem>
                  <SelectItem value="in_progress">In Progress</SelectItem>
                  <SelectItem value="review">Review</SelectItem>
                  <SelectItem value="completed">Completed</SelectItem>
                </SelectContent>
              </Select>
              <FormMessage />
            </FormItem>
          )}
        />

        <Button type="submit">
          {initialData ? "Update" : "Create"} Tax Return
        </Button>
      </form>
    </Form>
  );
}
```

### `src\components\tax\TaxReturnList.tsx`

```tsx
"use client";

import { DataGrid } from "@/components/shared/DataGrid";
import { useTaxReturns } from "@/hooks/useTaxReturns";
import { Button } from "@/components/ui/button";

interface ActionButtonsProps {
  taxReturn: {
    id: string;
    status: string;
  };
}

function ActionButtons({ taxReturn }: ActionButtonsProps) {
  return (
    <div className="flex gap-2">
      <Button variant="outline" size="sm">
        View
      </Button>
      {taxReturn.status !== "completed" && (
        <Button variant="outline" size="sm">
          Edit
        </Button>
      )}
    </div>
  );
}

export function TaxReturnList({ clientId }: { clientId: string }) {
  const { data, isLoading } = useTaxReturns(clientId);

  return (
    <DataGrid
      data={data}
      columns={[
        { field: "tax_year", header: "Year" },
        { field: "status", header: "Status" },
        { field: "due_date", header: "Due Date" },
        {
          field: "actions",
          header: "Actions",
          render: (row) => <ActionButtons taxReturn={row} />,
        },
      ]}
    />
  );
}
```

### `src\components\tax-return\TaxReturnList.tsx`

```tsx
"use client";

import React from "react";
import { useTaxReturns } from "@/hooks/useTaxReturns";
import { Database } from "@/types/database.types";

type TaxReturn = Database["public"]["Tables"]["tax_returns"]["Row"];

interface TaxReturnListProps {
  initialReturns?: TaxReturn[] | null;
}

export default function TaxReturnList({ initialReturns }: TaxReturnListProps) {
  const { taxReturns, loading, error, updateReturn, deleteReturn } =
    useTaxReturns(initialReturns);

  if (error) {
    return <div className="text-red-600">Error: {error}</div>;
  }

  if (loading && !taxReturns.length) {
    return <div>Loading tax returns...</div>;
  }

  return (
    <div className="space-y-2">
      {taxReturns.map((taxReturn) => (
        <div
          key={taxReturn.id}
          className="border p-2 rounded shadow-sm flex justify-between"
        >
          <div>
            <p className="font-semibold">Return #{taxReturn.id}</p>
            <p className="text-sm text-gray-600">Status: {taxReturn.status}</p>
          </div>
          <div className="space-x-2">
            <button
              onClick={() =>
                updateReturn(taxReturn.id, { status: "in_review" })
              }
              className="bg-blue-500 text-white px-3 py-1 rounded"
            >
              Move to Review
            </button>
            <button
              onClick={() => deleteReturn(taxReturn.id)}
              className="bg-red-500 text-white px-3 py-1 rounded"
            >
              Delete
            </button>
          </div>
        </div>
      ))}
    </div>
  );
}
```

### `src\components\templates\create-template-dialog.tsx`

```tsx
"use client";

import { useState } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import * as z from "zod";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from "src/components/ui/dialog";
import {
  Form,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "src/components/ui/form";
import { Input } from "src/components/ui/input";
import { Button } from "src/components/ui/button";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "src/components/ui/select";
import { Textarea } from "src/components/ui/textarea";
import { useProjectTemplates } from "src/hooks/useProjectTemplates";
import {
  ProjectTemplateInput,
  SeasonalPriority,
  ProjectDefaults,
} from "@/types/projects";

const templateSchema = z.object({
  title: z.string().min(1, "Title is required"),
  description: z.string().optional(),
  category: z.enum([
    "tax-return",
    "bookkeeping",
    "payroll",
    "business-services",
    "other",
  ]),
  default_priority: z.enum(["low", "medium", "high"]).optional(),
  estimated_total_minutes: z.number().min(0),
  recurring_schedule: z
    .enum(["daily", "weekly", "monthly", "quarterly", "annually", "one-time"])
    .optional(),
  seasonal_priority: z
    .object({
      Q1: z.enum(["low", "medium", "high", "critical"]),
      Q2: z.enum(["low", "medium", "high", "critical"]),
      Q3: z.enum(["low", "medium", "high", "critical"]),
      Q4: z.enum(["low", "medium", "high", "critical"]),
    })
    .optional(),
});

type TemplateFormValues = z.infer<typeof templateSchema>;

interface CreateTemplateDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
}

export function CreateTemplateDialog({
  open,
  onOpenChange,
}: CreateTemplateDialogProps) {
  const { createTemplate } = useProjectTemplates();
  const [isSubmitting, setIsSubmitting] = useState(false);

  const form = useForm<TemplateFormValues>({
    resolver: zodResolver(templateSchema),
    defaultValues: {
      title: "",
      description: "",
      category: "other",
      default_priority: "medium",
      estimated_total_minutes: 0,
      recurring_schedule: "one-time",
      seasonal_priority: {
        Q1: "medium",
        Q2: "medium",
        Q3: "medium",
        Q4: "medium",
      },
    },
  });

  const onSubmit = async (data: TemplateFormValues) => {
    try {
      setIsSubmitting(true);
      const templateInput: ProjectTemplateInput = {
        title: data.title,
        description: data.description || "",
        category: data.category,
        category_id: null,
        default_priority: data.default_priority || "medium",
        recurring_schedule: data.recurring_schedule,
        seasonal_priority: data.seasonal_priority as SeasonalPriority,
        project_defaults: {
          estimated_total_minutes: data.estimated_total_minutes,
          recurring_schedule: data.recurring_schedule,
          seasonal_priority: data.seasonal_priority,
        } as ProjectDefaults,
        template_tasks: [],
      };
      await createTemplate(templateInput);
      form.reset();
      onOpenChange(false);
    } catch (error) {
      console.error("Failed to create template:", error);
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-2xl">
        <DialogHeader>
          <DialogTitle>Create New Project Template</DialogTitle>
          <DialogDescription>
            Create a reusable project template for common business processes.
          </DialogDescription>
        </DialogHeader>

        <Form form={form}>
          <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
            <FormField
              control={form.control}
              name="title"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Title</FormLabel>
                  <FormControl>
                    <Input {...field} />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name="description"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Description</FormLabel>
                  <FormControl>
                    <Textarea {...field} />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            <div className="grid grid-cols-2 gap-4">
              <FormField
                control={form.control}
                name="category"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Category</FormLabel>
                    <Select
                      onValueChange={field.onChange}
                      defaultValue={field.value}
                    >
                      <FormControl>
                        <SelectTrigger>
                          <SelectValue placeholder="Select category" />
                        </SelectTrigger>
                      </FormControl>
                      <SelectContent>
                        <SelectItem value="tax-return">Tax Return</SelectItem>
                        <SelectItem value="bookkeeping">Bookkeeping</SelectItem>
                        <SelectItem value="payroll">Payroll</SelectItem>
                        <SelectItem value="business-services">
                          Business Services
                        </SelectItem>
                        <SelectItem value="other">Other</SelectItem>
                      </SelectContent>
                    </Select>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <FormField
                control={form.control}
                name="default_priority"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Default Priority</FormLabel>
                    <Select
                      onValueChange={field.onChange}
                      defaultValue={field.value}
                    >
                      <FormControl>
                        <SelectTrigger>
                          <SelectValue placeholder="Select priority" />
                        </SelectTrigger>
                      </FormControl>
                      <SelectContent>
                        <SelectItem value="low">Low</SelectItem>
                        <SelectItem value="medium">Medium</SelectItem>
                        <SelectItem value="high">High</SelectItem>
                      </SelectContent>
                    </Select>
                    <FormMessage />
                  </FormItem>
                )}
              />
            </div>

            <div className="grid grid-cols-2 gap-4">
              <FormField
                control={form.control}
                name="estimated_total_minutes"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Estimated Time (minutes)</FormLabel>
                    <FormControl>
                      <Input type="number" min="0" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <FormField
                control={form.control}
                name="recurring_schedule"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Recurring Schedule</FormLabel>
                    <Select
                      onValueChange={field.onChange}
                      defaultValue={field.value}
                    >
                      <FormControl>
                        <SelectTrigger>
                          <SelectValue placeholder="Select schedule" />
                        </SelectTrigger>
                      </FormControl>
                      <SelectContent>
                        <SelectItem value="daily">Daily</SelectItem>
                        <SelectItem value="weekly">Weekly</SelectItem>
                        <SelectItem value="monthly">Monthly</SelectItem>
                        <SelectItem value="quarterly">Quarterly</SelectItem>
                        <SelectItem value="annually">Annually</SelectItem>
                        <SelectItem value="one-time">One-time</SelectItem>
                      </SelectContent>
                    </Select>
                    <FormMessage />
                  </FormItem>
                )}
              />
            </div>

            <div className="space-y-4">
              <FormLabel>Seasonal Priority</FormLabel>
              <div className="grid grid-cols-4 gap-4">
                {(["Q1", "Q2", "Q3", "Q4"] as const).map((quarter) => (
                  <FormField
                    key={quarter}
                    control={form.control}
                    name={`seasonal_priority.${quarter}`}
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>{quarter}</FormLabel>
                        <Select
                          onValueChange={field.onChange}
                          defaultValue={field.value}
                        >
                          <FormControl>
                            <SelectTrigger>
                              <SelectValue />
                            </SelectTrigger>
                          </FormControl>
                          <SelectContent>
                            <SelectItem value="low">Low</SelectItem>
                            <SelectItem value="medium">Medium</SelectItem>
                            <SelectItem value="high">High</SelectItem>
                            <SelectItem value="critical">Critical</SelectItem>
                          </SelectContent>
                        </Select>
                      </FormItem>
                    )}
                  />
                ))}
              </div>
            </div>

            <div className="flex justify-end space-x-2">
              <Button
                type="button"
                variant="outline"
                onClick={() => onOpenChange(false)}
              >
                Cancel
              </Button>
              <Button type="submit" disabled={isSubmitting}>
                {isSubmitting ? "Creating..." : "Create Template"}
              </Button>
            </div>
          </form>
        </Form>
      </DialogContent>
    </Dialog>
  );
}
```

### `src\components\templates\create-template-task-dialog.tsx`

```tsx
"use client";

import { useState } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import * as z from "zod";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from "src/components/ui/dialog";
import {
  Form,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "src/components/ui/form";
import { Input } from "src/components/ui/input";
import { Button } from "src/components/ui/button";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "src/components/ui/select";
import { Textarea } from "src/components/ui/textarea";
import { useTemplateTasks } from "src/hooks/useTemplateTasks";
import { TemplateTask } from "src/types/hooks";

const taskSchema = z.object({
  title: z.string().min(1, "Title is required"),
  description: z.string().min(1, "Description is required"),
  priority: z.enum(["low", "medium", "high", "urgent"]),
  dependencies: z.array(z.string()).default([]),
});

type TaskFormValues = z.infer<typeof taskSchema>;

interface CreateTemplateTaskDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  templateId: string;
  existingTasks: TemplateTask[];
}

export function CreateTemplateTaskDialog({
  open,
  onOpenChange,
  templateId,
  existingTasks,
}: CreateTemplateTaskDialogProps) {
  const { createTask } = useTemplateTasks(templateId);
  const [isSubmitting, setIsSubmitting] = useState(false);

  const form = useForm<TaskFormValues>({
    resolver: zodResolver(taskSchema),
    defaultValues: {
      title: "",
      description: "",
      priority: "medium",
      dependencies: [],
    },
  });

  const onSubmit = async (data: TaskFormValues) => {
    try {
      setIsSubmitting(true);
      await createTask({
        title: data.title,
        description: data.description,
        priority: data.priority,
        dependencies: data.dependencies,
        template_id: templateId,
        order_index: existingTasks.length,
      });
      form.reset();
      onOpenChange(false);
    } catch (error) {
      console.error("Failed to create task:", error);
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-2xl">
        <DialogHeader>
          <DialogTitle>Add Template Task</DialogTitle>
          <DialogDescription>
            Add a new task to this project template.
          </DialogDescription>
        </DialogHeader>

        <Form form={form}>
          <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
            <FormField
              control={form.control}
              name="title"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Title</FormLabel>
                  <FormControl>
                    <Input {...field} />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name="description"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Description</FormLabel>
                  <FormControl>
                    <Textarea {...field} />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            <div className="grid grid-cols-1 gap-4">
              <FormField
                control={form.control}
                name="priority"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Priority</FormLabel>
                    <Select
                      onValueChange={field.onChange}
                      defaultValue={field.value}
                    >
                      <FormControl>
                        <SelectTrigger>
                          <SelectValue placeholder="Select priority" />
                        </SelectTrigger>
                      </FormControl>
                      <SelectContent>
                        <SelectItem value="low">Low</SelectItem>
                        <SelectItem value="medium">Medium</SelectItem>
                        <SelectItem value="high">High</SelectItem>
                        <SelectItem value="urgent">Urgent</SelectItem>
                      </SelectContent>
                    </Select>
                    <FormMessage />
                  </FormItem>
                )}
              />
            </div>

            <div className="flex justify-end space-x-2">
              <Button
                type="button"
                variant="outline"
                onClick={() => onOpenChange(false)}
              >
                Cancel
              </Button>
              <Button type="submit" disabled={isSubmitting}>
                {isSubmitting ? "Adding..." : "Add Task"}
              </Button>
            </div>
          </form>
        </Form>
      </DialogContent>
    </Dialog>
  );
}
```

### `src\components\templates\project-template-list.tsx`

```tsx
"use client";

import { useState } from "react";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "src/components/ui/card";
import { Badge } from "src/components/ui/badge";
import { Button } from "src/components/ui/button";
import {
  Plus,
  Clock,
  CalendarClock,
  ChevronDown,
  ChevronUp,
} from "lucide-react";
import { useProjectTemplates } from "src/hooks/useProjectTemplates";
import { ProjectTemplate } from "src/types/hooks";
import { CreateTemplateDialog } from "./create-template-dialog";
import { TemplateTasks } from "./template-tasks";

export function ProjectTemplateList() {
  const { templates } = useProjectTemplates();
  const [showCreateDialog, setShowCreateDialog] = useState(false);
  const [expandedTemplate, setExpandedTemplate] = useState<string | null>(null);

  const getCategoryColor = (category: string) => {
    switch (category.toLowerCase()) {
      case "tax-return":
        return "bg-red-500";
      case "bookkeeping":
        return "bg-blue-500";
      case "payroll":
        return "bg-green-500";
      case "business-services":
        return "bg-purple-500";
      default:
        return "bg-gray-500";
    }
  };

  const toggleTemplate = (templateId: string) => {
    setExpandedTemplate(expandedTemplate === templateId ? null : templateId);
  };

  return (
    <div className="space-y-4">
      <div className="flex justify-between items-center">
        <h2 className="text-2xl font-bold">Project Templates</h2>
        <Button onClick={() => setShowCreateDialog(true)}>
          <Plus className="mr-2 h-4 w-4" />
          New Template
        </Button>
      </div>

      <div className="grid grid-cols-1 gap-4">
        {templates?.map((template) => (
          <Card key={template.id}>
            <CardHeader
              className="cursor-pointer"
              onClick={() => toggleTemplate(template.id)}
            >
              <div className="flex justify-between items-start">
                <div>
                  <div className="flex items-center space-x-2">
                    <CardTitle>{template.title}</CardTitle>
                    {expandedTemplate === template.id ? (
                      <ChevronUp className="h-4 w-4" />
                    ) : (
                      <ChevronDown className="h-4 w-4" />
                    )}
                  </div>
                  <CardDescription>{template.description}</CardDescription>
                </div>
                <Badge
                  className={`${getCategoryColor(template.category)} text-white`}
                >
                  {template.category}
                </Badge>
              </div>
            </CardHeader>
            <CardContent>
              <div className="space-y-4">
                <div className="flex items-center space-x-4 text-sm text-muted-foreground">
                  {template.project_defaults?.estimated_total_minutes && (
                    <div className="flex items-center">
                      <Clock className="mr-2 h-4 w-4" />
                      {Math.floor(
                        template.project_defaults.estimated_total_minutes / 60,
                      )}
                      h {template.project_defaults.estimated_total_minutes % 60}
                      m
                    </div>
                  )}
                  {template.recurring_schedule && (
                    <div className="flex items-center">
                      <CalendarClock className="mr-2 h-4 w-4" />
                      {template.recurring_schedule}
                    </div>
                  )}
                  {template.default_priority && (
                    <Badge
                      variant={
                        template.default_priority === "high"
                          ? "destructive"
                          : template.default_priority === "medium"
                            ? "default"
                            : "secondary"
                      }
                    >
                      {template.default_priority} priority
                    </Badge>
                  )}
                </div>

                {expandedTemplate === template.id && (
                  <div className="mt-4 pt-4 border-t">
                    <TemplateTasks template={template} />
                  </div>
                )}
              </div>
            </CardContent>
          </Card>
        ))}
      </div>

      <CreateTemplateDialog
        open={showCreateDialog}
        onOpenChange={setShowCreateDialog}
      />
    </div>
  );
}
```

### `src\components\templates\template-combobox.tsx`

```tsx
"use client";

import * as React from "react";
import { Check, ChevronsUpDown } from "lucide-react";
import { cn } from "@/lib/utils";
import { Button } from "@/components/ui/button";
import {
  Command,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandItem,
} from "@/components/ui/command";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { useProjectTemplates } from "@/hooks/useProjectTemplates";
import { Badge } from "@/components/ui/badge";

interface TemplateComboboxProps {
  value?: string;
  onChange: (value: string) => void;
}

export function TemplateCombobox({ value, onChange }: TemplateComboboxProps) {
  const [open, setOpen] = React.useState(false);
  const { templates } = useProjectTemplates();

  return (
    <Popover open={open} onOpenChange={setOpen}>
      <PopoverTrigger asChild>
        <Button
          variant="outline"
          role="combobox"
          aria-expanded={open}
          className="w-full justify-between"
        >
          {value
            ? templates?.find((template) => template.id === value)?.title
            : "Select template..."}
          <ChevronsUpDown className="ml-2 h-4 w-4 shrink-0 opacity-50" />
        </Button>
      </PopoverTrigger>
      <PopoverContent className="w-[400px] p-0">
        <Command>
          <CommandInput placeholder="Search templates..." />
          <CommandEmpty>No template found.</CommandEmpty>
          <CommandGroup>
            {templates?.map((template) => (
              <CommandItem
                key={template.id}
                value={template.title}
                onSelect={() => {
                  onChange(template.id);
                  setOpen(false);
                }}
              >
                <Check
                  className={cn(
                    "mr-2 h-4 w-4",
                    value === template.id ? "opacity-100" : "opacity-0",
                  )}
                />
                <div className="flex flex-col">
                  <span>{template.title}</span>
                  <span className="text-sm text-muted-foreground">
                    {template.description}
                  </span>
                </div>
                <Badge className="ml-auto">{template.category}</Badge>
              </CommandItem>
            ))}
          </CommandGroup>
        </Command>
      </PopoverContent>
    </Popover>
  );
}
```

### `src\components\templates\template-form.tsx`

```tsx
"use client";

import { useState, useEffect } from "react";
import { Card, CardHeader, CardTitle, CardContent } from "../ui/card";
import { Tables } from "@/types/database.types";
import { Button } from "../ui/button";
import { Input } from "../ui/input";
import { Textarea } from "../ui/textarea";
import { Form, FormProvider } from "../ui/form";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "../ui/select";
import { Plus, Minus, GripVertical } from "lucide-react";
import { Database } from "@/types/database.types";

interface TemplateTask {
  id?: string;
  title: string;
  description?: string;
  priority: Database["public"]["Enums"]["task_priority"];
  dependencies: string[];
  order_index: number;
  required_skills?: string[];
}

interface TemplateFormProps {
  mode: "create" | "edit";
  template?: Tables<"project_templates"> & {
    tasks?: TemplateTask[];
    version?: number;
    is_archived?: boolean;
  };
  categories: Tables<"template_categories">[];
  onSuccess: () => void;
}

interface TemplatePreview {
  total_tasks: number;
  required_skills: string[];
  dependencies: Record<string, string[]>;
}

export default function TemplateForm({
  mode,
  template,
  categories,
  onSuccess,
}: TemplateFormProps) {
  const [formData, setFormData] = useState({
    title: template?.title || "",
    description: template?.description || "",
    categoryId: template?.category_id || "",
    priority:
      template?.default_priority ||
      ("medium" as Database["public"]["Enums"]["task_priority"]),
    version: template?.version || 1,
    is_archived: template?.is_archived || false,
    tasks: template?.tasks || ([] as TemplateTask[]),
    project_defaults: template?.project_defaults || {},
    recurring_schedule: template?.recurring_schedule || null,
    seasonal_priority: template?.seasonal_priority || null,
  });

  const [newTask, setNewTask] = useState("");
  const [templatePreview, setTemplatePreview] = useState<TemplatePreview>({
    total_tasks: 0,
    required_skills: [],
    dependencies: {},
  });

  useEffect(() => {
    // Calculate template preview stats
    const totalTasks = formData.tasks.length;
    const requiredSkills = Array.from(
      new Set(formData.tasks.flatMap((task) => task.required_skills || [])),
    );
    const dependencies = formData.tasks.reduce(
      (acc, task) => {
        if (task.dependencies && task.dependencies.length > 0) {
          acc[task.title] = task.dependencies;
        }
        return acc;
      },
      {} as Record<string, string[]>,
    );

    setTemplatePreview({
      total_tasks: totalTasks,
      required_skills: requiredSkills,
      dependencies: dependencies,
    });
  }, [formData.tasks]);

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();

    try {
      const url =
        mode === "create" ? "/api/templates" : `/api/templates/${template?.id}`;

      const method = mode === "create" ? "POST" : "PUT";

      const response = await fetch(url, {
        method,
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          ...formData,
          ...(mode === "edit" && { id: template?.id }),
        }),
      });

      if (!response.ok) {
        throw new Error("Failed to save template");
      }

      onSuccess();
    } catch (error) {
      console.error("Error saving template:", error);
      // TODO: Add error notification
    }
  };

  const addTask = () => {
    if (newTask.trim()) {
      const newTaskData: TemplateTask = {
        title: newTask,
        priority: "medium",
        dependencies: [],
        order_index: formData.tasks.length,
        required_skills: [],
      };

      setFormData({
        ...formData,
        tasks: [...formData.tasks, newTaskData],
      });
      setNewTask("");
    }
  };

  const updateTask = (
    index: number,
    field: keyof TemplateTask,
    value: string | number | string[] | undefined,
  ) => {
    const updatedTasks = [...formData.tasks];
    updatedTasks[index] = {
      ...updatedTasks[index],
      [field]: value,
    };
    setFormData({
      ...formData,
      tasks: updatedTasks,
    });
  };

  const removeTask = (index: number) => {
    const updatedTasks = formData.tasks.filter(
      (task: TemplateTask, i: number) => i !== index,
    );
    setFormData({
      ...formData,
      tasks: updatedTasks,
    });
  };

  return (
    <Form onSubmit={handleSubmit} className="space-y-6">
      <div className="space-y-4">
        <div>
          <label htmlFor="title" className="block text-sm font-medium mb-2">
            Template Title
          </label>
          <Input
            id="title"
            value={formData.title}
            onChange={(e: React.ChangeEvent<HTMLInputElement>) =>
              setFormData({ ...formData, title: e.target.value })
            }
            required
            className="w-full"
          />
        </div>

        <div>
          <label
            htmlFor="description"
            className="block text-sm font-medium mb-2"
          >
            Description
          </label>
          <Textarea
            id="description"
            value={formData.description}
            onChange={(e: React.ChangeEvent<HTMLTextAreaElement>) =>
              setFormData({ ...formData, description: e.target.value })
            }
            className="w-full"
          />
        </div>

        <div className="grid grid-cols-2 gap-6">
          <div className="space-y-2">
            <label
              htmlFor="category"
              className="block text-sm font-medium mb-2"
            >
              Category
            </label>
            <Select
              value={formData.categoryId}
              onValueChange={(value: string) =>
                setFormData({ ...formData, categoryId: value })
              }
            >
              <SelectTrigger className="w-full">
                <SelectValue placeholder="Select a category" />
              </SelectTrigger>
              <SelectContent>
                {categories.map((category) => (
                  <SelectItem key={category.id} value={category.id}>
                    {category.name}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>

          <div className="space-y-2">
            <label
              htmlFor="priority"
              className="block text-sm font-medium mb-2"
            >
              Priority
            </label>
            <Select
              value={formData.priority}
              onValueChange={(value: string) =>
                setFormData({ ...formData, priority: value })
              }
            >
              <SelectTrigger className="w-full">
                <SelectValue placeholder="Select priority" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="low">Low</SelectItem>
                <SelectItem value="medium">Medium</SelectItem>
                <SelectItem value="high">High</SelectItem>
              </SelectContent>
            </Select>
          </div>
        </div>
      </div>

      <div className="space-y-4">
        <label className="block text-sm font-medium mb-2">Tasks</label>
        <div className="space-y-3">
          {formData.tasks.map((task: TemplateTask, index: number) => (
            <div key={index} className="p-4 border rounded-lg space-y-2">
              <div className="flex items-center gap-3">
                <GripVertical className="w-4 h-4 text-muted-foreground" />
                <Input
                  value={task.title}
                  onChange={(e) => updateTask(index, "title", e.target.value)}
                  className="flex-1"
                  placeholder="Task title"
                />
                <Button
                  type="button"
                  variant="ghost"
                  size="icon"
                  onClick={() => removeTask(index)}
                >
                  <Minus className="w-4 h-4" />
                </Button>
              </div>

              <div className="grid grid-cols-1 gap-4">
                <div>
                  <label className="text-sm font-medium">Priority</label>
                  <Select
                    value={task.priority}
                    onValueChange={(value) =>
                      updateTask(index, "priority", value)
                    }
                  >
                    <SelectTrigger className="w-full">
                      <SelectValue placeholder="Select priority" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="low">Low</SelectItem>
                      <SelectItem value="medium">Medium</SelectItem>
                      <SelectItem value="high">High</SelectItem>
                    </SelectContent>
                  </Select>
                </div>
              </div>

              <div>
                <label className="text-sm font-medium">Required Skills</label>
                <Input
                  value={task.required_skills?.join(", ") || ""}
                  onChange={(e) =>
                    updateTask(
                      index,
                      "required_skills",
                      e.target.value.split(",").map((s) => s.trim()),
                    )
                  }
                  placeholder="Comma separated skills"
                />
              </div>

              <div>
                <label className="text-sm font-medium">Dependencies</label>
                <Input
                  value={task.dependencies?.join(", ") || ""}
                  onChange={(e) =>
                    updateTask(
                      index,
                      "dependencies",
                      e.target.value.split(",").map((s) => s.trim()),
                    )
                  }
                  placeholder="Comma separated task titles"
                />
              </div>
            </div>
          ))}
          <div className="flex gap-3">
            <Input
              value={newTask}
              onChange={(e: React.ChangeEvent<HTMLInputElement>) =>
                setNewTask(e.target.value)
              }
              placeholder="Add new task"
              className="flex-1"
            />
            <Button type="button" onClick={addTask}>
              <Plus className="w-4 h-4 mr-2" />
              Add Task
            </Button>
          </div>
        </div>
      </div>

      <Card className="mt-6">
        <CardHeader>
          <CardTitle>Template Preview</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="grid grid-cols-2 gap-4">
            <div>
              <label className="text-sm font-medium">Total Tasks</label>
              <div className="text-lg font-semibold">
                {templatePreview.total_tasks}
              </div>
            </div>
            <div>
              <label className="text-sm font-medium">Required Skills</label>
              <div className="text-lg font-semibold">
                {templatePreview.required_skills.join(", ") || "None"}
              </div>
            </div>
            <div>
              <label className="text-sm font-medium">Task Dependencies</label>
              <div className="space-y-1">
                {Object.entries(templatePreview.dependencies).map(
                  ([task, deps]) => (
                    <div key={task} className="text-sm">
                      {task}: {deps.join(", ")}
                    </div>
                  ),
                )}
              </div>
            </div>
          </div>
        </CardContent>
      </Card>

      <div className="flex justify-between pt-6">
        <div className="space-x-2">
          <Button
            type="button"
            variant="outline"
            onClick={() => {
              setFormData({
                ...formData,
                is_archived: !formData.is_archived,
              });
            }}
          >
            {formData.is_archived ? "Unarchive" : "Archive"}
          </Button>
          <Button
            type="button"
            variant="outline"
            onClick={() => {
              setFormData({
                ...formData,
                version: formData.version + 1,
              });
            }}
          >
            Create New Version
          </Button>
        </div>
        <Button type="submit">
          {mode === "create" ? "Create Template" : "Save Changes"}
        </Button>
      </div>
    </Form>
  );
}
```

### `src\components\templates\template-tasks.tsx`

```tsx
"use client";

import { useState } from "react";
import {
  Card,
  CardContent,
  CardHeader,
  CardTitle,
} from "src/components/ui/card";
import { Button } from "src/components/ui/button";
import { Badge } from "src/components/ui/badge";
import { Timer, ArrowUpDown, Trash2, Plus } from "lucide-react";
import { useTemplateTasks } from "src/hooks/useTemplateTasks";
import { ProjectTemplate } from "src/types/hooks";
import { CreateTemplateTaskDialog } from "./create-template-task-dialog";

interface TemplateTasksProps {
  template: ProjectTemplate;
}

export function TemplateTasks({ template }: TemplateTasksProps) {
  const { tasks, reorderTask, deleteTask } = useTemplateTasks(template.id);
  const [showCreateDialog, setShowCreateDialog] = useState(false);

  const moveTask = async (taskId: string, direction: "up" | "down") => {
    const currentIndex = tasks.findIndex((t) => t.id === taskId);
    if (
      (direction === "up" && currentIndex > 0) ||
      (direction === "down" && currentIndex < tasks.length - 1)
    ) {
      const newIndex = direction === "up" ? currentIndex - 1 : currentIndex + 1;
      await reorderTask(taskId, tasks[newIndex].order_index);
    }
  };

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between">
        <CardTitle>Template Tasks</CardTitle>
        <Button onClick={() => setShowCreateDialog(true)}>
          <Plus className="mr-2 h-4 w-4" />
          Add Task
        </Button>
      </CardHeader>
      <CardContent>
        <div className="space-y-2">
          {tasks.map((task) => (
            <div
              key={task.id}
              className="flex items-center justify-between p-2 border rounded-lg"
            >
              <div className="flex items-center space-x-2">
                <Badge
                  variant={
                    task.priority === "high"
                      ? "destructive"
                      : task.priority === "medium"
                        ? "default"
                        : "secondary"
                  }
                >
                  {task.priority}
                </Badge>
                <span>{task.title}</span>
              </div>
              <div className="flex items-center space-x-2">
                <Button
                  variant="ghost"
                  size="sm"
                  onClick={() => moveTask(task.id, "up")}
                  disabled={tasks.indexOf(task) === 0}
                >
                  <ArrowUpDown className="h-4 w-4" />
                </Button>
                <Button
                  variant="ghost"
                  size="sm"
                  onClick={() => deleteTask(task.id)}
                >
                  <Trash2 className="h-4 w-4" />
                </Button>
              </div>
            </div>
          ))}
        </div>
      </CardContent>

      <CreateTemplateTaskDialog
        open={showCreateDialog}
        onOpenChange={setShowCreateDialog}
        templateId={template.id}
        existingTasks={tasks}
      />
    </Card>
  );
}
```

### `src\components\templates\TemplateCategoryManager.tsx`

```tsx
"use client";

import React, { useState, useEffect, useCallback } from "react";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import { TemplateCategory } from "@/types/templates";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import { showSuccessToast, showErrorToast } from "@/lib/toast";

export function TemplateCategoryManager() {
  const supabase = createClientComponentClient();
  const [categories, setCategories] = useState<TemplateCategory[]>([]);
  const [newCategory, setNewCategory] = useState({ name: "", description: "" });
  const [editingCategory, setEditingCategory] =
    useState<TemplateCategory | null>(null);
  const [isLoading, setIsLoading] = useState(false);

  const validateCategory = (category: {
    name: string;
    description: string;
  }): boolean => {
    if (!category.name.trim()) {
      showErrorToast("Category name is required");
      return false;
    }
    if (category.name.length > 50) {
      showErrorToast("Category name must be 50 characters or less");
      return false;
    }
    return true;
  };

  const fetchCategories = useCallback(async () => {
    setIsLoading(true);
    try {
      const { data, error } = await supabase
        .from("template_categories")
        .select("*")
        .order("created_at", { ascending: false });

      if (error) throw error;
      if (data) setCategories(data);
    } catch (error) {
      showErrorToast("Failed to fetch categories");
      console.error("Error fetching categories:", error);
    } finally {
      setIsLoading(false);
    }
  }, [supabase]);

  const createCategory = async () => {
    if (!validateCategory(newCategory)) return;

    setIsLoading(true);
    try {
      const { data, error } = await supabase
        .from("template_categories")
        .insert(newCategory)
        .select();

      if (error) throw error;
      if (data) {
        setCategories([...categories, data[0]]);
        setNewCategory({ name: "", description: "" });
        showSuccessToast("Category created successfully");
      }
    } catch (error) {
      showErrorToast("Failed to create category");
      console.error("Error creating category:", error);
    } finally {
      setIsLoading(false);
    }
  };

  const updateCategory = async () => {
    if (!editingCategory) return;

    if (!validateCategory(editingCategory)) return;

    setIsLoading(true);
    try {
      const { data, error } = await supabase
        .from("template_categories")
        .update({
          name: editingCategory.name,
          description: editingCategory.description,
        })
        .eq("id", editingCategory.id)
        .select();

      if (error) throw error;
      if (data) {
        setCategories(
          categories.map((cat) =>
            cat.id === editingCategory.id ? data[0] : cat,
          ),
        );
        setEditingCategory(null);
        showSuccessToast("Category updated successfully");
      }
    } catch (error) {
      showErrorToast("Failed to update category");
      console.error("Error updating category:", error);
    } finally {
      setIsLoading(false);
    }
  };

  const deleteCategory = async (categoryId: string) => {
    setIsLoading(true);
    try {
      const { error } = await supabase
        .from("template_categories")
        .delete()
        .eq("id", categoryId);

      if (error) throw error;

      setCategories(categories.filter((cat) => cat.id !== categoryId));
      showSuccessToast("Category deleted successfully");
    } catch (error) {
      showErrorToast("Failed to delete category");
      console.error("Error deleting category:", error);
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchCategories();
  }, [fetchCategories, supabase]);

  return (
    <div className="space-y-4">
      <h2 className="text-xl font-bold">Template Categories</h2>

      <div className="flex space-x-2">
        <Input
          placeholder="Category Name"
          value={newCategory.name}
          onChange={(e) =>
            setNewCategory({ ...newCategory, name: e.target.value })
          }
          disabled={isLoading}
        />
        <Input
          placeholder="Description"
          value={newCategory.description}
          onChange={(e) =>
            setNewCategory({ ...newCategory, description: e.target.value })
          }
          disabled={isLoading}
        />
        <Button onClick={createCategory} disabled={isLoading}>
          {isLoading ? "Adding..." : "Add Category"}
        </Button>
      </div>

      <div className="space-y-2">
        {categories.map((category) => (
          <div
            key={category.id}
            className="border p-3 flex justify-between items-center"
          >
            <div>
              <h3 className="font-semibold">{category.name}</h3>
              <p className="text-gray-600">{category.description}</p>
            </div>
            <div className="space-x-2">
              <Dialog>
                <DialogTrigger asChild>
                  <Button
                    variant="outline"
                    onClick={() => setEditingCategory(category)}
                  >
                    Edit
                  </Button>
                </DialogTrigger>
                <DialogContent>
                  <DialogHeader>
                    <DialogTitle>Edit Category</DialogTitle>
                  </DialogHeader>
                  {editingCategory && (
                    <div className="space-y-2">
                      <Input
                        placeholder="Category Name"
                        value={editingCategory.name}
                        onChange={(e) =>
                          setEditingCategory({
                            ...editingCategory,
                            name: e.target.value,
                          })
                        }
                      />
                      <Input
                        placeholder="Description"
                        value={editingCategory.description}
                        onChange={(e) =>
                          setEditingCategory({
                            ...editingCategory,
                            description: e.target.value,
                          })
                        }
                      />
                      <Button onClick={updateCategory} disabled={isLoading}>
                        {isLoading ? "Saving..." : "Save Changes"}
                      </Button>
                    </div>
                  )}
                </DialogContent>
              </Dialog>
              <Button
                variant="destructive"
                onClick={() => deleteCategory(category.id)}
                disabled={isLoading}
              >
                Delete
              </Button>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}
```

### `src\components\templates\__tests__\TemplateCategoryManager.test.tsx`

```tsx
import { render, screen, fireEvent, waitFor } from "@testing-library/react";
import { TemplateCategoryManager } from "../TemplateCategoryManager";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";

// Mock Supabase client
jest.mock("@supabase/auth-helpers-nextjs", () => ({
  createClientComponentClient: jest.fn(),
}));

// Mock toast notifications
jest.mock("@/lib/toast", () => ({
  showSuccessToast: jest.fn(),
  showErrorToast: jest.fn(),
}));

describe("TemplateCategoryManager", () => {
  let mockSupabase: any;

  beforeEach(() => {
    mockSupabase = {
      from: jest.fn().mockReturnThis(),
      select: jest.fn().mockReturnThis(),
      insert: jest.fn().mockReturnThis(),
      order: jest.fn().mockReturnThis(),
      eq: jest.fn().mockReturnThis(),
      delete: jest.fn().mockReturnThis(),
      update: jest.fn().mockReturnThis(),
    };
    (createClientComponentClient as jest.Mock).mockReturnValue(mockSupabase);
  });

  test("renders category input fields", () => {
    mockSupabase.select.mockResolvedValue({ data: [], error: null });

    render(<TemplateCategoryManager />);

    expect(screen.getByPlaceholderText("Category Name")).toBeInTheDocument();
    expect(screen.getByPlaceholderText("Description")).toBeInTheDocument();
  });

  test("adds a new category", async () => {
    const mockCategory = {
      id: "1",
      name: "Test Category",
      description: "Test Description",
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
    };

    mockSupabase.select.mockResolvedValue({
      data: [],
      error: null,
    });

    mockSupabase.insert.mockResolvedValue({
      data: [mockCategory],
      error: null,
    });

    render(<TemplateCategoryManager />);

    const nameInput = screen.getByPlaceholderText("Category Name");
    const descInput = screen.getByPlaceholderText("Description");
    const addButton = screen.getByText("Add Category");

    fireEvent.change(nameInput, { target: { value: "Test Category" } });
    fireEvent.change(descInput, { target: { value: "Test Description" } });

    fireEvent.click(addButton);

    await waitFor(() => {
      expect(mockSupabase.insert).toHaveBeenCalledWith({
        name: "Test Category",
        description: "Test Description",
      });
    });
  });

  test("updates an existing category", async () => {
    const mockCategories = [
      {
        id: "1",
        name: "Original Category",
        description: "Original Description",
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      },
    ];

    const updatedCategory = {
      ...mockCategories[0],
      name: "Updated Category",
      description: "Updated Description",
    };

    mockSupabase.select.mockResolvedValue({
      data: mockCategories,
      error: null,
    });

    mockSupabase.update.mockResolvedValue({
      data: [updatedCategory],
      error: null,
    });

    render(<TemplateCategoryManager />);

    // Open edit dialog
    const editButton = screen.getByText("Edit");
    fireEvent.click(editButton);

    // Change category details
    const nameInput = screen.getByPlaceholderText("Category Name");
    const descInput = screen.getByPlaceholderText("Description");

    fireEvent.change(nameInput, { target: { value: "Updated Category" } });
    fireEvent.change(descInput, { target: { value: "Updated Description" } });

    // Save changes
    const saveButton = screen.getByText("Save Changes");
    fireEvent.click(saveButton);

    await waitFor(() => {
      expect(mockSupabase.update).toHaveBeenCalledWith(
        expect.objectContaining({
          name: "Updated Category",
          description: "Updated Description",
        }),
        expect.anything(),
      );
    });
  });
});
```

### `src\components\ui\accordion.tsx`

```tsx
"use client";

import * as React from "react";
import * as AccordionPrimitive from "@radix-ui/react-accordion";
import { ChevronDown } from "lucide-react";

import { cn } from "@/lib/utils";

const Accordion = AccordionPrimitive.Root;

const AccordionItem = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>
>(({ className, ...props }, ref) => (
  <AccordionPrimitive.Item
    ref={ref}
    className={cn("border-b", className)}
    {...props}
  />
));
AccordionItem.displayName = "AccordionItem";

const AccordionTrigger = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Header className="flex">
    <AccordionPrimitive.Trigger
      ref={ref}
      className={cn(
        "flex flex-1 items-center justify-between py-4 text-sm font-medium transition-all hover:underline text-left [&[data-state=open]>svg]:rotate-180",
        className,
      )}
      {...props}
    >
      {children}
      <ChevronDown className="h-4 w-4 shrink-0 text-muted-foreground transition-transform duration-200" />
    </AccordionPrimitive.Trigger>
  </AccordionPrimitive.Header>
));
AccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName;

const AccordionContent = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Content
    ref={ref}
    className="overflow-hidden text-sm data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down"
    {...props}
  >
    <div className={cn("pb-4 pt-0", className)}>{children}</div>
  </AccordionPrimitive.Content>
));
AccordionContent.displayName = AccordionPrimitive.Content.displayName;

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent };
```

### `src\components\ui\alert-dialog.tsx`

```tsx
"use client";

import * as React from "react";
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog";

import { cn } from "@/lib/utils";
import { buttonVariants } from "@/components/ui/button";

const AlertDialog = AlertDialogPrimitive.Root;

const AlertDialogTrigger = AlertDialogPrimitive.Trigger;

const AlertDialogPortal = AlertDialogPrimitive.Portal;

const AlertDialogOverlay = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className,
    )}
    {...props}
    ref={ref}
  />
));
AlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName;

const AlertDialogContent = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>
>(({ className, ...props }, ref) => (
  <AlertDialogPortal>
    <AlertDialogOverlay />
    <AlertDialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className,
      )}
      {...props}
    />
  </AlertDialogPortal>
));
AlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName;

const AlertDialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className,
    )}
    {...props}
  />
);
AlertDialogHeader.displayName = "AlertDialogHeader";

const AlertDialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className,
    )}
    {...props}
  />
);
AlertDialogFooter.displayName = "AlertDialogFooter";

const AlertDialogTitle = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold", className)}
    {...props}
  />
));
AlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName;

const AlertDialogDescription = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
));
AlertDialogDescription.displayName =
  AlertDialogPrimitive.Description.displayName;

const AlertDialogAction = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Action>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Action
    ref={ref}
    className={cn(buttonVariants(), className)}
    {...props}
  />
));
AlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName;

const AlertDialogCancel = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Cancel>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Cancel
    ref={ref}
    className={cn(
      buttonVariants({ variant: "outline" }),
      "mt-2 sm:mt-0",
      className,
    )}
    {...props}
  />
));
AlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName;

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
};
```

### `src\components\ui\alert.tsx`

```tsx
import * as React from "react";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const alertVariants = cva(
  "relative w-full rounded-lg border px-4 py-3 text-sm [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground [&>svg~*]:pl-7",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive:
          "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  },
);

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  />
));
Alert.displayName = "Alert";

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  />
));
AlertTitle.displayName = "AlertTitle";

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
));
AlertDescription.displayName = "AlertDescription";

export { Alert, AlertTitle, AlertDescription };
```

### `src\components\ui\aspect-ratio.tsx`

```tsx
"use client";

import * as AspectRatioPrimitive from "@radix-ui/react-aspect-ratio";

const AspectRatio = AspectRatioPrimitive.Root;

export { AspectRatio };
```

### `src\components\ui\avatar.tsx`

```tsx
import * as React from "react";
import * as AvatarPrimitive from "@radix-ui/react-avatar";
import { cn } from "src/lib/utils";

const Avatar = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full",
      className,
    )}
    {...props}
  />
));
Avatar.displayName = AvatarPrimitive.Root.displayName;

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn("aspect-square h-full w-full", className)}
    {...props}
  />
));
AvatarImage.displayName = AvatarPrimitive.Image.displayName;

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      "flex h-full w-full items-center justify-center rounded-full bg-muted",
      className,
    )}
    {...props}
  />
));
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName;

const AvatarGroup = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div">
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("flex -space-x-2", className)} {...props} />
));
AvatarGroup.displayName = "AvatarGroup";

export { Avatar, AvatarImage, AvatarFallback, AvatarGroup };
```

### `src\components\ui\badge.tsx`

```tsx
import * as React from "react";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "src/lib/utils";

const badgeVariants = cva(
  "inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground shadow hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground shadow hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  },
);

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  );
}

export { Badge, badgeVariants };
```

### `src\components\ui\bar-chart.tsx`

```tsx
"use client";

import {
  Bar,
  BarChart as RechartsBarChart,
  ResponsiveContainer,
} from "recharts";
import { cn } from "@/lib/utils";

interface BarChartProps {
  data: number[];
  className?: string;
  pathClassName?: string;
}

export function BarChart({ data, className, pathClassName }: BarChartProps) {
  const chartData = data.map((value, index) => ({ value }));

  return (
    <div className={cn("w-full h-[200px]", className)}>
      <ResponsiveContainer width="100%" height="100%">
        <RechartsBarChart data={chartData}>
          <Bar
            dataKey="value"
            radius={[4, 4, 0, 0]}
            className={cn("opacity-75", pathClassName)}
          />
        </RechartsBarChart>
      </ResponsiveContainer>
    </div>
  );
}
```

### `src\components\ui\breadcrumb.tsx`

```tsx
import { ChevronRight } from "lucide-react";
import { cn } from "@/lib/utils";

interface BreadcrumbProps {
  items: string[];
  className?: string;
}

export function Breadcrumb({ items, className }: BreadcrumbProps) {
  return (
    <nav className={cn("flex items-center space-x-1 text-sm", className)}>
      {items.map((item, index) => (
        <div key={item} className="flex items-center">
          {index > 0 && (
            <ChevronRight className="h-4 w-4 text-muted-foreground mx-1" />
          )}
          <span
            className={cn(
              "text-sm font-medium",
              index === items.length - 1
                ? "text-foreground"
                : "text-muted-foreground hover:text-foreground",
            )}
          >
            {item}
          </span>
        </div>
      ))}
    </nav>
  );
}
```

### `src\components\ui\button.tsx`

```tsx
import * as React from "react";
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";
import { cn } from "@/lib/utils";

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline:
          "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  },
);

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button";
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    );
  },
);
Button.displayName = "Button";

export { Button, buttonVariants };
```

### `src\components\ui\calendar.tsx`

```tsx
"use client";

import * as React from "react";
import { ChevronLeft, ChevronRight } from "lucide-react";
import { DayPicker } from "react-day-picker";

import { cn } from "@/lib/utils";
import { buttonVariants } from "@/components/ui/button";

export type CalendarProps = React.ComponentProps<typeof DayPicker>;

function Calendar({
  className,
  classNames,
  showOutsideDays = true,
  ...props
}: CalendarProps) {
  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={cn("p-3", className)}
      classNames={{
        months: "flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0",
        month: "space-y-4",
        caption: "flex justify-center pt-1 relative items-center",
        caption_label: "text-sm font-medium",
        nav: "space-x-1 flex items-center",
        nav_button: cn(
          buttonVariants({ variant: "outline" }),
          "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100",
        ),
        nav_button_previous: "absolute left-1",
        nav_button_next: "absolute right-1",
        table: "w-full border-collapse space-y-1",
        head_row: "flex",
        head_cell:
          "text-muted-foreground rounded-md w-9 font-normal text-[0.8rem]",
        row: "flex w-full mt-2",
        cell: "h-9 w-9 text-center text-sm p-0 relative [&:has([aria-selected])]:bg-accent first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md focus-within:relative focus-within:z-20",
        day: cn(
          buttonVariants({ variant: "ghost" }),
          "h-9 w-9 p-0 font-normal aria-selected:opacity-100",
        ),
        day_selected:
          "bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground",
        day_today: "bg-accent text-accent-foreground",
        day_outside: "text-muted-foreground opacity-50",
        day_disabled: "text-muted-foreground opacity-50",
        day_range_middle:
          "aria-selected:bg-accent aria-selected:text-accent-foreground",
        day_hidden: "invisible",
        ...classNames,
      }}
      components={{
        IconLeft: ({ ...props }) => <ChevronLeft className="h-4 w-4" />,
        IconRight: ({ ...props }) => <ChevronRight className="h-4 w-4" />,
      }}
      {...props}
    />
  );
}
Calendar.displayName = "Calendar";

export { Calendar };
```

### `src\components\ui\card.tsx`

```tsx
import * as React from "react";

import { cn } from "src/lib/utils";

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-xl border bg-background dark:bg-card text-foreground dark:text-card-foreground shadow",
      "transition-colors duration-300",
      className,
    )}
    {...props}
  />
));
Card.displayName = "Card";

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
));
CardHeader.displayName = "CardHeader";

const CardTitle = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("font-semibold leading-none tracking-tight", className)}
    {...props}
  />
));
CardTitle.displayName = "CardTitle";

const CardDescription = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
));
CardDescription.displayName = "CardDescription";

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
));
CardContent.displayName = "CardContent";

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
));
CardFooter.displayName = "CardFooter";

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardDescription,
  CardContent,
};
```

### `src\components\ui\carousel.tsx`

```tsx
"use client";

import * as React from "react";
import useEmblaCarousel, {
  type UseEmblaCarouselType,
} from "embla-carousel-react";
import { ArrowLeft, ArrowRight } from "lucide-react";

import { cn } from "@/lib/utils";
import { Button } from "@/components/ui/button";

type CarouselApi = UseEmblaCarouselType[1];
type UseCarouselParameters = Parameters<typeof useEmblaCarousel>;
type CarouselOptions = UseCarouselParameters[0];
type CarouselPlugin = UseCarouselParameters[1];

type CarouselProps = {
  opts?: CarouselOptions;
  plugins?: CarouselPlugin;
  orientation?: "horizontal" | "vertical";
  setApi?: (api: CarouselApi) => void;
};

type CarouselContextProps = {
  carouselRef: ReturnType<typeof useEmblaCarousel>[0];
  api: ReturnType<typeof useEmblaCarousel>[1];
  scrollPrev: () => void;
  scrollNext: () => void;
  canScrollPrev: boolean;
  canScrollNext: boolean;
} & CarouselProps;

const CarouselContext = React.createContext<CarouselContextProps | null>(null);

function useCarousel() {
  const context = React.useContext(CarouselContext);

  if (!context) {
    throw new Error("useCarousel must be used within a <Carousel />");
  }

  return context;
}

const Carousel = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & CarouselProps
>(
  (
    {
      orientation = "horizontal",
      opts,
      setApi,
      plugins,
      className,
      children,
      ...props
    },
    ref,
  ) => {
    const [carouselRef, api] = useEmblaCarousel(
      {
        ...opts,
        axis: orientation === "horizontal" ? "x" : "y",
      },
      plugins,
    );
    const [canScrollPrev, setCanScrollPrev] = React.useState(false);
    const [canScrollNext, setCanScrollNext] = React.useState(false);

    const onSelect = React.useCallback((api: CarouselApi) => {
      if (!api) {
        return;
      }

      setCanScrollPrev(api.canScrollPrev());
      setCanScrollNext(api.canScrollNext());
    }, []);

    const scrollPrev = React.useCallback(() => {
      api?.scrollPrev();
    }, [api]);

    const scrollNext = React.useCallback(() => {
      api?.scrollNext();
    }, [api]);

    const handleKeyDown = React.useCallback(
      (event: React.KeyboardEvent<HTMLDivElement>) => {
        if (event.key === "ArrowLeft") {
          event.preventDefault();
          scrollPrev();
        } else if (event.key === "ArrowRight") {
          event.preventDefault();
          scrollNext();
        }
      },
      [scrollPrev, scrollNext],
    );

    React.useEffect(() => {
      if (!api || !setApi) {
        return;
      }

      setApi(api);
    }, [api, setApi]);

    React.useEffect(() => {
      if (!api) {
        return;
      }

      onSelect(api);
      api.on("reInit", onSelect);
      api.on("select", onSelect);

      return () => {
        api?.off("select", onSelect);
      };
    }, [api, onSelect]);

    return (
      <CarouselContext.Provider
        value={{
          carouselRef,
          api: api,
          opts,
          orientation:
            orientation || (opts?.axis === "y" ? "vertical" : "horizontal"),
          scrollPrev,
          scrollNext,
          canScrollPrev,
          canScrollNext,
        }}
      >
        <div
          ref={ref}
          onKeyDownCapture={handleKeyDown}
          className={cn("relative", className)}
          role="region"
          aria-roledescription="carousel"
          {...props}
        >
          {children}
        </div>
      </CarouselContext.Provider>
    );
  },
);
Carousel.displayName = "Carousel";

const CarouselContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const { carouselRef, orientation } = useCarousel();

  return (
    <div ref={carouselRef} className="overflow-hidden">
      <div
        ref={ref}
        className={cn(
          "flex",
          orientation === "horizontal" ? "-ml-4" : "-mt-4 flex-col",
          className,
        )}
        {...props}
      />
    </div>
  );
});
CarouselContent.displayName = "CarouselContent";

const CarouselItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const { orientation } = useCarousel();

  return (
    <div
      ref={ref}
      role="group"
      aria-roledescription="slide"
      className={cn(
        "min-w-0 shrink-0 grow-0 basis-full",
        orientation === "horizontal" ? "pl-4" : "pt-4",
        className,
      )}
      {...props}
    />
  );
});
CarouselItem.displayName = "CarouselItem";

const CarouselPrevious = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<typeof Button>
>(({ className, variant = "outline", size = "icon", ...props }, ref) => {
  const { orientation, scrollPrev, canScrollPrev } = useCarousel();

  return (
    <Button
      ref={ref}
      variant={variant}
      size={size}
      className={cn(
        "absolute  h-8 w-8 rounded-full",
        orientation === "horizontal"
          ? "-left-12 top-1/2 -translate-y-1/2"
          : "-top-12 left-1/2 -translate-x-1/2 rotate-90",
        className,
      )}
      disabled={!canScrollPrev}
      onClick={scrollPrev}
      {...props}
    >
      <ArrowLeft className="h-4 w-4" />
      <span className="sr-only">Previous slide</span>
    </Button>
  );
});
CarouselPrevious.displayName = "CarouselPrevious";

const CarouselNext = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<typeof Button>
>(({ className, variant = "outline", size = "icon", ...props }, ref) => {
  const { orientation, scrollNext, canScrollNext } = useCarousel();

  return (
    <Button
      ref={ref}
      variant={variant}
      size={size}
      className={cn(
        "absolute h-8 w-8 rounded-full",
        orientation === "horizontal"
          ? "-right-12 top-1/2 -translate-y-1/2"
          : "-bottom-12 left-1/2 -translate-x-1/2 rotate-90",
        className,
      )}
      disabled={!canScrollNext}
      onClick={scrollNext}
      {...props}
    >
      <ArrowRight className="h-4 w-4" />
      <span className="sr-only">Next slide</span>
    </Button>
  );
});
CarouselNext.displayName = "CarouselNext";

export {
  type CarouselApi,
  Carousel,
  CarouselContent,
  CarouselItem,
  CarouselPrevious,
  CarouselNext,
};
```

### `src\components\ui\checkbox.tsx`

```tsx
"use client";

import * as React from "react";
import * as CheckboxPrimitive from "@radix-ui/react-checkbox";
import { Check } from "lucide-react";

import { cn } from "@/lib/utils";

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary shadow focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className,
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
));
Checkbox.displayName = CheckboxPrimitive.Root.displayName;

export { Checkbox };
```

### `src\components\ui\collapsible.tsx`

```tsx
"use client";

import * as CollapsiblePrimitive from "@radix-ui/react-collapsible";

const Collapsible = CollapsiblePrimitive.Root;

const CollapsibleTrigger = CollapsiblePrimitive.CollapsibleTrigger;

const CollapsibleContent = CollapsiblePrimitive.CollapsibleContent;

export { Collapsible, CollapsibleTrigger, CollapsibleContent };
```

### `src\components\ui\command.tsx`

```tsx
"use client";

import * as React from "react";
import { type DialogProps } from "@radix-ui/react-dialog";
import { Command as CommandPrimitive } from "cmdk";
import { Search } from "lucide-react";

import { cn } from "@/lib/utils";
import { Dialog, DialogContent } from "@/components/ui/dialog";

const Command = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive>
>(({ className, ...props }, ref) => (
  <CommandPrimitive
    ref={ref}
    className={cn(
      "flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground",
      className,
    )}
    {...props}
  />
));
Command.displayName = CommandPrimitive.displayName;

const CommandDialog = ({ children, ...props }: DialogProps) => {
  return (
    <Dialog {...props}>
      <DialogContent className="overflow-hidden p-0">
        <Command className="[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-group]]:px-2 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5">
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  );
};

const CommandInput = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Input>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Input>
>(({ className, ...props }, ref) => (
  <div className="flex items-center border-b px-3" cmdk-input-wrapper="">
    <Search className="mr-2 h-4 w-4 shrink-0 opacity-50" />
    <CommandPrimitive.Input
      ref={ref}
      className={cn(
        "flex h-10 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50",
        className,
      )}
      {...props}
    />
  </div>
));

CommandInput.displayName = CommandPrimitive.Input.displayName;

const CommandList = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.List>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.List
    ref={ref}
    className={cn("max-h-[300px] overflow-y-auto overflow-x-hidden", className)}
    {...props}
  />
));

CommandList.displayName = CommandPrimitive.List.displayName;

const CommandEmpty = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Empty>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Empty>
>((props, ref) => (
  <CommandPrimitive.Empty
    ref={ref}
    className="py-6 text-center text-sm"
    {...props}
  />
));

CommandEmpty.displayName = CommandPrimitive.Empty.displayName;

const CommandGroup = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Group>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Group>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Group
    ref={ref}
    className={cn(
      "overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground",
      className,
    )}
    {...props}
  />
));

CommandGroup.displayName = CommandPrimitive.Group.displayName;

const CommandSeparator = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 h-px bg-border", className)}
    {...props}
  />
));
CommandSeparator.displayName = CommandPrimitive.Separator.displayName;

const CommandItem = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Item>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default gap-2 select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[disabled=true]:pointer-events-none data-[selected=true]:bg-accent data-[selected=true]:text-accent-foreground data-[disabled=true]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      className,
    )}
    {...props}
  />
));

CommandItem.displayName = CommandPrimitive.Item.displayName;

const CommandShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className,
      )}
      {...props}
    />
  );
};
CommandShortcut.displayName = "CommandShortcut";

export {
  Command,
  CommandDialog,
  CommandInput,
  CommandList,
  CommandEmpty,
  CommandGroup,
  CommandItem,
  CommandShortcut,
  CommandSeparator,
};
```

### `src\components\ui\context-menu.tsx`

```tsx
"use client";

import * as React from "react";
import * as ContextMenuPrimitive from "@radix-ui/react-context-menu";
import { Check, ChevronRight, Circle } from "lucide-react";

import { cn } from "@/lib/utils";

const ContextMenu = ContextMenuPrimitive.Root;

const ContextMenuTrigger = ContextMenuPrimitive.Trigger;

const ContextMenuGroup = ContextMenuPrimitive.Group;

const ContextMenuPortal = ContextMenuPrimitive.Portal;

const ContextMenuSub = ContextMenuPrimitive.Sub;

const ContextMenuRadioGroup = ContextMenuPrimitive.RadioGroup;

const ContextMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubTrigger> & {
    inset?: boolean;
  }
>(({ className, inset, children, ...props }, ref) => (
  <ContextMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      inset && "pl-8",
      className,
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </ContextMenuPrimitive.SubTrigger>
));
ContextMenuSubTrigger.displayName = ContextMenuPrimitive.SubTrigger.displayName;

const ContextMenuSubContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className,
    )}
    {...props}
  />
));
ContextMenuSubContent.displayName = ContextMenuPrimitive.SubContent.displayName;

const ContextMenuContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Portal>
    <ContextMenuPrimitive.Content
      ref={ref}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className,
      )}
      {...props}
    />
  </ContextMenuPrimitive.Portal>
));
ContextMenuContent.displayName = ContextMenuPrimitive.Content.displayName;

const ContextMenuItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Item> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className,
    )}
    {...props}
  />
));
ContextMenuItem.displayName = ContextMenuPrimitive.Item.displayName;

const ContextMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <ContextMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className,
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <ContextMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.CheckboxItem>
));
ContextMenuCheckboxItem.displayName =
  ContextMenuPrimitive.CheckboxItem.displayName;

const ContextMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <ContextMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className,
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <ContextMenuPrimitive.ItemIndicator>
        <Circle className="h-4 w-4 fill-current" />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.RadioItem>
));
ContextMenuRadioItem.displayName = ContextMenuPrimitive.RadioItem.displayName;

const ContextMenuLabel = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Label> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold text-foreground",
      inset && "pl-8",
      className,
    )}
    {...props}
  />
));
ContextMenuLabel.displayName = ContextMenuPrimitive.Label.displayName;

const ContextMenuSeparator = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-border", className)}
    {...props}
  />
));
ContextMenuSeparator.displayName = ContextMenuPrimitive.Separator.displayName;

const ContextMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className,
      )}
      {...props}
    />
  );
};
ContextMenuShortcut.displayName = "ContextMenuShortcut";

export {
  ContextMenu,
  ContextMenuTrigger,
  ContextMenuContent,
  ContextMenuItem,
  ContextMenuCheckboxItem,
  ContextMenuRadioItem,
  ContextMenuLabel,
  ContextMenuSeparator,
  ContextMenuShortcut,
  ContextMenuGroup,
  ContextMenuPortal,
  ContextMenuSub,
  ContextMenuSubContent,
  ContextMenuSubTrigger,
  ContextMenuRadioGroup,
};
```

### `src\components\ui\data-table.tsx`

```tsx
import {
  ColumnDef,
  flexRender,
  getCoreRowModel,
  useReactTable,
  getPaginationRowModel,
  SortingState,
  getSortedRowModel,
  ColumnFiltersState,
  getFilteredRowModel,
} from "@tanstack/react-table";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { useState } from "react";

interface DataTableProps<TData, TValue> {
  columns: ColumnDef<TData, TValue>[];
  data: TData[];
}

export function DataTable<TData, TValue>({
  columns,
  data,
}: DataTableProps<TData, TValue>) {
  const [sorting, setSorting] = useState<SortingState>([]);
  const [columnFilters, setColumnFilters] = useState<ColumnFiltersState>([]);

  const table = useReactTable({
    data,
    columns,
    getCoreRowModel: getCoreRowModel(),
    getPaginationRowModel: getPaginationRowModel(),
    onSortingChange: setSorting,
    getSortedRowModel: getSortedRowModel(),
    onColumnFiltersChange: setColumnFilters,
    getFilteredRowModel: getFilteredRowModel(),
    state: {
      sorting,
      columnFilters,
    },
  });

  return (
    <div>
      <div className="flex items-center py-4">
        <Input
          placeholder="Filter..."
          value={
            (table.getColumn("client_name")?.getFilterValue() as string) ?? ""
          }
          onChange={(event) =>
            table.getColumn("client_name")?.setFilterValue(event.target.value)
          }
          className="max-w-sm"
        />
      </div>
      <div className="rounded-md border">
        <Table>
          <TableHeader>
            {table.getHeaderGroups().map((headerGroup) => (
              <TableRow key={headerGroup.id}>
                {headerGroup.headers.map((header) => {
                  return (
                    <TableHead key={header.id}>
                      {header.isPlaceholder
                        ? null
                        : flexRender(
                            header.column.columnDef.header,
                            header.getContext(),
                          )}
                    </TableHead>
                  );
                })}
              </TableRow>
            ))}
          </TableHeader>
          <TableBody>
            {table.getRowModel().rows?.length ? (
              table.getRowModel().rows.map((row) => (
                <TableRow
                  key={row.id}
                  data-state={row.getIsSelected() && "selected"}
                >
                  {row.getVisibleCells().map((cell) => (
                    <TableCell key={cell.id}>
                      {flexRender(
                        cell.column.columnDef.cell,
                        cell.getContext(),
                      )}
                    </TableCell>
                  ))}
                </TableRow>
              ))
            ) : (
              <TableRow>
                <TableCell
                  colSpan={columns.length}
                  className="h-24 text-center"
                >
                  No results.
                </TableCell>
              </TableRow>
            )}
          </TableBody>
        </Table>
      </div>
      <div className="flex items-center justify-end space-x-2 py-4">
        <Button
          variant="outline"
          size="sm"
          onClick={() => table.previousPage()}
          disabled={!table.getCanPreviousPage()}
        >
          Previous
        </Button>
        <Button
          variant="outline"
          size="sm"
          onClick={() => table.nextPage()}
          disabled={!table.getCanNextPage()}
        >
          Next
        </Button>
      </div>
    </div>
  );
}
```

### `src\components\ui\date-picker.tsx`

```tsx
"use client";

import * as React from "react";
import { format } from "date-fns";
import { Calendar as CalendarIcon } from "lucide-react";
import { cn } from "@/lib/utils";
import { Button } from "@/components/ui/button";
import { Calendar } from "@/components/ui/calendar";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";

interface DatePickerProps {
  value?: string | null;
  onChange?: (date: Date | undefined) => void;
  className?: string;
}

export function DatePicker({ value, onChange, className }: DatePickerProps) {
  const [date, setDate] = React.useState<Date | undefined>(
    value ? new Date(value) : undefined,
  );

  return (
    <Popover>
      <PopoverTrigger asChild>
        <Button
          variant="outline"
          className={cn(
            "w-full justify-start text-left font-normal",
            !date && "text-muted-foreground",
            className,
          )}
        >
          <CalendarIcon className="mr-2 h-4 w-4" />
          {date ? format(date, "PPP") : <span>Pick a date</span>}
        </Button>
      </PopoverTrigger>
      <PopoverContent className="w-auto p-0" align="start">
        <Calendar
          mode="single"
          selected={date}
          onSelect={(newDate) => {
            setDate(newDate);
            onChange?.(newDate);
          }}
          initialFocus
        />
      </PopoverContent>
    </Popover>
  );
}
```

### `src\components\ui\dialog.tsx`

```tsx
"use client";

import * as React from "react";
import * as DialogPrimitive from "@radix-ui/react-dialog";
import { X } from "lucide-react";

import { cn } from "@/lib/utils";

const Dialog = DialogPrimitive.Root;

const DialogTrigger = DialogPrimitive.Trigger;

const DialogPortal = DialogPrimitive.Portal;

const DialogClose = DialogPrimitive.Close;

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className,
    )}
    {...props}
  />
));
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName;

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className,
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
));
DialogContent.displayName = DialogPrimitive.Content.displayName;

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className,
    )}
    {...props}
  />
);
DialogHeader.displayName = "DialogHeader";

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className,
    )}
    {...props}
  />
);
DialogFooter.displayName = "DialogFooter";

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className,
    )}
    {...props}
  />
));
DialogTitle.displayName = DialogPrimitive.Title.displayName;

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
));
DialogDescription.displayName = DialogPrimitive.Description.displayName;

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogTrigger,
  DialogClose,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
};
```

### `src\components\ui\dropdown-menu.tsx`

```tsx
"use client";

import * as React from "react";
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu";
import { Check, ChevronRight, Circle } from "lucide-react";

import { cn } from "src/lib/utils";

const DropdownMenu = DropdownMenuPrimitive.Root;

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger;

const DropdownMenuGroup = DropdownMenuPrimitive.Group;

const DropdownMenuPortal = DropdownMenuPrimitive.Portal;

const DropdownMenuSub = DropdownMenuPrimitive.Sub;

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup;

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean;
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default gap-2 select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      inset && "pl-8",
      className,
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto" />
  </DropdownMenuPrimitive.SubTrigger>
));
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName;

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className,
    )}
    {...props}
  />
));
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName;

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md",
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className,
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
));
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName;

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&>svg]:size-4 [&>svg]:shrink-0",
      inset && "pl-8",
      className,
    )}
    {...props}
  />
));
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName;

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className,
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
));
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName;

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className,
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
));
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName;

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className,
    )}
    {...props}
  />
));
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName;

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
));
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName;

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  );
};
DropdownMenuShortcut.displayName = "DropdownMenuShortcut";

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
};
```

### `src\components\ui\due-counter.tsx`

```tsx
import { Card } from "./card";
import { cn } from "@/lib/utils";

interface DueCounterProps {
  label: string;
  count: number;
  variant?: "default" | "destructive";
}

export function DueCounter({
  label,
  count,
  variant = "default",
}: DueCounterProps) {
  return (
    <Card
      className={cn(
        "inline-flex items-center gap-2 p-2",
        variant === "destructive" &&
          "border-red-200 bg-red-50 dark:border-red-900 dark:bg-red-950",
      )}
    >
      <span
        className={cn(
          "text-2xl font-bold",
          variant === "destructive"
            ? "text-red-600 dark:text-red-400"
            : "text-foreground",
        )}
      >
        {count}
      </span>
      <span
        className={cn(
          "text-sm",
          variant === "destructive"
            ? "text-red-600 dark:text-red-400"
            : "text-muted-foreground",
        )}
      >
        {label}
      </span>
    </Card>
  );
}
```

### `src\components\ui\error-boundary.tsx`

```tsx
"use client";

import { Component, ErrorInfo, ReactNode } from "react";
import { Card, CardContent } from "./card";
import { Button } from "./button";
import { AlertCircle } from "lucide-react";

interface Props {
  children: ReactNode;
}

interface State {
  hasError: boolean;
  error: Error | null;
}

export class ErrorBoundary extends Component<Props, State> {
  public state: State = {
    hasError: false,
    error: null,
  };

  public static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error("Uncaught error:", error, errorInfo);
  }

  public render() {
    if (this.state.hasError) {
      return (
        <Card className="border-destructive">
          <CardContent className="pt-6">
            <div className="flex flex-col items-center justify-center space-y-4">
              <AlertCircle className="h-12 w-12 text-destructive" />
              <div className="text-center">
                <h2 className="text-lg font-semibold">Something went wrong</h2>
                <p className="text-sm text-muted-foreground mt-1">
                  {this.state.error?.message || "An unexpected error occurred"}
                </p>
              </div>
              <Button
                variant="outline"
                onClick={() => this.setState({ hasError: false, error: null })}
              >
                Try again
              </Button>
            </div>
          </CardContent>
        </Card>
      );
    }

    return this.props.children;
  }
}
```

### `src\components\ui\filter-dropdown.tsx`

```tsx
import { Check, ChevronDown } from "lucide-react";
import { Button } from "./button";
import {
  DropdownMenu,
  DropdownMenuCheckboxItem,
  DropdownMenuContent,
  DropdownMenuTrigger,
} from "./dropdown-menu";
import { Calendar } from "./calendar";
import { Popover, PopoverContent, PopoverTrigger } from "./popover";
import { cn } from "@/lib/utils";
import { format } from "date-fns";
import { useState } from "react";

interface FilterOption {
  label: string;
  value: string;
}

interface FilterDropdownProps {
  label: string;
  options?: FilterOption[];
  type?: "select" | "date";
  multiple?: boolean;
  value?: string | string[] | Date;
  onChange?: (value: string | string[] | Date) => void;
  className?: string;
}

export function FilterDropdown({
  label,
  options = [],
  type = "select",
  multiple = false,
  value,
  onChange,
  className,
}: FilterDropdownProps) {
  const [selectedDate, setSelectedDate] = useState<Date>();

  if (type === "date") {
    return (
      <Popover>
        <PopoverTrigger asChild>
          <Button
            variant="outline"
            className={cn(
              "justify-between min-w-[150px]",
              !selectedDate && "text-muted-foreground",
              className,
            )}
          >
            {selectedDate ? format(selectedDate, "PPP") : label}
            <ChevronDown className="ml-2 h-4 w-4" />
          </Button>
        </PopoverTrigger>
        <PopoverContent className="w-auto p-0" align="start">
          <Calendar
            mode="single"
            selected={selectedDate}
            onSelect={(date) => {
              setSelectedDate(date);
              onChange?.(date as Date);
            }}
            initialFocus
          />
        </PopoverContent>
      </Popover>
    );
  }

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button
          variant="outline"
          className={cn("justify-between min-w-[150px]", className)}
        >
          {label}
          <ChevronDown className="ml-2 h-4 w-4" />
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="start" className="w-[200px]">
        {options.map((option) => (
          <DropdownMenuCheckboxItem
            key={option.value}
            checked={
              multiple
                ? Array.isArray(value) && value.includes(option.value)
                : value === option.value
            }
            onCheckedChange={(checked) => {
              if (multiple && Array.isArray(value)) {
                const newValue = checked
                  ? [...value, option.value]
                  : value.filter((v) => v !== option.value);
                onChange?.(newValue);
              } else {
                onChange?.(checked ? option.value : "");
              }
            }}
          >
            {option.label}
          </DropdownMenuCheckboxItem>
        ))}
      </DropdownMenuContent>
    </DropdownMenu>
  );
}
```

### `src\components\ui\form.tsx`

```tsx
"use client";

import * as React from "react";
import * as LabelPrimitive from "@radix-ui/react-label";
import { Slot } from "@radix-ui/react-slot";
import {
  Controller,
  ControllerProps,
  FieldPath,
  FieldValues,
  FormProvider,
  useFormContext,
} from "react-hook-form";

import { cn } from "@/lib/utils";
import { Label } from "@/components/ui/label";

const Form = React.forwardRef<HTMLFormElement, React.ComponentProps<"form">>(
  ({ className, onSubmit, children, ...props }, ref) => {
    return (
      <form
        ref={ref}
        className={cn("space-y-8", className)}
        onSubmit={onSubmit}
        {...props}
      >
        {children}
      </form>
    );
  },
);
Form.displayName = "Form";

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
> = {
  name: TName;
};

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue,
);

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  );
};

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext);
  const itemContext = React.useContext(FormItemContext);
  const { formState } = useFormContext();

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>");
  }

  if (!itemContext) {
    throw new Error("useFormField should be used within <FormItem>");
  }

  const { id } = itemContext;

  const fieldState = {
    invalid: formState?.errors?.[fieldContext.name] ? true : false,
    isDirty: formState?.dirtyFields?.[fieldContext.name] ? true : false,
    isTouched: formState?.touchedFields?.[fieldContext.name] ? true : false,
    error: formState?.errors?.[fieldContext.name],
  };

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  };
};

type FormItemContextValue = {
  id: string;
};

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue,
);

const FormItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const id = React.useId();

  return (
    <FormItemContext.Provider value={{ id }}>
      <div ref={ref} className={cn("space-y-2", className)} {...props} />
    </FormItemContext.Provider>
  );
});
FormItem.displayName = "FormItem";

const FormLabel = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>
>(({ className, ...props }, ref) => {
  const { error, formItemId } = useFormField();

  return (
    <Label
      ref={ref}
      className={cn(error && "text-destructive", className)}
      htmlFor={formItemId}
      {...props}
    />
  );
});
FormLabel.displayName = "FormLabel";

const FormControl = React.forwardRef<
  React.ElementRef<typeof Slot>,
  React.ComponentPropsWithoutRef<typeof Slot>
>(({ ...props }, ref) => {
  const { error, formItemId, formDescriptionId, formMessageId } =
    useFormField();

  return (
    <Slot
      ref={ref}
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  );
});
FormControl.displayName = "FormControl";

const FormDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => {
  const { formDescriptionId } = useFormField();

  return (
    <p
      ref={ref}
      id={formDescriptionId}
      className={cn("text-sm text-muted-foreground", className)}
      {...props}
    />
  );
});
FormDescription.displayName = "FormDescription";

const FormMessage = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, children, ...props }, ref) => {
  const { error, formMessageId } = useFormField();
  const body = error ? String(error?.message) : children;

  if (!body) {
    return null;
  }

  return (
    <p
      ref={ref}
      id={formMessageId}
      className={cn("text-sm font-medium text-destructive", className)}
      {...props}
    >
      {body}
    </p>
  );
});
FormMessage.displayName = "FormMessage";

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
  FormFieldContext,
  FormItemContext,
  FormProvider,
};
```

### `src\components\ui\hover-card.tsx`

```tsx
"use client";

import * as React from "react";
import * as HoverCardPrimitive from "@radix-ui/react-hover-card";

import { cn } from "@/lib/utils";

const HoverCard = HoverCardPrimitive.Root;

const HoverCardTrigger = HoverCardPrimitive.Trigger;

const HoverCardContent = React.forwardRef<
  React.ElementRef<typeof HoverCardPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof HoverCardPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <HoverCardPrimitive.Content
    ref={ref}
    align={align}
    sideOffset={sideOffset}
    className={cn(
      "z-50 w-64 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className,
    )}
    {...props}
  />
));
HoverCardContent.displayName = HoverCardPrimitive.Content.displayName;

export { HoverCard, HoverCardTrigger, HoverCardContent };
```

### `src\components\ui\input.tsx`

```tsx
import * as React from "react";

import { cn } from "src/lib/utils";

const Input = React.forwardRef<HTMLInputElement, React.ComponentProps<"input">>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-base shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
          className,
        )}
        ref={ref}
        {...props}
      />
    );
  },
);
Input.displayName = "Input";

export { Input };
```

### `src\components\ui\label.tsx`

```tsx
"use client";

import * as React from "react";
import * as LabelPrimitive from "@radix-ui/react-label";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70",
);

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
));
Label.displayName = LabelPrimitive.Root.displayName;

export { Label };
```

### `src\components\ui\line-chart.tsx`

```tsx
"use client";

import {
  Line,
  LineChart as RechartsLineChart,
  ResponsiveContainer,
} from "recharts";
import { cn } from "@/lib/utils";

interface LineChartProps {
  data: number[];
  className?: string;
  pathClassName?: string;
}

export function LineChart({ data, className, pathClassName }: LineChartProps) {
  const chartData = data.map((value, index) => ({ value }));

  return (
    <div className={cn("w-full h-[200px]", className)}>
      <ResponsiveContainer width="100%" height="100%">
        <RechartsLineChart data={chartData}>
          <Line
            type="monotone"
            dataKey="value"
            stroke="currentColor"
            strokeWidth={2}
            dot={false}
            className={cn("opacity-75", pathClassName)}
          />
        </RechartsLineChart>
      </ResponsiveContainer>
    </div>
  );
}
```

### `src\components\ui\loader.tsx`

```tsx
"use client";

import { Loader2 as LucideLoader } from "lucide-react";
import { cn } from "@/lib/utils";

export { LucideLoader as Loader2 };

interface LoaderProps extends React.HTMLAttributes<HTMLDivElement> {
  size?: number;
  className?: string;
}

export function Loader({ size = 16, className, ...props }: LoaderProps) {
  return (
    <div role="status" {...props}>
      <LucideLoader
        className={cn("animate-spin text-muted-foreground", className)}
        size={size}
      />
      <span className="sr-only">Loading...</span>
    </div>
  );
}
```

### `src\components\ui\loading-spinner.tsx`

```tsx
"use client";

import { cn } from "@/lib/utils";

type SpinnerSize = "sm" | "md" | "lg" | "xl";

interface LoadingSpinnerProps {
  size?: SpinnerSize;
  className?: string;
}

const sizeClasses: Record<SpinnerSize, string> = {
  sm: "h-4 w-4 border-2",
  md: "h-6 w-6 border-2",
  lg: "h-8 w-8 border-3",
  xl: "h-12 w-12 border-4",
};

export function LoadingSpinner({
  size = "md",
  className,
}: LoadingSpinnerProps) {
  return (
    <div
      className={cn(
        "animate-spin rounded-full border-t-transparent border-primary",
        sizeClasses[size],
        className,
      )}
      role="status"
      aria-label="Loading"
    >
      <span className="sr-only">Loading...</span>
    </div>
  );
}
```

### `src\components\ui\menubar.tsx`

```tsx
"use client";

import * as React from "react";
import * as MenubarPrimitive from "@radix-ui/react-menubar";
import { Check, ChevronRight, Circle } from "lucide-react";

import { cn } from "@/lib/utils";

const MenubarMenu = MenubarPrimitive.Menu;

const MenubarGroup = MenubarPrimitive.Group;

const MenubarPortal = MenubarPrimitive.Portal;

const MenubarSub = MenubarPrimitive.Sub;

const MenubarRadioGroup = MenubarPrimitive.RadioGroup;

const Menubar = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Root
    ref={ref}
    className={cn(
      "flex h-9 items-center space-x-1 rounded-md border bg-background p-1 shadow-sm",
      className,
    )}
    {...props}
  />
));
Menubar.displayName = MenubarPrimitive.Root.displayName;

const MenubarTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-3 py-1 text-sm font-medium outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      className,
    )}
    {...props}
  />
));
MenubarTrigger.displayName = MenubarPrimitive.Trigger.displayName;

const MenubarSubTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubTrigger> & {
    inset?: boolean;
  }
>(({ className, inset, children, ...props }, ref) => (
  <MenubarPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      inset && "pl-8",
      className,
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </MenubarPrimitive.SubTrigger>
));
MenubarSubTrigger.displayName = MenubarPrimitive.SubTrigger.displayName;

const MenubarSubContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className,
    )}
    {...props}
  />
));
MenubarSubContent.displayName = MenubarPrimitive.SubContent.displayName;

const MenubarContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Content>
>(
  (
    { className, align = "start", alignOffset = -4, sideOffset = 8, ...props },
    ref,
  ) => (
    <MenubarPrimitive.Portal>
      <MenubarPrimitive.Content
        ref={ref}
        align={align}
        alignOffset={alignOffset}
        sideOffset={sideOffset}
        className={cn(
          "z-50 min-w-[12rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
          className,
        )}
        {...props}
      />
    </MenubarPrimitive.Portal>
  ),
);
MenubarContent.displayName = MenubarPrimitive.Content.displayName;

const MenubarItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Item> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className,
    )}
    {...props}
  />
));
MenubarItem.displayName = MenubarPrimitive.Item.displayName;

const MenubarCheckboxItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <MenubarPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className,
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.CheckboxItem>
));
MenubarCheckboxItem.displayName = MenubarPrimitive.CheckboxItem.displayName;

const MenubarRadioItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <MenubarPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className,
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Circle className="h-4 w-4 fill-current" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.RadioItem>
));
MenubarRadioItem.displayName = MenubarPrimitive.RadioItem.displayName;

const MenubarLabel = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Label> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className,
    )}
    {...props}
  />
));
MenubarLabel.displayName = MenubarPrimitive.Label.displayName;

const MenubarSeparator = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
));
MenubarSeparator.displayName = MenubarPrimitive.Separator.displayName;

const MenubarShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className,
      )}
      {...props}
    />
  );
};
MenubarShortcut.displayname = "MenubarShortcut";

export {
  Menubar,
  MenubarMenu,
  MenubarTrigger,
  MenubarContent,
  MenubarItem,
  MenubarSeparator,
  MenubarLabel,
  MenubarCheckboxItem,
  MenubarRadioGroup,
  MenubarRadioItem,
  MenubarPortal,
  MenubarSubContent,
  MenubarSubTrigger,
  MenubarGroup,
  MenubarSub,
  MenubarShortcut,
};
```

### `src\components\ui\multi-select.tsx`

```tsx
"use client";

import * as React from "react";
import { X } from "lucide-react";
import { Badge } from "@/components/ui/badge";
import {
  Command,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandItem,
} from "@/components/ui/command";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { cn } from "@/lib/utils";
import { Button } from "./button";

export type Option = {
  label: string;
  value: string;
};

interface MultiSelectProps {
  options: Option[];
  selected: string[];
  onChange: (values: string[]) => void;
  className?: string;
  placeholder?: string;
}

export function MultiSelect({
  options,
  selected,
  onChange,
  className,
  placeholder = "Select items...",
}: MultiSelectProps) {
  const [open, setOpen] = React.useState(false);

  const handleUnselect = (item: string) => {
    onChange(selected.filter((i) => i !== item));
  };

  return (
    <Popover open={open} onOpenChange={setOpen}>
      <PopoverTrigger asChild>
        <Button
          variant="outline"
          role="combobox"
          aria-expanded={open}
          className={cn("w-full justify-between", className)}
        >
          <div className="flex gap-1 flex-wrap">
            {selected.length === 0 && placeholder}
            {selected.map((item) => (
              <Badge
                variant="secondary"
                key={item}
                className="mr-1"
                onClick={(e) => {
                  e.stopPropagation();
                  handleUnselect(item);
                }}
              >
                {options.find((option) => option.value === item)?.label}
                <button
                  className="ml-1 ring-offset-background rounded-full outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2"
                  onKeyDown={(e) => {
                    if (e.key === "Enter") {
                      handleUnselect(item);
                    }
                  }}
                  onMouseDown={(e) => {
                    e.preventDefault();
                    e.stopPropagation();
                  }}
                  onClick={(e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    handleUnselect(item);
                  }}
                >
                  <X className="h-3 w-3 text-muted-foreground hover:text-foreground" />
                </button>
              </Badge>
            ))}
          </div>
        </Button>
      </PopoverTrigger>
      <PopoverContent className="w-full p-0">
        <Command>
          <CommandInput placeholder="Search..." />
          <CommandEmpty>No item found.</CommandEmpty>
          <CommandGroup className="max-h-64 overflow-auto">
            {options.map((option) => (
              <CommandItem
                key={option.value}
                onSelect={() => {
                  onChange(
                    selected.includes(option.value)
                      ? selected.filter((item) => item !== option.value)
                      : [...selected, option.value],
                  );
                  setOpen(true);
                }}
              >
                <div
                  className={cn(
                    "mr-2 flex h-4 w-4 items-center justify-center rounded-sm border border-primary",
                    selected.includes(option.value)
                      ? "bg-primary text-primary-foreground"
                      : "opacity-50 [&_svg]:invisible",
                  )}
                >
                  <span className="h-4 w-4 text-xs">‚úì</span>
                </div>
                {option.label}
              </CommandItem>
            ))}
          </CommandGroup>
        </Command>
      </PopoverContent>
    </Popover>
  );
}
```

### `src\components\ui\navigation-menu.tsx`

```tsx
import * as React from "react";
import * as NavigationMenuPrimitive from "@radix-ui/react-navigation-menu";
import { cva } from "class-variance-authority";
import { ChevronDown } from "lucide-react";

import { cn } from "@/lib/utils";

const NavigationMenu = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Root
    ref={ref}
    className={cn(
      "relative z-10 flex max-w-max flex-1 items-center justify-center",
      className,
    )}
    {...props}
  >
    {children}
    <NavigationMenuViewport />
  </NavigationMenuPrimitive.Root>
));
NavigationMenu.displayName = NavigationMenuPrimitive.Root.displayName;

const NavigationMenuList = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.List>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.List
    ref={ref}
    className={cn(
      "group flex flex-1 list-none items-center justify-center space-x-1",
      className,
    )}
    {...props}
  />
));
NavigationMenuList.displayName = NavigationMenuPrimitive.List.displayName;

const NavigationMenuItem = NavigationMenuPrimitive.Item;

const navigationMenuTriggerStyle = cva(
  "group inline-flex h-9 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus:outline-none disabled:pointer-events-none disabled:opacity-50 data-[active]:bg-accent/50 data-[state=open]:bg-accent/50",
);

const NavigationMenuTrigger = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Trigger
    ref={ref}
    className={cn(navigationMenuTriggerStyle(), "group", className)}
    {...props}
  >
    {children}{" "}
    <ChevronDown
      className="relative top-[1px] ml-1 h-3 w-3 transition duration-300 group-data-[state=open]:rotate-180"
      aria-hidden="true"
    />
  </NavigationMenuPrimitive.Trigger>
));
NavigationMenuTrigger.displayName = NavigationMenuPrimitive.Trigger.displayName;

const NavigationMenuContent = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Content
    ref={ref}
    className={cn(
      "left-0 top-0 w-full data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 md:absolute md:w-auto ",
      className,
    )}
    {...props}
  />
));
NavigationMenuContent.displayName = NavigationMenuPrimitive.Content.displayName;

const NavigationMenuLink = NavigationMenuPrimitive.Link;

const NavigationMenuViewport = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Viewport>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Viewport>
>(({ className, ...props }, ref) => (
  <div className={cn("absolute left-0 top-full flex justify-center")}>
    <NavigationMenuPrimitive.Viewport
      className={cn(
        "origin-top-center relative mt-1.5 h-[var(--radix-navigation-menu-viewport-height)] w-full overflow-hidden rounded-md border bg-popover text-popover-foreground shadow data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 md:w-[var(--radix-navigation-menu-viewport-width)]",
        className,
      )}
      ref={ref}
      {...props}
    />
  </div>
));
NavigationMenuViewport.displayName =
  NavigationMenuPrimitive.Viewport.displayName;

const NavigationMenuIndicator = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Indicator>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Indicator>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Indicator
    ref={ref}
    className={cn(
      "top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden data-[state=visible]:animate-in data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:fade-in",
      className,
    )}
    {...props}
  >
    <div className="relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm bg-border shadow-md" />
  </NavigationMenuPrimitive.Indicator>
));
NavigationMenuIndicator.displayName =
  NavigationMenuPrimitive.Indicator.displayName;

export {
  navigationMenuTriggerStyle,
  NavigationMenu,
  NavigationMenuList,
  NavigationMenuItem,
  NavigationMenuContent,
  NavigationMenuTrigger,
  NavigationMenuLink,
  NavigationMenuIndicator,
  NavigationMenuViewport,
};
```

### `src\components\ui\pagination.tsx`

```tsx
"use client";

import { useEffect } from "react";
import { Button } from "./button";
import { ChevronLeft, ChevronRight } from "lucide-react";

interface PaginationProps {
  currentPage: number;
  totalPages: number;
  onPageChange: (page: number) => void;
  onNextPage?: () => void;
}

export function Pagination({
  currentPage,
  totalPages,
  onPageChange,
  onNextPage,
}: PaginationProps) {
  useEffect(() => {
    if (currentPage < totalPages && onNextPage) {
      onNextPage();
    }
  }, [currentPage, totalPages, onNextPage]);

  const pages = Array.from({ length: totalPages }, (_, i) => i + 1);
  const visiblePages = pages.filter((page) => {
    if (totalPages <= 7) return true;
    if (page === 1 || page === totalPages) return true;
    if (page >= currentPage - 1 && page <= currentPage + 1) return true;
    return false;
  });

  const renderPageButton = (page: number) => (
    <Button
      key={page}
      variant={page === currentPage ? "default" : "outline"}
      size="icon"
      onClick={() => onPageChange(page)}
      disabled={page === currentPage}
    >
      {page}
    </Button>
  );

  return (
    <div className="flex justify-center items-center gap-2">
      <Button
        variant="outline"
        size="icon"
        onClick={() => onPageChange(currentPage - 1)}
        disabled={currentPage === 1}
      >
        <ChevronLeft className="h-4 w-4" />
      </Button>

      {visiblePages.map((page, index, array) => {
        if (index > 0 && page - array[index - 1] > 1) {
          return (
            <div key={`ellipsis-${page}`} className="flex items-center gap-2">
              <span className="text-muted-foreground">...</span>
              {renderPageButton(page)}
            </div>
          );
        }
        return renderPageButton(page);
      })}

      <Button
        variant="outline"
        size="icon"
        onClick={() => onPageChange(currentPage + 1)}
        disabled={currentPage === totalPages}
      >
        <ChevronRight className="h-4 w-4" />
      </Button>
    </div>
  );
}
```

### `src\components\ui\popover.tsx`

```tsx
"use client";

import * as React from "react";
import * as PopoverPrimitive from "@radix-ui/react-popover";

import { cn } from "@/lib/utils";

const Popover = PopoverPrimitive.Root;

const PopoverTrigger = PopoverPrimitive.Trigger;

const PopoverAnchor = PopoverPrimitive.Anchor;

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className,
      )}
      {...props}
    />
  </PopoverPrimitive.Portal>
));
PopoverContent.displayName = PopoverPrimitive.Content.displayName;

export { Popover, PopoverTrigger, PopoverContent, PopoverAnchor };
```

### `src\components\ui\priority-select.tsx`

```tsx
import * as React from "react";
import { useController, UseControllerProps } from "react-hook-form";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "./select";
import { FormControl, FormLabel, FormMessage, FormItem } from "./form";
import { Database } from "@/types/database.types";

type Priority = Database["public"]["Enums"]["task_priority"];

interface PrioritySelectProps<TFieldValues>
  extends UseControllerProps<TFieldValues> {
  label?: string;
  placeholder?: string;
}

/**
 * Reusable PrioritySelect component
 */
export function PrioritySelect<TFieldValues>({
  name,
  control,
  label = "Priority",
  placeholder = "Select priority",
}: PrioritySelectProps<TFieldValues>) {
  const { field, fieldState } = useController({ name, control });
  const priorityOptions: Priority[] = ["low", "medium", "high", "urgent"];

  return (
    <FormItem>
      {label && <FormLabel>{label}</FormLabel>}
      <FormControl>
        <Select
          onValueChange={field.onChange}
          value={field.value as string}
          defaultValue={field.value as string}
        >
          <SelectTrigger>
            <SelectValue placeholder={placeholder} />
          </SelectTrigger>
          <SelectContent>
            {priorityOptions.map((priority) => (
              <SelectItem key={priority} value={priority}>
                {priority.charAt(0).toUpperCase() + priority.slice(1)}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
      </FormControl>
      <FormMessage>{fieldState.error?.message}</FormMessage>
    </FormItem>
  );
}
```

### `src\components\ui\progress.tsx`

```tsx
"use client";

import * as React from "react";
import * as ProgressPrimitive from "@radix-ui/react-progress";

import { cn } from "src/lib/utils";

const Progress = React.forwardRef<
  React.ElementRef<typeof ProgressPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>
>(({ className, value, ...props }, ref) => (
  <ProgressPrimitive.Root
    ref={ref}
    className={cn(
      "relative h-2 w-full overflow-hidden rounded-full bg-primary/20",
      className,
    )}
    {...props}
  >
    <ProgressPrimitive.Indicator
      className="h-full w-full flex-1 bg-primary transition-all"
      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
    />
  </ProgressPrimitive.Root>
));
Progress.displayName = ProgressPrimitive.Root.displayName;

export { Progress };
```

### `src\components\ui\radio-group.tsx`

```tsx
"use client";

import * as React from "react";
import * as RadioGroupPrimitive from "@radix-ui/react-radio-group";
import { Circle } from "lucide-react";

import { cn } from "@/lib/utils";

const RadioGroup = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Root>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Root
      className={cn("grid gap-2", className)}
      {...props}
      ref={ref}
    />
  );
});
RadioGroup.displayName = RadioGroupPrimitive.Root.displayName;

const RadioGroupItem = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Item>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Item
      ref={ref}
      className={cn(
        "aspect-square h-4 w-4 rounded-full border border-primary text-primary shadow focus:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50",
        className,
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator className="flex items-center justify-center">
        <Circle className="h-3.5 w-3.5 fill-primary" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  );
});
RadioGroupItem.displayName = RadioGroupPrimitive.Item.displayName;

export { RadioGroup, RadioGroupItem };
```

### `src\components\ui\scroll-area.tsx`

```tsx
"use client";

import * as React from "react";
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area";

import { cn } from "src/lib/utils";

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
));
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName;

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
        "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
        "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className,
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
));
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName;

export { ScrollArea, ScrollBar };
```

### `src\components\ui\select.tsx`

```tsx
"use client";

import * as React from "react";
import * as SelectPrimitive from "@radix-ui/react-select";
import { Check, ChevronDown, ChevronUp } from "lucide-react";

import { cn } from "src/lib/utils";

const Select = SelectPrimitive.Root;

const SelectGroup = SelectPrimitive.Group;

const SelectValue = SelectPrimitive.Value;

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-9 w-full items-center justify-between whitespace-nowrap rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-1 focus:ring-ring disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className,
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
));
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName;

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className,
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
));
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName;

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className,
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
));
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName;

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className,
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]",
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
));
SelectContent.displayName = SelectPrimitive.Content.displayName;

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("px-2 py-1.5 text-sm font-semibold", className)}
    {...props}
  />
));
SelectLabel.displayName = SelectPrimitive.Label.displayName;

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-2 pr-8 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className,
    )}
    {...props}
  >
    <span className="absolute right-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>
    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
));
SelectItem.displayName = SelectPrimitive.Item.displayName;

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
));
SelectSeparator.displayName = SelectPrimitive.Separator.displayName;

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
};
```

### `src\components\ui\separator.tsx`

```tsx
"use client";

import * as React from "react";
import * as SeparatorPrimitive from "@radix-ui/react-separator";

import { cn } from "@/lib/utils";

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = "horizontal", decorative = true, ...props },
    ref,
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "shrink-0 bg-border",
        orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
        className,
      )}
      {...props}
    />
  ),
);
Separator.displayName = SeparatorPrimitive.Root.displayName;

export { Separator };
```

### `src\components\ui\sheet.tsx`

```tsx
"use client";

import * as React from "react";
import * as SheetPrimitive from "@radix-ui/react-dialog";
import { cva, type VariantProps } from "class-variance-authority";
import { X } from "lucide-react";

import { cn } from "@/lib/utils";

const Sheet = SheetPrimitive.Root;

const SheetTrigger = SheetPrimitive.Trigger;

const SheetClose = SheetPrimitive.Close;

const SheetPortal = SheetPrimitive.Portal;

const SheetOverlay = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className,
    )}
    {...props}
    ref={ref}
  />
));
SheetOverlay.displayName = SheetPrimitive.Overlay.displayName;

const sheetVariants = cva(
  "fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500 data-[state=open]:animate-in data-[state=closed]:animate-out",
  {
    variants: {
      side: {
        top: "inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
        bottom:
          "inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
        left: "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
        right:
          "inset-y-0 right-0 h-full w-3/4 border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm",
      },
    },
    defaultVariants: {
      side: "right",
    },
  },
);

interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,
    VariantProps<typeof sheetVariants> {}

const SheetContent = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Content>,
  SheetContentProps
>(({ side = "right", className, children, ...props }, ref) => (
  <SheetPortal>
    <SheetOverlay />
    <SheetPrimitive.Content
      ref={ref}
      className={cn(sheetVariants({ side }), className)}
      {...props}
    >
      <SheetPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </SheetPrimitive.Close>
      {children}
    </SheetPrimitive.Content>
  </SheetPortal>
));
SheetContent.displayName = SheetPrimitive.Content.displayName;

const SheetHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className,
    )}
    {...props}
  />
);
SheetHeader.displayName = "SheetHeader";

const SheetFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className,
    )}
    {...props}
  />
);
SheetFooter.displayName = "SheetFooter";

const SheetTitle = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold text-foreground", className)}
    {...props}
  />
));
SheetTitle.displayName = SheetPrimitive.Title.displayName;

const SheetDescription = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
));
SheetDescription.displayName = SheetPrimitive.Description.displayName;

export {
  Sheet,
  SheetPortal,
  SheetOverlay,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
};
```

### `src\components\ui\sidebar.tsx`

```tsx
"use client";

import * as React from "react";
import { Slot } from "@radix-ui/react-slot";
import { VariantProps, cva } from "class-variance-authority";
import { PanelLeft } from "lucide-react";

import { useIsMobile } from "@/hooks/use-mobile";
import { cn } from "@/lib/utils";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Separator } from "@/components/ui/separator";
import { Sheet, SheetContent } from "@/components/ui/sheet";
import { Skeleton } from "@/components/ui/skeleton";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";

const SIDEBAR_COOKIE_NAME = "sidebar:state";
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7;
const SIDEBAR_WIDTH = "16rem";
const SIDEBAR_WIDTH_MOBILE = "18rem";
const SIDEBAR_WIDTH_ICON = "3rem";
const SIDEBAR_KEYBOARD_SHORTCUT = "b";

type SidebarContext = {
  state: "expanded" | "collapsed";
  open: boolean;
  setOpen: (open: boolean) => void;
  openMobile: boolean;
  setOpenMobile: (open: boolean) => void;
  isMobile: boolean;
  toggleSidebar: () => void;
};

const SidebarContext = React.createContext<SidebarContext | null>(null);

function useSidebar() {
  const context = React.useContext(SidebarContext);
  if (!context) {
    throw new Error("useSidebar must be used within a SidebarProvider.");
  }

  return context;
}

const SidebarProvider = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    defaultOpen?: boolean;
    open?: boolean;
    onOpenChange?: (open: boolean) => void;
  }
>(
  (
    {
      defaultOpen = true,
      open: openProp,
      onOpenChange: setOpenProp,
      className,
      style,
      children,
      ...props
    },
    ref,
  ) => {
    const isMobile = useIsMobile();
    const [openMobile, setOpenMobile] = React.useState(false);

    // This is the internal state of the sidebar.
    // We use openProp and setOpenProp for control from outside the component.
    const [_open, _setOpen] = React.useState(defaultOpen);
    const open = openProp ?? _open;
    const setOpen = React.useCallback(
      (value: boolean | ((value: boolean) => boolean)) => {
        const openState = typeof value === "function" ? value(open) : value;
        if (setOpenProp) {
          setOpenProp(openState);
        } else {
          _setOpen(openState);
        }

        // This sets the cookie to keep the sidebar state.
        document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`;
      },
      [setOpenProp, open],
    );

    // Helper to toggle the sidebar.
    const toggleSidebar = React.useCallback(() => {
      return isMobile
        ? setOpenMobile((open) => !open)
        : setOpen((open) => !open);
    }, [isMobile, setOpen, setOpenMobile]);

    // Adds a keyboard shortcut to toggle the sidebar.
    React.useEffect(() => {
      const handleKeyDown = (event: KeyboardEvent) => {
        if (
          event.key === SIDEBAR_KEYBOARD_SHORTCUT &&
          (event.metaKey || event.ctrlKey)
        ) {
          event.preventDefault();
          toggleSidebar();
        }
      };

      window.addEventListener("keydown", handleKeyDown);
      return () => window.removeEventListener("keydown", handleKeyDown);
    }, [toggleSidebar]);

    // We add a state so that we can do data-state="expanded" or "collapsed".
    // This makes it easier to style the sidebar with Tailwind classes.
    const state = open ? "expanded" : "collapsed";

    const contextValue = React.useMemo<SidebarContext>(
      () => ({
        state,
        open,
        setOpen,
        isMobile,
        openMobile,
        setOpenMobile,
        toggleSidebar,
      }),
      [
        state,
        open,
        setOpen,
        isMobile,
        openMobile,
        setOpenMobile,
        toggleSidebar,
      ],
    );

    return (
      <SidebarContext.Provider value={contextValue}>
        <TooltipProvider delayDuration={0}>
          <div
            style={
              {
                "--sidebar-width": SIDEBAR_WIDTH,
                "--sidebar-width-icon": SIDEBAR_WIDTH_ICON,
                ...style,
              } as React.CSSProperties
            }
            className={cn(
              "group/sidebar-wrapper flex min-h-svh w-full has-[[data-variant=inset]]:bg-sidebar",
              className,
            )}
            ref={ref}
            {...props}
          >
            {children}
          </div>
        </TooltipProvider>
      </SidebarContext.Provider>
    );
  },
);
SidebarProvider.displayName = "SidebarProvider";

const Sidebar = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    side?: "left" | "right";
    variant?: "sidebar" | "floating" | "inset";
    collapsible?: "offcanvas" | "icon" | "none";
  }
>(
  (
    {
      side = "left",
      variant = "sidebar",
      collapsible = "offcanvas",
      className,
      children,
      ...props
    },
    ref,
  ) => {
    const { isMobile, state, openMobile, setOpenMobile } = useSidebar();

    if (collapsible === "none") {
      return (
        <div
          className={cn(
            "flex h-full w-[--sidebar-width] flex-col bg-sidebar text-sidebar-foreground",
            className,
          )}
          ref={ref}
          {...props}
        >
          {children}
        </div>
      );
    }

    if (isMobile) {
      return (
        <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>
          <SheetContent
            data-sidebar="sidebar"
            data-mobile="true"
            className="w-[--sidebar-width] bg-sidebar p-0 text-sidebar-foreground [&>button]:hidden"
            style={
              {
                "--sidebar-width": SIDEBAR_WIDTH_MOBILE,
              } as React.CSSProperties
            }
            side={side}
          >
            <div className="flex h-full w-full flex-col">{children}</div>
          </SheetContent>
        </Sheet>
      );
    }

    return (
      <div
        ref={ref}
        className="group peer hidden md:block text-sidebar-foreground"
        data-state={state}
        data-collapsible={state === "collapsed" ? collapsible : ""}
        data-variant={variant}
        data-side={side}
      >
        {/* This is what handles the sidebar gap on desktop */}
        <div
          className={cn(
            "duration-200 relative h-svh w-[--sidebar-width] bg-transparent transition-[width] ease-linear",
            "group-data-[collapsible=offcanvas]:w-0",
            "group-data-[side=right]:rotate-180",
            variant === "floating" || variant === "inset"
              ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4))]"
              : "group-data-[collapsible=icon]:w-[--sidebar-width-icon]",
          )}
        />
        <div
          className={cn(
            "duration-200 fixed inset-y-0 z-10 hidden h-svh w-[--sidebar-width] transition-[left,right,width] ease-linear md:flex",
            side === "left"
              ? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]"
              : "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]",
            // Adjust the padding for floating and inset variants.
            variant === "floating" || variant === "inset"
              ? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4)_+2px)]"
              : "group-data-[collapsible=icon]:w-[--sidebar-width-icon] group-data-[side=left]:border-r group-data-[side=right]:border-l",
            className,
          )}
          {...props}
        >
          <div
            data-sidebar="sidebar"
            className="flex h-full w-full flex-col bg-sidebar group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:border-sidebar-border group-data-[variant=floating]:shadow"
          >
            {children}
          </div>
        </div>
      </div>
    );
  },
);
Sidebar.displayName = "Sidebar";

const SidebarTrigger = React.forwardRef<
  React.ElementRef<typeof Button>,
  React.ComponentProps<typeof Button>
>(({ className, onClick, ...props }, ref) => {
  const { toggleSidebar } = useSidebar();

  return (
    <Button
      ref={ref}
      data-sidebar="trigger"
      variant="ghost"
      size="icon"
      className={cn("h-7 w-7", className)}
      onClick={(event) => {
        onClick?.(event);
        toggleSidebar();
      }}
      {...props}
    >
      <PanelLeft />
      <span className="sr-only">Toggle Sidebar</span>
    </Button>
  );
});
SidebarTrigger.displayName = "SidebarTrigger";

const SidebarRail = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button">
>(({ className, ...props }, ref) => {
  const { toggleSidebar } = useSidebar();

  return (
    <button
      ref={ref}
      data-sidebar="rail"
      aria-label="Toggle Sidebar"
      tabIndex={-1}
      onClick={toggleSidebar}
      title="Toggle Sidebar"
      className={cn(
        "absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] hover:after:bg-sidebar-border group-data-[side=left]:-right-4 group-data-[side=right]:left-0 sm:flex",
        "[[data-side=left]_&]:cursor-w-resize [[data-side=right]_&]:cursor-e-resize",
        "[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize",
        "group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full group-data-[collapsible=offcanvas]:hover:bg-sidebar",
        "[[data-side=left][data-collapsible=offcanvas]_&]:-right-2",
        "[[data-side=right][data-collapsible=offcanvas]_&]:-left-2",
        className,
      )}
      {...props}
    />
  );
});
SidebarRail.displayName = "SidebarRail";

const SidebarInset = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"main">
>(({ className, ...props }, ref) => {
  return (
    <main
      ref={ref}
      className={cn(
        "relative flex min-h-svh flex-1 flex-col bg-background",
        "peer-data-[variant=inset]:min-h-[calc(100svh-theme(spacing.4))] md:peer-data-[variant=inset]:m-2 md:peer-data-[state=collapsed]:peer-data-[variant=inset]:ml-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow",
        className,
      )}
      {...props}
    />
  );
});
SidebarInset.displayName = "SidebarInset";

const SidebarInput = React.forwardRef<
  React.ElementRef<typeof Input>,
  React.ComponentProps<typeof Input>
>(({ className, ...props }, ref) => {
  return (
    <Input
      ref={ref}
      data-sidebar="input"
      className={cn(
        "h-8 w-full bg-background shadow-none focus-visible:ring-2 focus-visible:ring-sidebar-ring",
        className,
      )}
      {...props}
    />
  );
});
SidebarInput.displayName = "SidebarInput";

const SidebarHeader = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="header"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  );
});
SidebarHeader.displayName = "SidebarHeader";

const SidebarFooter = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="footer"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  );
});
SidebarFooter.displayName = "SidebarFooter";

const SidebarSeparator = React.forwardRef<
  React.ElementRef<typeof Separator>,
  React.ComponentProps<typeof Separator>
>(({ className, ...props }, ref) => {
  return (
    <Separator
      ref={ref}
      data-sidebar="separator"
      className={cn("mx-2 w-auto bg-sidebar-border", className)}
      {...props}
    />
  );
});
SidebarSeparator.displayName = "SidebarSeparator";

const SidebarContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="content"
      className={cn(
        "flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden",
        className,
      )}
      {...props}
    />
  );
});
SidebarContent.displayName = "SidebarContent";

const SidebarGroup = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="group"
      className={cn("relative flex w-full min-w-0 flex-col p-2", className)}
      {...props}
    />
  );
});
SidebarGroup.displayName = "SidebarGroup";

const SidebarGroupLabel = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & { asChild?: boolean }
>(({ className, asChild = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "div";

  return (
    <Comp
      ref={ref}
      data-sidebar="group-label"
      className={cn(
        "duration-200 flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium text-sidebar-foreground/70 outline-none ring-sidebar-ring transition-[margin,opa] ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        "group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0",
        className,
      )}
      {...props}
    />
  );
});
SidebarGroupLabel.displayName = "SidebarGroupLabel";

const SidebarGroupAction = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & { asChild?: boolean }
>(({ className, asChild = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "button";

  return (
    <Comp
      ref={ref}
      data-sidebar="group-action"
      className={cn(
        "absolute right-3 top-3.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 after:md:hidden",
        "group-data-[collapsible=icon]:hidden",
        className,
      )}
      {...props}
    />
  );
});
SidebarGroupAction.displayName = "SidebarGroupAction";

const SidebarGroupContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    data-sidebar="group-content"
    className={cn("w-full text-sm", className)}
    {...props}
  />
));
SidebarGroupContent.displayName = "SidebarGroupContent";

const SidebarMenu = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    data-sidebar="menu"
    className={cn("flex w-full min-w-0 flex-col gap-1", className)}
    {...props}
  />
));
SidebarMenu.displayName = "SidebarMenu";

const SidebarMenuItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ className, ...props }, ref) => (
  <li
    ref={ref}
    data-sidebar="menu-item"
    className={cn("group/menu-item relative", className)}
    {...props}
  />
));
SidebarMenuItem.displayName = "SidebarMenuItem";

const sidebarMenuButtonVariants = cva(
  "peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-none ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-[[data-sidebar=menu-action]]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:!size-8 group-data-[collapsible=icon]:!p-2 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
        outline:
          "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]",
      },
      size: {
        default: "h-8 text-sm",
        sm: "h-7 text-xs",
        lg: "h-12 text-sm group-data-[collapsible=icon]:!p-0",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  },
);

const SidebarMenuButton = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & {
    asChild?: boolean;
    isActive?: boolean;
    tooltip?: string | React.ComponentProps<typeof TooltipContent>;
  } & VariantProps<typeof sidebarMenuButtonVariants>
>(
  (
    {
      asChild = false,
      isActive = false,
      variant = "default",
      size = "default",
      tooltip,
      className,
      ...props
    },
    ref,
  ) => {
    const Comp = asChild ? Slot : "button";
    const { isMobile, state } = useSidebar();

    const button = (
      <Comp
        ref={ref}
        data-sidebar="menu-button"
        data-size={size}
        data-active={isActive}
        className={cn(sidebarMenuButtonVariants({ variant, size }), className)}
        {...props}
      />
    );

    if (!tooltip) {
      return button;
    }

    if (typeof tooltip === "string") {
      tooltip = {
        children: tooltip,
      };
    }

    return (
      <Tooltip>
        <TooltipTrigger asChild>{button}</TooltipTrigger>
        <TooltipContent
          side="right"
          align="center"
          hidden={state !== "collapsed" || isMobile}
          {...tooltip}
        />
      </Tooltip>
    );
  },
);
SidebarMenuButton.displayName = "SidebarMenuButton";

const SidebarMenuAction = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & {
    asChild?: boolean;
    showOnHover?: boolean;
  }
>(({ className, asChild = false, showOnHover = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "button";

  return (
    <Comp
      ref={ref}
      data-sidebar="menu-action"
      className={cn(
        "absolute right-1 top-1.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 peer-hover/menu-button:text-sidebar-accent-foreground [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 after:md:hidden",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        showOnHover &&
          "group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 peer-data-[active=true]/menu-button:text-sidebar-accent-foreground md:opacity-0",
        className,
      )}
      {...props}
    />
  );
});
SidebarMenuAction.displayName = "SidebarMenuAction";

const SidebarMenuBadge = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    data-sidebar="menu-badge"
    className={cn(
      "absolute right-1 flex h-5 min-w-5 items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums text-sidebar-foreground select-none pointer-events-none",
      "peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground",
      "peer-data-[size=sm]/menu-button:top-1",
      "peer-data-[size=default]/menu-button:top-1.5",
      "peer-data-[size=lg]/menu-button:top-2.5",
      "group-data-[collapsible=icon]:hidden",
      className,
    )}
    {...props}
  />
));
SidebarMenuBadge.displayName = "SidebarMenuBadge";

const SidebarMenuSkeleton = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    showIcon?: boolean;
  }
>(({ className, showIcon = false, ...props }, ref) => {
  // Random width between 50 to 90%.
  const width = React.useMemo(() => {
    return `${Math.floor(Math.random() * 40) + 50}%`;
  }, []);

  return (
    <div
      ref={ref}
      data-sidebar="menu-skeleton"
      className={cn("rounded-md h-8 flex gap-2 px-2 items-center", className)}
      {...props}
    >
      {showIcon && (
        <Skeleton
          className="size-4 rounded-md"
          data-sidebar="menu-skeleton-icon"
        />
      )}
      <Skeleton
        className="h-4 flex-1 max-w-[--skeleton-width]"
        data-sidebar="menu-skeleton-text"
        style={
          {
            "--skeleton-width": width,
          } as React.CSSProperties
        }
      />
    </div>
  );
});
SidebarMenuSkeleton.displayName = "SidebarMenuSkeleton";

const SidebarMenuSub = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    data-sidebar="menu-sub"
    className={cn(
      "mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l border-sidebar-border px-2.5 py-0.5",
      "group-data-[collapsible=icon]:hidden",
      className,
    )}
    {...props}
  />
));
SidebarMenuSub.displayName = "SidebarMenuSub";

const SidebarMenuSubItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ ...props }, ref) => <li ref={ref} {...props} />);
SidebarMenuSubItem.displayName = "SidebarMenuSubItem";

const SidebarMenuSubButton = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentProps<"a"> & {
    asChild?: boolean;
    size?: "sm" | "md";
    isActive?: boolean;
  }
>(({ asChild = false, size = "md", isActive, className, ...props }, ref) => {
  const Comp = asChild ? Slot : "a";

  return (
    <Comp
      ref={ref}
      data-sidebar="menu-sub-button"
      data-size={size}
      data-active={isActive}
      className={cn(
        "flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 text-sidebar-foreground outline-none ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0 [&>svg]:text-sidebar-accent-foreground",
        "data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground",
        size === "sm" && "text-xs",
        size === "md" && "text-sm",
        "group-data-[collapsible=icon]:hidden",
        className,
      )}
      {...props}
    />
  );
});
SidebarMenuSubButton.displayName = "SidebarMenuSubButton";

export {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarInput,
  SidebarInset,
  SidebarMenu,
  SidebarMenuAction,
  SidebarMenuBadge,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarMenuSkeleton,
  SidebarMenuSub,
  SidebarMenuSubButton,
  SidebarMenuSubItem,
  SidebarProvider,
  SidebarRail,
  SidebarSeparator,
  SidebarTrigger,
  useSidebar,
};
```

### `src\components\ui\skeleton.tsx`

```tsx
import { cn } from "@/lib/utils";

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-primary/10", className)}
      {...props}
    />
  );
}

export { Skeleton };
```

### `src\components\ui\slider.tsx`

```tsx
"use client";

import * as React from "react";
import * as SliderPrimitive from "@radix-ui/react-slider";

import { cn } from "@/lib/utils";

const Slider = React.forwardRef<
  React.ElementRef<typeof SliderPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root>
>(({ className, ...props }, ref) => (
  <SliderPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex w-full touch-none select-none items-center",
      className,
    )}
    {...props}
  >
    <SliderPrimitive.Track className="relative h-1.5 w-full grow overflow-hidden rounded-full bg-primary/20">
      <SliderPrimitive.Range className="absolute h-full bg-primary" />
    </SliderPrimitive.Track>
    <SliderPrimitive.Thumb className="block h-4 w-4 rounded-full border border-primary/50 bg-background shadow transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50" />
  </SliderPrimitive.Root>
));
Slider.displayName = SliderPrimitive.Root.displayName;

export { Slider };
```

### `src\components\ui\status-select.tsx`

```tsx
import * as React from "react";
import { useController, UseControllerProps } from "react-hook-form";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "./select";
import { FormControl, FormLabel, FormMessage, FormItem } from "./form";
import { Database } from "@/types/database.types";

type Status = Database["public"]["Enums"]["task_status"];

interface StatusSelectProps<TFieldValues>
  extends UseControllerProps<TFieldValues> {
  label?: string;
  placeholder?: string;
}

/**
 * Reusable StatusSelect component
 */
export function StatusSelect<TFieldValues>({
  name,
  control,
  label = "Status",
  placeholder = "Select status",
}: StatusSelectProps<TFieldValues>) {
  const { field, fieldState } = useController({ name, control });
  const statusOptions: Status[] = [
    "todo",
    "in_progress",
    "review",
    "completed",
  ];

  return (
    <FormItem>
      {label && <FormLabel>{label}</FormLabel>}
      <FormControl>
        <Select
          onValueChange={field.onChange}
          value={field.value as string}
          defaultValue={field.value as string}
        >
          <SelectTrigger>
            <SelectValue placeholder={placeholder} />
          </SelectTrigger>
          <SelectContent>
            {statusOptions.map((status) => (
              <SelectItem key={status} value={status}>
                {status
                  .replace(/_/g, " ")
                  .replace(/\b\w/g, (l) => l.toUpperCase())}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
      </FormControl>
      <FormMessage>{fieldState.error?.message}</FormMessage>
    </FormItem>
  );
}
```

### `src\components\ui\switch.tsx`

```tsx
"use client";

import * as React from "react";
import * as SwitchPrimitives from "@radix-ui/react-switch";

import { cn } from "@/lib/utils";

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-5 w-9 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      className,
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-4 w-4 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-4 data-[state=unchecked]:translate-x-0",
      )}
    />
  </SwitchPrimitives.Root>
));
Switch.displayName = SwitchPrimitives.Root.displayName;

export { Switch };
```

### `src\components\ui\table.tsx`

```tsx
import * as React from "react";

import { cn } from "src/lib/utils";

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-auto">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
  </div>
));
Table.displayName = "Table";

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />
));
TableHeader.displayName = "TableHeader";

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
));
TableBody.displayName = "TableBody";

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
      className,
    )}
    {...props}
  />
));
TableFooter.displayName = "TableFooter";

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      className,
    )}
    {...props}
  />
));
TableRow.displayName = "TableRow";

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-10 px-2 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
      className,
    )}
    {...props}
  />
));
TableHead.displayName = "TableHead";

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn(
      "p-2 align-middle [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
      className,
    )}
    {...props}
  />
));
TableCell.displayName = "TableCell";

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-muted-foreground", className)}
    {...props}
  />
));
TableCaption.displayName = "TableCaption";

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
};
```

### `src\components\ui\tabs.tsx`

```tsx
"use client";

import * as React from "react";
import * as TabsPrimitive from "@radix-ui/react-tabs";

import { cn } from "src/lib/utils";

const Tabs = TabsPrimitive.Root;

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-9 items-center justify-center rounded-lg bg-muted p-1 text-muted-foreground",
      className,
    )}
    {...props}
  />
));
TabsList.displayName = TabsPrimitive.List.displayName;

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-md px-3 py-1 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow",
      className,
    )}
    {...props}
  />
));
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName;

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className,
    )}
    {...props}
  />
));
TabsContent.displayName = TabsPrimitive.Content.displayName;

export { Tabs, TabsList, TabsTrigger, TabsContent };
```

### `src\components\ui\textarea.tsx`

```tsx
import * as React from "react";

import { cn } from "src/lib/utils";

const Textarea = React.forwardRef<
  HTMLTextAreaElement,
  React.ComponentProps<"textarea">
>(({ className, ...props }, ref) => {
  return (
    <textarea
      className={cn(
        "flex min-h-[60px] w-full rounded-md border border-input bg-transparent px-3 py-2 text-base shadow-sm placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className,
      )}
      ref={ref}
      {...props}
    />
  );
});
Textarea.displayName = "Textarea";

export { Textarea };
```

### `src\components\ui\toast.tsx`

```tsx
"use client";

import * as React from "react";
import * as ToastPrimitives from "@radix-ui/react-toast";
import { cva, type VariantProps } from "class-variance-authority";
import { X } from "lucide-react";

import { cn } from "src/lib/utils";

const ToastProvider = ToastPrimitives.Provider;

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      className,
    )}
    {...props}
  />
));
ToastViewport.displayName = ToastPrimitives.Viewport.displayName;

const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-2 overflow-hidden rounded-md border p-4 pr-6 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border bg-background text-foreground",
        destructive:
          "destructive group border-destructive bg-destructive text-destructive-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  },
);

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  );
});
Toast.displayName = ToastPrimitives.Root.displayName;

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium transition-colors hover:bg-secondary focus:outline-none focus:ring-1 focus:ring-ring disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
      className,
    )}
    {...props}
  />
));
ToastAction.displayName = ToastPrimitives.Action.displayName;

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-1 top-1 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-1 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className,
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
));
ToastClose.displayName = ToastPrimitives.Close.displayName;

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn("text-sm font-semibold [&+div]:text-xs", className)}
    {...props}
  />
));
ToastTitle.displayName = ToastPrimitives.Title.displayName;

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn("text-sm opacity-90", className)}
    {...props}
  />
));
ToastDescription.displayName = ToastPrimitives.Description.displayName;

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>;

type ToastActionElement = React.ReactElement<typeof ToastAction>;

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
};
```

### `src\components\ui\toaster.tsx`

```tsx
"use client";

import { Toaster as SonnerToaster } from "sonner";

export function Toaster() {
  return <SonnerToaster richColors position="top-right" />;
}
```

### `src\components\ui\toggle.tsx`

```tsx
"use client";

import * as React from "react";
import * as TogglePrimitive from "@radix-ui/react-toggle";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const toggleVariants = cva(
  "inline-flex items-center justify-center gap-2 rounded-md text-sm font-medium transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        outline:
          "border border-input bg-transparent shadow-sm hover:bg-accent hover:text-accent-foreground",
      },
      size: {
        default: "h-9 px-2 min-w-9",
        sm: "h-8 px-1.5 min-w-8",
        lg: "h-10 px-2.5 min-w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  },
);

const Toggle = React.forwardRef<
  React.ElementRef<typeof TogglePrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof TogglePrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, ...props }, ref) => (
  <TogglePrimitive.Root
    ref={ref}
    className={cn(toggleVariants({ variant, size, className }))}
    {...props}
  />
));

Toggle.displayName = TogglePrimitive.Root.displayName;

export { Toggle, toggleVariants };
```

### `src\components\ui\tooltip.tsx`

```tsx
"use client";

import * as React from "react";
import * as TooltipPrimitive from "@radix-ui/react-tooltip";

import { cn } from "@/lib/utils";

const TooltipProvider = TooltipPrimitive.Provider;

const Tooltip = TooltipPrimitive.Root;

const TooltipTrigger = TooltipPrimitive.Trigger;

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Portal>
    <TooltipPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 overflow-hidden rounded-md bg-primary px-3 py-1.5 text-xs text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className,
      )}
      {...props}
    />
  </TooltipPrimitive.Portal>
));
TooltipContent.displayName = TooltipPrimitive.Content.displayName;

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider };
```

### `src\components\ui\use-toast.ts`

```ts
// Inspired by react-hot-toast library
import * as React from "react";

import type { ToastActionElement, ToastProps } from "@/components/ui/toast";

const TOAST_LIMIT = 1;
const TOAST_REMOVE_DELAY = 1000000;

type ToasterToast = ToastProps & {
  id: string;
  title?: React.ReactNode;
  description?: React.ReactNode;
  action?: ToastActionElement;
};

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const;

let count = 0;

function genId() {
  count = (count + 1) % Number.MAX_VALUE;
  return count.toString();
}

type ActionType = typeof actionTypes;

type Action =
  | {
      type: ActionType["ADD_TOAST"];
      toast: ToasterToast;
    }
  | {
      type: ActionType["UPDATE_TOAST"];
      toast: Partial<ToasterToast>;
    }
  | {
      type: ActionType["DISMISS_TOAST"];
      toastId?: ToasterToast["id"];
    }
  | {
      type: ActionType["REMOVE_TOAST"];
      toastId?: ToasterToast["id"];
    };

interface State {
  toasts: ToasterToast[];
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>();

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return;
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId);
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    });
  }, TOAST_REMOVE_DELAY);

  toastTimeouts.set(toastId, timeout);
};

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      };

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t,
        ),
      };

    case "DISMISS_TOAST": {
      const { toastId } = action;

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId);
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id);
        });
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t,
        ),
      };
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        };
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      };
  }
};

const listeners: Array<(state: State) => void> = [];

let memoryState: State = { toasts: [] };

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action);
  listeners.forEach((listener) => {
    listener(memoryState);
  });
}

type Toast = Omit<ToasterToast, "id">;

function toast({ ...props }: Toast) {
  const id = genId();

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    });
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id });

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss();
      },
    },
  });

  return {
    id: id,
    dismiss,
    update,
  };
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState);

  React.useEffect(() => {
    listeners.push(setState);
    return () => {
      const index = listeners.indexOf(setState);
      if (index > -1) {
        listeners.splice(index, 1);
      }
    };
  }, [state]);

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  };
}

export { useToast, toast };
```

### `src\components\ui\view-toggle.tsx`

```tsx
import { LayoutList, Calendar } from "lucide-react";
import { Button } from "./button";
import { cn } from "@/lib/utils";

interface ViewToggleProps {
  view: "list" | "calendar";
  onChange: (view: "list" | "calendar") => void;
  className?: string;
}

export function ViewToggle({ view, onChange, className }: ViewToggleProps) {
  return (
    <div
      className={cn(
        "inline-flex items-center rounded-md border bg-muted p-1",
        className,
      )}
    >
      <Button
        variant="ghost"
        size="sm"
        className={cn("px-2.5", view === "list" && "bg-background shadow-sm")}
        onClick={() => onChange("list")}
      >
        <LayoutList className="h-4 w-4 mr-2" />
        List
      </Button>
      <Button
        variant="ghost"
        size="sm"
        className={cn(
          "px-2.5",
          view === "calendar" && "bg-background shadow-sm",
        )}
        onClick={() => onChange("calendar")}
      >
        <Calendar className="h-4 w-4 mr-2" />
        Calendar
      </Button>
    </div>
  );
}
```

### `src\components\workflows\DocumentTracker.tsx`

```tsx
import { useState } from "react";
import { Button } from "@/components/ui/button";
import { Checkbox } from "@/components/ui/checkbox";

interface Document {
  id: string;
  name: string;
  status: "pending" | "received" | "reviewed";
  due_date: string;
  reminder_sent: boolean;
}

interface DocumentTrackerProps {
  documents: Document[];
  onSendReminder: (documentId: string) => void;
  onStatusChange: (documentId: string, status: string) => void;
}

export function DocumentTracker({
  documents,
  onSendReminder,
  onStatusChange,
}: DocumentTrackerProps) {
  const [selectedDocuments, setSelectedDocuments] = useState<string[]>([]);

  const handleStatusChange = (documentId: string, status: string) => {
    onStatusChange(documentId, status);
    setSelectedDocuments((prev) => prev.filter((id) => id !== documentId));
  };

  return (
    <div className="space-y-4">
      <div className="flex justify-between items-center">
        <h3 className="font-semibold">Document Tracking</h3>
        <Button
          size="sm"
          disabled={selectedDocuments.length === 0}
          onClick={() => {
            selectedDocuments.forEach((id) => onSendReminder(id));
            setSelectedDocuments([]);
          }}
        >
          Send Reminder
        </Button>
      </div>

      <div className="space-y-2">
        {documents.map((document) => (
          <div
            key={document.id}
            className="flex items-center gap-4 p-2 border rounded"
          >
            <Checkbox
              checked={selectedDocuments.includes(document.id)}
              onCheckedChange={(checked) => {
                setSelectedDocuments((prev) =>
                  checked
                    ? [...prev, document.id]
                    : prev.filter((id) => id !== document.id),
                );
              }}
            />
            <div className="flex-1">
              <div className="font-medium">{document.name}</div>
              <div className="text-sm text-gray-600">
                Due: {new Date(document.due_date).toLocaleDateString()}
              </div>
            </div>
            <select
              value={document.status}
              onChange={(e) => handleStatusChange(document.id, e.target.value)}
              className="p-1 border rounded"
            >
              <option value="pending">Pending</option>
              <option value="received">Received</option>
              <option value="reviewed">Reviewed</option>
            </select>
          </div>
        ))}
      </div>
    </div>
  );
}
```

### `src\components\workflows\TaskDependencyGraph.tsx`

```tsx
import { useMemo } from "react";
import { Graph } from "react-d3-graph";

interface TaskDependencyGraphProps {
  tasks: {
    id: string;
    name: string;
    dependencies: string[];
  }[];
}

export function TaskDependencyGraph({ tasks }: TaskDependencyGraphProps) {
  const graphData = useMemo(() => {
    const nodes = tasks.map((task) => ({
      id: task.id,
      name: task.name,
    }));

    const links = tasks.flatMap((task) =>
      task.dependencies.map((dependencyId) => ({
        source: task.id,
        target: dependencyId,
      })),
    );

    return { nodes, links };
  }, [tasks]);

  const config = {
    nodeHighlightBehavior: true,
    node: {
      color: "#6366f1",
      size: 120,
      highlightStrokeColor: "blue",
    },
    link: {
      highlightColor: "lightblue",
    },
  };

  return (
    <div className="h-[500px] border rounded-lg">
      <Graph id="task-dependency-graph" data={graphData} config={config} />
    </div>
  );
}
```

### `src\components\workflows\workflow-stage.tsx`

```tsx
import { Tables } from "@/types/database.types";
import { Database } from "@/types/database.types";
import TaskCard from "../tasks/task-card";

interface WorkflowStageProps {
  stageName: string;
  tasks: Tables<"tasks">[];
}

type TaskCardTask = {
  id: string;
  title: string;
  description?: string | null;
  status: Database["public"]["Enums"]["task_status"];
  priority?: Database["public"]["Enums"]["task_priority"];
  category?: Database["public"]["Enums"]["service_type"] | null;
  due_date?: string | null;
  created_at?: string | null;
  updated_at?: string | null;
  project_id?: string | null;
};

export default function WorkflowStage({
  stageName,
  tasks,
}: WorkflowStageProps) {
  return (
    <div className="space-y-4">
      <h2 className="text-xl font-semibold">{stageName}</h2>
      <div className="space-y-2">
        {tasks.map((task) => (
          <TaskCard
            key={task.id}
            task={{
              id: task.id,
              title: task.title,
              description: task.description,
              status: task.status as Database["public"]["Enums"]["task_status"],
              priority:
                task.priority as Database["public"]["Enums"]["task_priority"],
              category:
                task.category as Database["public"]["Enums"]["service_type"],
              due_date: task.due_date,
              created_at: task.created_at,
              updated_at: task.updated_at,
              project_id: task.project_id,
            }}
          />
        ))}
      </div>
    </div>
  );
}
```

### `src\components\workflows\WorkflowStageComponent.tsx`

```tsx
interface WorkflowStageProps {
  stage: string;
  tasks: string[];
  completedTasks: number;
  totalTasks: number;
}

export function WorkflowStageComponent({
  stage,
  tasks,
  completedTasks,
  totalTasks,
}: WorkflowStageProps) {
  return (
    <div className="border rounded-lg p-4">
      <h3 className="font-semibold mb-2">{stage}</h3>
      <div className="text-sm text-gray-600 mb-2">
        {completedTasks}/{totalTasks} tasks completed
      </div>
      <ul className="space-y-1">
        {tasks.map((task, index) => (
          <li key={index} className="flex items-center">
            <input type="checkbox" className="mr-2" onChange={() => {}} />
            <span>{task}</span>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

### `src\hooks\use-auth.ts`

```ts
"use client";

import { createClient } from "@/lib/supabase/browser";
import { useRouter } from "next/navigation";
import { useEffect, useState } from "react";
import type { User } from "@supabase/supabase-js";
import { toast } from "sonner";

export function useAuth() {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const router = useRouter();
  const supabase = createClient();

  useEffect(() => {
    // Get initial session
    supabase.auth.getSession().then(({ data: { session } }) => {
      setUser(session?.user ?? null);
      setLoading(false);
    });

    // Listen for auth changes
    const {
      data: { subscription },
    } = supabase.auth.onAuthStateChange((_event, session) => {
      setUser(session?.user ?? null);
      setLoading(false);
    });

    return () => {
      subscription.unsubscribe();
    };
  }, [supabase.auth]);

  const signIn = async (email: string, password: string) => {
    try {
      const { error } = await supabase.auth.signInWithPassword({
        email,
        password,
      });
      if (error) throw error;
      router.refresh();
    } catch (error) {
      toast.error("Failed to sign in");
      console.error("Sign in error:", error);
    }
  };

  const signOut = async () => {
    try {
      const { error } = await supabase.auth.signOut();
      if (error) throw error;
      router.refresh();
    } catch (error) {
      toast.error("Failed to sign out");
      console.error("Sign out error:", error);
    }
  };

  return {
    user,
    loading,
    signIn,
    signOut,
  };
}
```

### `src\hooks\use-debounce.tsx`

```tsx
import { useState, useEffect } from "react";

function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}

export default useDebounce;
```

### `src\hooks\use-mobile.tsx`

```tsx
import * as React from "react";

const MOBILE_BREAKPOINT = 768;

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(
    undefined,
  );

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`);
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    };
    mql.addEventListener("change", onChange);
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    return () => mql.removeEventListener("change", onChange);
  }, []);

  return !!isMobile;
}
```

### `src\hooks\use-protected-route.ts`

```ts
import { useEffect } from "react";
import { useRouter, usePathname } from "next/navigation";
import { useAuth } from "@/components/providers/auth-provider";
import type { UserRole } from "@/types/auth";

interface UseProtectedRouteOptions {
  allowedRoles?: UserRole[];
  redirectTo?: string;
  isPublicRoute?: boolean;
}

export function useProtectedRoute({
  allowedRoles,
  redirectTo = "/login",
  isPublicRoute = false,
}: UseProtectedRouteOptions = {}) {
  const { session, loading, checkRole } = useAuth();
  const router = useRouter();
  const pathname = usePathname();

  useEffect(() => {
    if (loading) return;

    // Allow public routes
    if (isPublicRoute) return;

    // Redirect to login if not authenticated
    if (!session) {
      const returnUrl = encodeURIComponent(pathname || "");
      router.replace(`${redirectTo}?returnUrl=${returnUrl}`);
      return;
    }

    // Check role-based access if roles are specified
    if (allowedRoles && allowedRoles.length > 0) {
      const hasAllowedRole = allowedRoles.some((role) => checkRole(role));
      if (!hasAllowedRole) {
        router.replace("/unauthorized");
      }
    }
  }, [
    session,
    loading,
    allowedRoles,
    redirectTo,
    isPublicRoute,
    router,
    pathname,
    checkRole,
  ]);

  return {
    isAuthenticated: !!session,
    isAuthorized: !allowedRoles || allowedRoles.some((role) => checkRole(role)),
    isLoading: loading,
    user: session?.user,
  };
}
```

### `src\hooks\use-toast.ts`

```ts
"use client";

// Inspired by react-hot-toast library
import * as React from "react";

import type { ToastActionElement, ToastProps } from "@/components/ui/toast";

const TOAST_LIMIT = 1;
const TOAST_REMOVE_DELAY = 1000000;

type ToasterToast = ToastProps & {
  id: string;
  title?: React.ReactNode;
  description?: React.ReactNode;
  action?: ToastActionElement;
};

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const;

let count = 0;

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER;
  return count.toString();
}

type ActionType = typeof actionTypes;

type Action =
  | {
      type: ActionType["ADD_TOAST"];
      toast: ToasterToast;
    }
  | {
      type: ActionType["UPDATE_TOAST"];
      toast: Partial<ToasterToast>;
    }
  | {
      type: ActionType["DISMISS_TOAST"];
      toastId?: ToasterToast["id"];
    }
  | {
      type: ActionType["REMOVE_TOAST"];
      toastId?: ToasterToast["id"];
    };

interface State {
  toasts: ToasterToast[];
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>();

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return;
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId);
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    });
  }, TOAST_REMOVE_DELAY);

  toastTimeouts.set(toastId, timeout);
};

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      };

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t,
        ),
      };

    case "DISMISS_TOAST": {
      const { toastId } = action;

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId);
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id);
        });
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t,
        ),
      };
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        };
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      };
  }
};

const listeners: Array<(state: State) => void> = [];

let memoryState: State = { toasts: [] };

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action);
  listeners.forEach((listener) => {
    listener(memoryState);
  });
}

type Toast = Omit<ToasterToast, "id">;

function toast({ ...props }: Toast) {
  const id = genId();

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    });
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id });

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss();
      },
    },
  });

  return {
    id: id,
    dismiss,
    update,
  };
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState);

  React.useEffect(() => {
    listeners.push(setState);
    return () => {
      const index = listeners.indexOf(setState);
      if (index > -1) {
        listeners.splice(index, 1);
      }
    };
  }, [state]);

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  };
}

export { useToast, toast };
```

### `src\hooks\useAITasks.ts`

```ts
import { useState } from "react";
import { TaskCategory } from "@/lib/ai/tasks";

export function useAITasks() {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  async function classifyTask(title: string, description: string) {
    setIsLoading(true);
    setError(null);

    try {
      const response = await fetch("/api/ai/classify-task", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ title, description }),
      });

      if (!response.ok) {
        throw new Error("Failed to classify task");
      }

      const data = await response.json();
      return data as {
        category: TaskCategory;
        suggestions: Array<{ category: TaskCategory; confidence: number }>;
      };
    } catch (err) {
      setError(err instanceof Error ? err.message : "Classification failed");
      throw err;
    } finally {
      setIsLoading(false);
    }
  }

  return {
    classifyTask,
    isLoading,
    error,
  };
}
```

### `src\hooks\useAuditLog.ts`

```ts
import { supabaseBrowserClient } from "@/lib/supabaseBrowserClient";
import { Database } from "@/types/database.types";

type AuditLog = Database["public"]["Tables"]["audit_log"]["Row"];

export function useAuditLog() {
  async function logAction(action: string, details: string) {
    await supabaseBrowserClient.from("audit_log").insert({ action, details });
  }

  return { logAction };
}
```

### `src\hooks\useClientOnboarding.ts`

```ts
import { useState, useEffect } from "react";
import { supabase } from "@/lib/supabase";
import { ClientOnboardingWorkflow, WorkflowTemplate } from "@/types/hooks";

export function useClientOnboarding(clientId?: string) {
  const [workflow, setWorkflow] = useState<ClientOnboardingWorkflow | null>(
    null,
  );
  const [templates, setTemplates] = useState<WorkflowTemplate[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (clientId) {
      fetchWorkflow();
    }
    fetchTemplates();
  }, [clientId]);

  async function fetchWorkflow() {
    if (!clientId) return;

    try {
      const { data, error } = await supabase
        .from("client_onboarding_workflows")
        .select("*")
        .eq("client_id", clientId)
        .single();

      if (error && error.code !== "PGRST116") throw error; // PGRST116 is "no rows returned"

      // Transform the data to include steps if progress exists
      if (data) {
        const progressData = data.progress ? JSON.parse(data.progress) : null;
        const workflowData: ClientOnboardingWorkflow = {
          ...data,
          steps: progressData?.steps || [],
        };
        setWorkflow(workflowData);
      } else {
        setWorkflow(null);
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : "An error occurred");
    } finally {
      setLoading(false);
    }
  }

  async function fetchTemplates() {
    try {
      const { data, error } = await supabase
        .from("workflow_templates")
        .select("*")
        .order("name");

      if (error) throw error;

      // Transform the templates data to parse steps JSON
      const transformedTemplates = (data || []).map((template) => ({
        ...template,
        steps: Array.isArray(template.steps)
          ? template.steps
          : typeof template.steps === "string"
            ? JSON.parse(template.steps)
            : [],
      })) as WorkflowTemplate[];

      setTemplates(transformedTemplates);
    } catch (err) {
      setError(err instanceof Error ? err.message : "An error occurred");
    }
  }

  async function startWorkflow(clientId: string, templateId: number) {
    try {
      if (!clientId || !templateId) {
        throw new Error("Client ID and template ID are required");
      }

      const template = templates.find((t) => t.id === templateId);
      if (!template) {
        throw new Error("Template not found");
      }

      const workflowData = {
        client_id: clientId,
        template_id: templateId,
        status: "in_progress",
        progress: JSON.stringify({
          currentStep: 0,
          totalSteps: template.steps.length,
          completedSteps: [],
          steps: template.steps.map((step) => ({
            ...step,
            status: "pending",
          })),
        }),
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      };

      const { data, error } = await supabase
        .from("client_onboarding_workflows")
        .insert([workflowData])
        .select();

      if (error) throw error;
      if (data && data[0]) {
        const progressData = JSON.parse(data[0].progress || "{}");
        const workflowWithSteps: ClientOnboardingWorkflow = {
          ...data[0],
          steps: progressData.steps || [],
        };
        setWorkflow(workflowWithSteps);
        return workflowWithSteps;
      }
      throw new Error("Failed to start workflow");
    } catch (err) {
      setError(err instanceof Error ? err.message : "An error occurred");
      throw err;
    }
  }

  async function updateWorkflow(
    id: number,
    updates: Partial<
      Omit<ClientOnboardingWorkflow, "id" | "created_at" | "client_id">
    >,
  ) {
    try {
      if (!id) {
        throw new Error("Workflow ID is required");
      }

      const updateData = {
        ...updates,
        updated_at: new Date().toISOString(),
      };

      const { data, error } = await supabase
        .from("client_onboarding_workflows")
        .update(updateData)
        .eq("id", id)
        .select();

      if (error) throw error;
      if (data && data[0]) {
        setWorkflow(data[0]);
        return data[0];
      }
      throw new Error("Failed to update workflow");
    } catch (err) {
      setError(err instanceof Error ? err.message : "An error occurred");
      throw err;
    }
  }

  async function deleteWorkflow(id: number) {
    try {
      if (!id) {
        throw new Error("Workflow ID is required");
      }

      const { error } = await supabase
        .from("client_onboarding_workflows")
        .delete()
        .eq("id", id);

      if (error) throw error;
      setWorkflow(null);
    } catch (err) {
      setError(err instanceof Error ? err.message : "An error occurred");
      throw err;
    }
  }

  return {
    workflow,
    templates,
    loading,
    error,
    startWorkflow,
    updateWorkflow,
    deleteWorkflow,
    refresh: fetchWorkflow,
  };
}
```

### `src\hooks\useClients.ts`

```ts
"use client";

import { useState, useEffect } from "react";
import { supabaseBrowserClient } from "@/lib/supabaseBrowserClient";
import { handleError } from "@/lib/error-handler";
import { Database } from "@/types/database.types";

// Strict typing using the Database schema
type Client = Database["public"]["Tables"]["clients"]["Row"];

export function useClients(initialClients?: Client[] | null) {
  const [clients, setClients] = useState<Client[]>(initialClients || []);
  const [loading, setLoading] = useState(!initialClients);
  const [error, setError] = useState("");

  // Fetch and subscribe to real-time updates
  useEffect(() => {
    // If we didn't receive SSR data, fetch from the DB
    if (!initialClients) {
      fetchClients();
    }

    // Subscribe to real-time updates
    const channel = supabaseBrowserClient
      .channel("clients")
      .on(
        "postgres_changes",
        { event: "*", schema: "public", table: "clients" },
        () => {
          fetchClients();
        },
      )
      .subscribe();

    return () => {
      channel.unsubscribe();
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  async function fetchClients() {
    setLoading(true);
    try {
      const { data, error } = await supabaseBrowserClient
        .from("clients")
        .select("*");
      if (error) throw error;
      if (data) setClients(data);
    } catch (err: any) {
      setError(handleError(err).message);
    } finally {
      setLoading(false);
    }
  }

  async function createClient(newClient: Partial<Client>) {
    try {
      setLoading(true);
      const { error } = await supabaseBrowserClient
        .from("clients")
        .insert(newClient);
      if (error) throw error;
      await fetchClients();
    } catch (err: any) {
      setError(handleError(err).message);
    } finally {
      setLoading(false);
    }
  }

  async function updateClient(
    clientId: string,
    updatedFields: Partial<Client>,
  ) {
    try {
      setLoading(true);
      const { error } = await supabaseBrowserClient
        .from("clients")
        .update(updatedFields)
        .eq("id", clientId);
      if (error) throw error;
      await fetchClients();
    } catch (err: any) {
      setError(handleError(err).message);
    } finally {
      setLoading(false);
    }
  }

  async function deleteClient(clientId: string) {
    try {
      setLoading(true);
      const { error } = await supabaseBrowserClient
        .from("clients")
        .delete()
        .eq("id", clientId);
      if (error) throw error;
      await fetchClients();
    } catch (err: any) {
      setError(handleError(err).message);
    } finally {
      setLoading(false);
    }
  }

  return {
    clients,
    loading,
    error,
    createClient,
    updateClient,
    deleteClient,
  };
}
```

### `src\hooks\useDatabase.ts`

```ts
"use client";

import { supabaseBrowserClient } from "@/lib/supabaseBrowserClient";
import type { Database } from "@/types/database.types";

export function useDatabase() {
  return supabaseBrowserClient as Database;
}
```

### `src\hooks\useDocuments.ts`

```ts
"use client";

import { useState, useEffect } from "react";
import { supabaseBrowserClient } from "@/lib/supabaseBrowserClient";
import { Database } from "@/types/database.types";

type Document = Database["public"]["Tables"]["client_documents"]["Row"];
type DocumentInsert =
  Database["public"]["Tables"]["client_documents"]["Insert"];

export const useDocuments = (clientId: string) => {
  const [documents, setDocuments] = useState<Document[]>([]);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    fetchDocuments();
  }, [clientId]);

  const fetchDocuments = async () => {
    setIsLoading(true);
    const { data, error } = await supabaseBrowserClient
      .from("client_documents")
      .select("*")
      .eq("client_id", clientId);

    if (error) {
      console.error("Error fetching documents:", error);
      return;
    }

    setDocuments(data || []);
    setIsLoading(false);
  };

  return {
    documents,
    isLoading,
    fetchDocuments,
  };
};
```

### `src\hooks\useNotes.ts`

```ts
import { useState, useEffect } from "react";
import { supabase } from "@/lib/supabase";
import { Note } from "@/types/hooks";

export function useNotes(
  clientId?: string,
  projectId?: number,
  userId?: string,
) {
  const [notes, setNotes] = useState<Note[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    fetchNotes();
  }, [clientId, projectId, userId]);

  async function fetchNotes() {
    try {
      let query = supabase
        .from("notes")
        .select("*")
        .order("created_at", { ascending: false });

      if (clientId) {
        query = query.eq("client_id", clientId);
      }

      if (projectId) {
        query = query.eq("project_id", projectId);
      }

      if (userId) {
        query = query.eq("user_id", userId);
      }

      const { data, error } = await query;

      if (error) throw error;
      setNotes(data || []);
    } catch (err) {
      setError(err instanceof Error ? err.message : "An error occurred");
    } finally {
      setLoading(false);
    }
  }

  async function addNote({
    content,
    ...rest
  }: Omit<Note, "id" | "created_at">) {
    try {
      if (!content) {
        throw new Error("Content is required");
      }

      const noteData = {
        content,
        ...rest,
        created_at: new Date().toISOString(),
        client_id: clientId,
        user_id: userId,
        project_id: projectId,
      };

      const { data, error } = await supabase
        .from("notes")
        .insert([noteData])
        .select();

      if (error) throw error;
      if (data && data[0]) {
        setNotes((prev) => [data[0], ...prev]);
        return data[0];
      }
      throw new Error("Failed to create note");
    } catch (err) {
      setError(err instanceof Error ? err.message : "An error occurred");
      throw err;
    }
  }

  async function updateNote(id: number, content: string) {
    try {
      if (!content) {
        throw new Error("Content is required");
      }

      const { data, error } = await supabase
        .from("notes")
        .update({ content })
        .eq("id", id)
        .select();

      if (error) throw error;
      setNotes((prev) =>
        prev.map((note) => (note.id === id ? { ...note, content } : note)),
      );
    } catch (err) {
      setError(err instanceof Error ? err.message : "An error occurred");
      throw err;
    }
  }

  async function deleteNote(id: number) {
    try {
      const { error } = await supabase.from("notes").delete().eq("id", id);

      if (error) throw error;
      setNotes((prev) => prev.filter((note) => note.id !== id));
    } catch (err) {
      setError(err instanceof Error ? err.message : "An error occurred");
      throw err;
    }
  }

  return {
    notes,
    loading,
    error,
    addNote,
    updateNote,
    deleteNote,
    refresh: fetchNotes,
  };
}
```

### `src\hooks\usePayrollServices.ts`

```ts
import { useState, useEffect } from "react";
import { supabase } from "@/lib/supabase";
import { PayrollService } from "@/types/hooks";

export function usePayrollServices(clientId?: string) {
  const [services, setServices] = useState<PayrollService[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    fetchServices();
  }, [clientId]);

  async function fetchServices() {
    try {
      let query = supabase
        .from("payroll_services")
        .select("*")
        .order("created_at", { ascending: false });

      if (clientId) {
        query = query.eq("client_id", clientId);
      }

      const { data, error } = await query;

      if (error) throw error;
      setServices(data || []);
    } catch (err) {
      setError(err instanceof Error ? err.message : "An error occurred");
    } finally {
      setLoading(false);
    }
  }

  async function addService({
    service_name,
    frequency,
    ...rest
  }: Omit<PayrollService, "id" | "created_at" | "updated_at">) {
    try {
      if (!service_name || !frequency) {
        throw new Error("Service name and frequency are required");
      }

      const serviceData = {
        service_name,
        frequency,
        ...rest,
        client_id: clientId,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      };

      const { data, error } = await supabase
        .from("payroll_services")
        .insert([serviceData])
        .select();

      if (error) throw error;
      if (data && data[0]) {
        setServices((prev) => [data[0], ...prev]);
        return data[0];
      }
      throw new Error("Failed to create payroll service");
    } catch (err) {
      setError(err instanceof Error ? err.message : "An error occurred");
      throw err;
    }
  }

  async function updateService(
    id: number,
    updates: Partial<Omit<PayrollService, "id" | "created_at" | "client_id">>,
  ) {
    try {
      const updateData = {
        ...updates,
        updated_at: new Date().toISOString(),
      };

      const { data, error } = await supabase
        .from("payroll_services")
        .update(updateData)
        .eq("id", id)
        .select();

      if (error) throw error;
      if (data && data[0]) {
        setServices((prev) =>
          prev.map((service) => (service.id === id ? data[0] : service)),
        );
        return data[0];
      }
      throw new Error("Failed to update payroll service");
    } catch (err) {
      setError(err instanceof Error ? err.message : "An error occurred");
      throw err;
    }
  }

  async function deleteService(id: number) {
    try {
      const { error } = await supabase
        .from("payroll_services")
        .delete()
        .eq("id", id);

      if (error) throw error;
      setServices((prev) => prev.filter((service) => service.id !== id));
    } catch (err) {
      setError(err instanceof Error ? err.message : "An error occurred");
      throw err;
    }
  }

  return {
    services,
    loading,
    error,
    addService,
    updateService,
    deleteService,
    refresh: fetchServices,
  };
}
```

### `src\hooks\useProcessingStatus.ts`

```ts
"use client";

import { useQuery, useQueryClient } from "@tanstack/react-query";
import { createClient } from "@/lib/supabase/browser";
import { useEffect } from "react";
import type { Database } from "@/types/database.types";

type ProcessingStatus =
  Database["public"]["Tables"]["document_processing"]["Row"];

export function useProcessingStatus(documentId: string) {
  const supabase = createClient();
  const queryClient = useQueryClient();

  useEffect(() => {
    // Subscribe to changes
    const channel = supabase
      .channel("processing-status-changes")
      .on(
        "postgres_changes",
        {
          event: "*",
          schema: "public",
          table: "document_processing",
          filter: `document_id=eq.${documentId}`,
        },
        (payload) => {
          // Invalidate and refetch
          queryClient.invalidateQueries({
            queryKey: ["processingStatus", documentId],
          });
        },
      )
      .subscribe();

    return () => {
      supabase.removeChannel(channel);
    };
  }, [supabase, queryClient, documentId]);

  return useQuery<ProcessingStatus>({
    queryKey: ["processingStatus", documentId],
    queryFn: async () => {
      const { data, error } = await supabase
        .from("document_processing")
        .select("*")
        .eq("document_id", documentId)
        .single();
      if (error) throw error;
      return data;
    },
  });
}
```

### `src\hooks\useProjectAnalytics.ts`

```ts
import { useCallback, useState } from "react";
import { Database } from "@/types/database.types";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";

type Project = Database["public"]["Tables"]["projects"]["Row"];

function calculateCompletionRate(project: Project): number {
  if (!project.task_count || project.task_count === 0) return 0;
  return ((project.completed_tasks || 0) / project.task_count) * 100;
}

function assessProjectRisk(project: Project): string {
  const completionRate = calculateCompletionRate(project);
  if (completionRate < 30) return "high";
  if (completionRate < 70) return "medium";
  return "low";
}

function predictDelay(project: Project): number {
  const completionRate = calculateCompletionRate(project);
  // Simple delay prediction based on completion rate
  if (completionRate < 50) return 5; // 5 days delay predicted
  if (completionRate < 80) return 2; // 2 days delay predicted
  return 0; // No delay predicted
}

function analyzeResourceUtilization(project: Project): number {
  // Simple resource utilization calculation
  const completionRate = calculateCompletionRate(project);
  return Math.min(100, completionRate * 1.2); // Adjust based on completion rate
}

function generateRecommendations(project: Project): string[] {
  const recommendations: string[] = [];
  const completionRate = calculateCompletionRate(project);

  if (completionRate < 30) {
    recommendations.push("Consider allocating more resources to this project");
  }
  if (project.status === "blocked") {
    recommendations.push("Review and address project blockers");
  }
  if (!project.primary_manager) {
    recommendations.push(
      "Assign a primary manager to improve project oversight",
    );
  }

  return recommendations;
}

export function useProjectAnalytics() {
  const [loading, setLoading] = useState(false);
  const [insights, setInsights] = useState<any[]>([]);
  const supabase = createClientComponentClient<Database>();

  const analyzeProjects = useCallback(async (projects: Project[]) => {
    setLoading(true);
    try {
      // Analyze project patterns and generate insights
      const projectInsights = projects.map((project) => ({
        id: project.id,
        name: project.name,
        metrics: {
          completionRate: calculateCompletionRate(project),
          riskLevel: assessProjectRisk(project),
          predictedDelay: predictDelay(project),
          resourceUtilization: analyzeResourceUtilization(project),
        },
        recommendations: generateRecommendations(project),
      }));

      setInsights(projectInsights);
      return projectInsights;
    } catch (error) {
      console.error("Error analyzing projects:", error);
      return [];
    } finally {
      setLoading(false);
    }
  }, []);

  return {
    loading,
    insights,
    analyzeProjects,
  };
}
```

### `src\hooks\useProjectFilters.ts`

```ts
import { useState } from "react";
import type { DateRange } from "react-day-picker";
import type { ProjectWithRelations } from "@/types/projects";
import type { ProjectStatus, Priority, ServiceCategory } from "@/types/hooks";
import { startOfDay, endOfDay } from "date-fns";

export interface ProjectFilters {
  search: string;
  status: ProjectStatus[];
  priority: Priority[];
  service_category: ServiceCategory[];
  clientId: string;
  dateRange?: DateRange;
  sortBy: string;
  sortOrder: "asc" | "desc";
  groupBy: string;
}

export const defaultFilters: ProjectFilters = {
  search: "",
  status: [],
  priority: [],
  service_category: [],
  clientId: "all",
  dateRange: undefined,
  sortBy: "due_date",
  sortOrder: "asc",
  groupBy: "status",
};

export function useProjectFilters() {
  const [filters, setFilters] = useState<ProjectFilters>(defaultFilters);
  const [error, setError] = useState<Error | null>(null);

  const updateFilters = (updates: Partial<ProjectFilters>) => {
    setFilters((prev) => ({
      ...prev,
      ...updates,
    }));
  };

  const resetFilters = () => {
    setFilters(defaultFilters);
  };

  const filterProjects = (
    projects: ProjectWithRelations[],
  ): ProjectWithRelations[] => {
    try {
      return projects.filter((project) => {
        // Search filter
        if (filters.search && !matchesSearch(project, filters.search)) {
          return false;
        }

        // Status filter
        if (
          filters.status.length > 0 &&
          !filters.status.includes(project.status)
        ) {
          return false;
        }

        // Priority filter
        if (
          filters.priority.length > 0 &&
          project.priority &&
          !filters.priority.includes(project.priority as Priority)
        ) {
          return false;
        }

        // Service category filter
        if (
          filters.service_category.length > 0 &&
          project.service_type &&
          !filters.service_category.includes(
            project.service_type as ServiceCategory,
          )
        ) {
          return false;
        }

        // Client filter
        if (
          filters.clientId !== "all" &&
          project.client_id !== filters.clientId
        ) {
          return false;
        }

        // Date range filter
        if (filters.dateRange?.from) {
          const startDate = startOfDay(filters.dateRange.from);
          const endDate = filters.dateRange.to
            ? endOfDay(filters.dateRange.to)
            : endOfDay(filters.dateRange.from);
          const projectDate = project.due_date
            ? new Date(project.due_date)
            : null;

          if (
            !projectDate ||
            projectDate < startDate ||
            projectDate > endDate
          ) {
            return false;
          }
        }

        return true;
      });
    } catch (err) {
      console.error("Error filtering projects:", err);
      setError(
        err instanceof Error ? err : new Error("Failed to filter projects"),
      );
      return projects;
    }
  };

  const matchesSearch = (
    project: ProjectWithRelations,
    search: string,
  ): boolean => {
    const searchLower = search.toLowerCase();
    return (
      project.name?.toLowerCase().includes(searchLower) ||
      false ||
      project.description?.toLowerCase().includes(searchLower) ||
      false ||
      project.client?.full_name?.toLowerCase().includes(searchLower) ||
      false ||
      project.client?.company_name?.toLowerCase().includes(searchLower) ||
      false
    );
  };

  return {
    filters,
    updateFilters,
    resetFilters,
    filterProjects,
    error,
  };
}
```

### `src\hooks\useProjectForm.ts`

```ts
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { useState } from "react";
import {
  ProjectFormValues,
  projectSchema,
  ServiceType,
} from "@/lib/validations/project";
import { Database } from "@/types/database.types";
import { ProjectTemplate } from "@/types/projects";

type ProjectRow = Database["public"]["Tables"]["projects"]["Row"];

interface UseProjectFormProps {
  defaultValues?: Partial<ProjectFormValues>;
  onSubmit: (data: ProjectFormValues) => Promise<void>;
}

export function useProjectForm({
  defaultValues,
  onSubmit,
}: UseProjectFormProps) {
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [progress, setProgress] = useState(0);

  const form = useForm<ProjectFormValues>({
    resolver: zodResolver(projectSchema),
    defaultValues: {
      name: "",
      status: "not_started",
      priority: "medium",
      service_type: "tax_return",
      tax_info: null,
      accounting_info: null,
      payroll_info: null,
      service_info: null,
      completed_tasks: 0,
      completion_percentage: 0,
      task_count: 0,
      ...defaultValues,
    },
  });

  const calculateProgress = () => {
    const fields = form.getValues();
    const requiredFields = ["name", "client_id", "service_type", "due_date"];

    const serviceFields = {
      tax_return: ["tax_info"],
      bookkeeping: ["accounting_info"],
      payroll: ["payroll_info"],
      advisory: ["service_info"],
    } as const;

    let completed = 0;
    let total = requiredFields.length;

    // Check basic required fields
    for (const field of requiredFields) {
      if (fields[field as keyof ProjectFormValues]) {
        completed++;
      }
    }

    // Check service-specific fields
    if (fields.service_type && serviceFields[fields.service_type]) {
      const serviceSpecificFields = serviceFields[fields.service_type];
      total += serviceSpecificFields.length;
      for (const field of serviceSpecificFields) {
        if (fields[field as keyof ProjectFormValues]) {
          completed++;
        }
      }
    }

    // Calculate percentage
    const percentage = (completed / total) * 100;
    setProgress(Math.round(percentage));
  };

  const onServiceTypeChange = (type: ServiceType) => {
    // Reset service-specific fields when type changes
    form.setValue("service_type", type);
    form.setValue("tax_info", null);
    form.setValue("accounting_info", null);
    form.setValue("payroll_info", null);
    form.setValue("service_info", null);
    calculateProgress();
  };

  const onTemplateSelect = (template: ProjectTemplate | null) => {
    if (!template) {
      form.setValue("template_id", null);
      return;
    }

    form.setValue("template_id", template.id);
    if (template.project_defaults) {
      const defaults = template.project_defaults as Partial<ProjectRow>;
      Object.entries(defaults).forEach(([key, value]) => {
        form.setValue(key as keyof ProjectFormValues, value);
      });
    }
    calculateProgress();
  };

  const handleSubmit = async (e?: React.BaseSyntheticEvent) => {
    if (e) {
      e.preventDefault();
    }

    try {
      setIsSubmitting(true);
      const values = form.getValues();
      await onSubmit(values);
    } finally {
      setIsSubmitting(false);
    }
  };

  return {
    form,
    isSubmitting,
    progress,
    onServiceTypeChange,
    onTemplateSelect,
    onSubmit: handleSubmit,
    calculateProgress,
  };
}
```

### `src\hooks\useProjectManagement.ts`

```ts
import { useState, useCallback, useMemo, useEffect } from "react";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import { format, startOfWeek, endOfWeek, addMonths } from "date-fns";
import type {
  ProjectWithRelations,
  ServiceCategory,
  TaxReturnType,
  ProjectStatus,
  Priority,
} from "@/types/projects";
import type { ReviewStatus } from "@/types/tasks";
import { useToast } from "@/components/ui/use-toast";
import { useProjectFilters } from "./useProjectFilters";
import type { ProjectFilters } from "./useProjectFilters";

export function useProjectManagement(): {
  projects: ProjectWithRelations[];
  loading: boolean;
  error: Error | null;
  filters: ProjectFilters;
  updateFilters: (updates: Partial<ProjectFilters>) => void;
  resetFilters: () => void;
  filterProjects: (projects: ProjectWithRelations[]) => ProjectWithRelations[];
  groupProjects: (
    projects: ProjectWithRelations[],
    groupBy: string,
  ) => { [key: string]: ProjectWithRelations[] };
  refresh: () => Promise<void>;
  bulkUpdateProjects: (
    projectIds: string[],
    updates: Partial<ProjectWithRelations>,
  ) => Promise<boolean>;
  archiveProjects: (projectIds: string[]) => Promise<boolean>;
} {
  const [projects, setProjects] = useState<ProjectWithRelations[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);
  const { toast } = useToast();
  const supabase = createClientComponentClient();
  const {
    filters,
    updateFilters,
    resetFilters,
    filterProjects: applyFilters,
  } = useProjectFilters();

  const groupKeyMap = {
    status: (project: ProjectWithRelations) => project.status || "No Status",
    service: (project: ProjectWithRelations) =>
      project.service_category || "Uncategorized",
    deadline: (project: ProjectWithRelations) => {
      if (!project.due_date) return "No Due Date";
      const dueDate = new Date(project.due_date);
      const today = new Date();
      const weekStart = startOfWeek(today);
      const weekEnd = endOfWeek(today);

      if (dueDate < today) return "Overdue";
      if (dueDate <= weekEnd) return "This Week";
      if (dueDate <= addMonths(today, 1)) return "Next Month";
      return "Later";
    },
    client: (project: ProjectWithRelations) =>
      project.client?.name || "No Client",
  };

  const fetchProjects = useCallback(async () => {
    try {
      setLoading(true);
      const { data, error: fetchError } = await supabase.from("projects")
        .select(`
          *,
          client:clients(*),
          tasks:project_tasks(
            *,
            checklist_items(*),
            activity_log_entries(*)
          ),
          tax_return:tax_returns(*)
        `);

      if (fetchError) throw fetchError;

      const processedProjects = data.map((project) => ({
        ...project,
        completion_percentage: calculateCompletionPercentage(project),
      }));

      setProjects(processedProjects);
      setError(null);
    } catch (err) {
      console.error("Error fetching projects:", err);
      setError(
        err instanceof Error ? err : new Error("Failed to fetch projects"),
      );
      toast({
        title: "Error",
        description: "Failed to fetch projects. Please try again.",
        variant: "destructive",
      });
    } finally {
      setLoading(false);
    }
  }, [supabase, toast]);

  useEffect(() => {
    fetchProjects();

    const projectsChannel = supabase
      .channel("projects_changes")
      .on(
        "postgres_changes",
        { event: "*", schema: "public", table: "projects" },
        fetchProjects,
      )
      .subscribe();

    return () => {
      projectsChannel.unsubscribe();
    };
  }, [fetchProjects, supabase]);

  const calculateCompletionPercentage = (
    project: ProjectWithRelations,
  ): number => {
    if (!project.tasks?.length) return 0;
    const completedTasks = project.tasks.filter(
      (task) => task.status === "completed",
    ).length;
    return Math.round((completedTasks / project.tasks.length) * 100);
  };

  const groupProjects = useCallback(
    (projects: ProjectWithRelations[], groupBy: string) => {
      const groupedProjects: { [key: string]: ProjectWithRelations[] } = {};
      const getGroupKey =
        groupKeyMap[groupBy as keyof typeof groupKeyMap] || groupKeyMap.status;

      projects.forEach((project) => {
        const key = getGroupKey(project);
        if (!groupedProjects[key]) {
          groupedProjects[key] = [];
        }
        groupedProjects[key].push(project);
      });

      return groupedProjects;
    },
    [],
  );

  const bulkUpdateProjects = async (
    projectIds: string[],
    updates: Partial<ProjectWithRelations>,
  ) => {
    try {
      const { error: updateError } = await supabase
        .from("projects")
        .update(updates)
        .in("id", projectIds);

      if (updateError) throw updateError;

      await fetchProjects();
      return true;
    } catch (err) {
      console.error("Error updating projects:", err);
      throw new Error("Failed to update projects");
    }
  };

  const archiveProjects = async (projectIds: string[]) => {
    return bulkUpdateProjects(projectIds, {
      status: "archived",
      updated_at: new Date().toISOString(),
    });
  };

  const TAX_DEADLINES: Record<
    TaxReturnType,
    { normal: string; extended: string }
  > = {
    "1040": { normal: "04-15", extended: "10-15" },
    "1120": { normal: "04-15", extended: "10-15" },
    "1065": { normal: "03-15", extended: "09-15" },
    "1120S": { normal: "03-15", extended: "09-15" },
    "990": { normal: "05-15", extended: "11-15" },
    "941": { normal: "quarterly", extended: "N/A" },
    "940": { normal: "01-31", extended: "N/A" },
    other: { normal: "04-15", extended: "10-15" },
  };

  const ESTIMATED_TAX_DEADLINES = ["04-15", "06-15", "09-15", "01-15"];

  const getDeadline = useCallback(
    (returnType: TaxReturnType, isExtended: boolean = false): Date => {
      const currentYear = new Date().getFullYear();
      const deadlineType = isExtended ? "extended" : "normal";
      const monthDay = TAX_DEADLINES[returnType]?.[deadlineType] || "04-15";
      return new Date(`${currentYear}-${monthDay}`);
    },
    [],
  );

  const getNextEstimatedTaxDeadline = useCallback(() => {
    const today = new Date();
    const currentYear = today.getFullYear();

    for (const deadline of ESTIMATED_TAX_DEADLINES) {
      const deadlineDate = new Date(`${currentYear}-${deadline}`);
      if (new Date(deadlineDate) > today) {
        return deadlineDate;
      }
    }

    return new Date(`${currentYear + 1}-${ESTIMATED_TAX_DEADLINES[0]}`);
  }, []);

  const getProjectDeadline = useCallback(
    (project: ProjectWithRelations): Date | null => {
      if (project.due_date) {
        return new Date(project.due_date);
      }
      if (project.tax_info?.filing_deadline) {
        return new Date(project.tax_info.filing_deadline);
      }
      if (project.payroll_info?.next_payroll_date) {
        return new Date(project.payroll_info.next_payroll_date);
      }
      if (project.business_services_info?.due_date) {
        return new Date(project.business_services_info.due_date);
      }
      if (project.tax_info?.return_type) {
        const isExtended = project.tax_info.is_extended || false;
        return getDeadline(project.tax_info.return_type, isExtended);
      }
      return null;
    },
    [getDeadline],
  );

  const filterProjects = useCallback(
    (projects: ProjectWithRelations[]) => {
      if (!projects) return [];

      return projects.filter((project) => {
        const searchLower = (filters.search || "").toLowerCase();

        // Safely access potentially undefined properties
        const projectTitle = project?.title || "";
        const projectDesc = project?.description || "";
        const clientCompany = project?.client?.company_name || "";
        const clientName = project?.client?.full_name || "";
        const returnType = project?.tax_info?.return_type || "";

        const matchesSearch =
          !searchLower ||
          projectTitle.toLowerCase().includes(searchLower) ||
          projectDesc.toLowerCase().includes(searchLower) ||
          clientCompany.toLowerCase().includes(searchLower) ||
          clientName.toLowerCase().includes(searchLower) ||
          returnType.toLowerCase().includes(searchLower);

        const matchesService =
          !filters.service?.length ||
          (project?.service_category &&
            filters.service.includes(project.service_category));

        const matchesStatus =
          !filters.status?.length ||
          (project?.status && filters.status.includes(project.status));

        const matchesPriority =
          !filters.priority?.length ||
          (project?.priority && filters.priority.includes(project.priority));

        const matchesReturnType =
          !filters.returnType?.length ||
          (project?.tax_info?.return_type &&
            filters.returnType.includes(project.tax_info.return_type));

        const matchesReviewStatus =
          !filters.reviewStatus?.length ||
          (project?.tax_info?.review_status &&
            filters.reviewStatus.includes(project.tax_info.review_status));

        const deadline = getProjectDeadline(project);
        const matchesDueThisWeek =
          !filters.dueThisWeek ||
          (deadline && new Date(deadline) <= new Date(endOfWeek(new Date())));

        const matchesDueThisMonth =
          !filters.dueThisMonth ||
          (deadline &&
            new Date(deadline) <= new Date(addMonths(new Date(), 1)));

        const matchesDueThisQuarter =
          !filters.dueThisQuarter ||
          (deadline &&
            new Date(deadline) <= new Date(addMonths(new Date(), 3)));

        const matchesDateRange =
          !filters.dateRange ||
          !deadline ||
          (deadline >= new Date(filters.dateRange.from) &&
            deadline <= new Date(filters.dateRange.to));

        return (
          matchesSearch &&
          matchesService &&
          matchesStatus &&
          matchesPriority &&
          matchesReturnType &&
          matchesReviewStatus &&
          matchesDueThisWeek &&
          matchesDueThisMonth &&
          matchesDueThisQuarter &&
          matchesDateRange
        );
      });
    },
    [filters, getProjectDeadline],
  );

  return {
    projects,
    loading,
    error,
    filters,
    updateFilters,
    resetFilters,
    filterProjects,
    groupProjects,
    refresh: fetchProjects,
    bulkUpdateProjects,
    archiveProjects,
  };
}
```

### `src\hooks\useProjects.ts`

```ts
"use client";

import { useCallback, useState } from "react";
import { getBrowserClient } from "@/lib/supabase/browser-client";
import type { Tables } from "@/types/database.types";
import type { ProjectFormData } from "@/lib/validations/project";

export function useProjects() {
  const supabase = getBrowserClient();
  const [sorting, setSorting] = useState({
    column: "created_at",
    direction: "desc",
  });
  const [filters, setFilters] = useState({});
  const [pagination, setPagination] = useState({ page: 1, pageSize: 10 });

  const buildQuery = useCallback(() => {
    let query = supabase
      .from("projects")
      .select("*, tax_returns(*)", { count: "exact" });

    // Apply filters
    Object.entries(filters).forEach(([key, value]) => {
      if (value) {
        query = query.eq(key, value);
      }
    });

    // Apply sorting
    query = query.order(sorting.column, {
      ascending: sorting.direction === "asc",
    });

    // Apply pagination
    const from = (pagination.page - 1) * pagination.pageSize;
    query = query.range(from, from + pagination.pageSize - 1);

    return query;
  }, [supabase, filters, pagination, sorting]);

  const fetchProjects = useCallback(async () => {
    try {
      const query = buildQuery();
      const { data: projects, count, error } = await query;

      if (error) throw error;

      return { projects: projects || [], count: count || 0 };
    } catch (error) {
      console.error("Error fetching projects:", error);
      return { projects: [], count: 0 };
    }
  }, [buildQuery]);

  const createProject = useCallback(
    async (data: ProjectFormData) => {
      try {
        const { error } = await supabase
          .from("projects")
          .insert(data)
          .select()
          .single();

        if (error) throw error;
      } catch (error) {
        console.error("Error creating project:", error);
        throw error;
      }
    },
    [supabase],
  );

  return {
    fetchProjects,
    createProject,
    setSorting,
    setFilters,
    setPagination,
    sorting,
    filters,
    pagination,
  };
}
```

### `src\hooks\useProjects.tsx`

```tsx
import { useCallback, useEffect, useState } from "react";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import { Database } from "@/types/database.types";
import {
  DbProject,
  ProjectWithRelations,
  ProjectInsert,
  ProjectResponse,
} from "@/types/projects";

export function useProjects(clientId?: string): {
  projects: ProjectWithRelations[];
  isLoading: boolean;
  error: string | null;
  addProject: (project: ProjectInsert) => Promise<ProjectWithRelations>;
  updateProject: (
    id: string,
    updates: Partial<DbProject>,
  ) => Promise<ProjectWithRelations>;
  deleteProject: (id: string) => Promise<void>;
  refreshProjects: () => Promise<void>;
} {
  const [projects, setProjects] = useState<ProjectWithRelations[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const supabase = createClientComponentClient<Database>();

  const fetchProjects = async () => {
    setIsLoading(true);
    try {
      let query = supabase
        .from("projects")
        .select(
          `
          *,
          client:clients (
            id,
            full_name,
            company_name,
            contact_info,
            contact_email,
            type,
            status
          ),
          tasks:tasks!tasks_project_id_fkey (
            id,
            title,
            description,
            status,
            priority,
            due_date,
            assignee_id,
            progress,
            category
          ),
          team_members:project_team_members!project_team_members_project_id_fkey (
            user:users (
              id,
              full_name,
              email,
              role
            )
          )
        `,
        )
        .order("due_date", { ascending: true })
        .neq("status", "archived");

      if (clientId) {
        query = query.eq("client_id", clientId);
      }

      const { data: projectsData, error: projectsError } = await query;

      if (projectsError) {
        console.error("Error fetching projects:", projectsError);
        throw new Error("Failed to fetch projects");
      }

      const projectsWithRelations =
        (projectsData as unknown as ProjectResponse[] | null)?.map(
          (project) => ({
            ...project,
            client: project.client || null,
            tasks: project.tasks || [],
            team_members: project.team_members?.map((tm) => tm.user) || [],
            tax_info: project.tax_info || null,
            accounting_info: project.accounting_info || null,
            payroll_info: project.payroll_info || null,
            service_info: project.service_info || null,
          }),
        ) || [];

      setProjects(projectsWithRelations);
      setError(null);
    } catch (err) {
      const errorMessage =
        err instanceof Error
          ? err.message
          : "An error occurred while fetching projects";
      console.error("Error in fetchProjects:", err);
      setError(errorMessage);
      setProjects([]);
    } finally {
      setIsLoading(false);
    }
  };

  const addProject = async (
    project: ProjectInsert,
  ): Promise<ProjectWithRelations> => {
    const { data, error } = await supabase
      .from("projects")
      .insert(project)
      .select(
        `
        *,
        client:clients (
          id,
          full_name,
          company_name,
          contact_info,
          contact_email,
          type,
          status
        ),
        tasks:tasks!tasks_project_id_fkey (
          id,
          title,
          description,
          status,
          priority,
          due_date,
          assignee_id,
          progress,
          category
        ),
        team_members:project_team_members!project_team_members_project_id_fkey (
          user:users (
            id,
            full_name,
            email,
            role
          )
        )
      `,
      )
      .single();

    if (error) throw error;
    if (!data) throw new Error("No data returned from insert");

    const newProject = {
      ...data,
      client: (data as unknown as ProjectResponse).client || null,
      tasks: (data as unknown as ProjectResponse).tasks || [],
      team_members:
        (data as unknown as ProjectResponse).team_members?.map(
          (tm) => tm.user,
        ) || [],
      tax_info: data.tax_info || null,
      accounting_info: data.accounting_info || null,
      payroll_info: data.payroll_info || null,
      service_info: data.service_info || null,
    } as ProjectWithRelations;

    setProjects((current) => [...current, newProject]);
    return newProject;
  };

  const updateProject = async (
    id: string,
    updates: Partial<DbProject>,
  ): Promise<ProjectWithRelations> => {
    const { data, error } = await supabase
      .from("projects")
      .update(updates)
      .eq("id", id)
      .select(
        `
        *,
        client:clients (
          id,
          full_name,
          company_name,
          contact_info,
          contact_email,
          type,
          status
        ),
        tasks:tasks!tasks_project_id_fkey (
          id,
          title,
          description,
          status,
          priority,
          due_date,
          assignee_id,
          progress,
          category
        ),
        team_members:project_team_members!project_team_members_project_id_fkey (
          user:users (
            id,
            full_name,
            email,
            role
          )
        )
      `,
      )
      .single();

    if (error) throw error;
    if (!data) throw new Error("No data returned from update");

    const updatedProject = {
      ...data,
      client: (data as unknown as ProjectResponse).client || null,
      tasks: (data as unknown as ProjectResponse).tasks || [],
      team_members:
        (data as unknown as ProjectResponse).team_members?.map(
          (tm) => tm.user,
        ) || [],
      tax_info: data.tax_info || null,
      accounting_info: data.accounting_info || null,
      payroll_info: data.payroll_info || null,
      service_info: data.service_info || null,
    } as ProjectWithRelations;

    setProjects((current) =>
      current.map((p) => (p.id === id ? updatedProject : p)),
    );

    return updatedProject;
  };

  const deleteProject = async (id: string): Promise<void> => {
    const { error } = await supabase.from("projects").delete().eq("id", id);

    if (error) throw error;

    setProjects((current) => current.filter((p) => p.id !== id));
  };

  useEffect(() => {
    fetchProjects();
  }, [clientId]);

  return {
    projects,
    isLoading,
    error,
    addProject,
    updateProject,
    deleteProject,
    refreshProjects: fetchProjects,
  };
}
```

### `src\hooks\useProjectSubmission.ts`

```ts
import { useState } from "react";
import { toast } from "sonner";
import {
  ProjectFormValues,
  validateTaskDependencies,
  sortTasksByDependencies,
} from "@/lib/validations/project";

export const useProjectSubmission = (onSuccess: () => void) => {
  const [isLoading, setIsLoading] = useState(false);

  const submitProject = async (values: ProjectFormValues) => {
    setIsLoading(true);

    try {
      // Validate tasks before submission
      if (values.tasks?.length && !validateTaskDependencies(values.tasks)) {
        throw new Error("Invalid task dependencies");
      }

      // Sort tasks by dependencies to ensure correct order
      const sortedTasks = values.tasks
        ? sortTasksByDependencies(values.tasks)
        : [];

      // Prepare project data
      const projectData = {
        creation_type: values.creation_type,
        template_id: values.template_id,
        name: values.name.trim(),
        description: values.description?.trim(),
        client_id: values.client_id,
        status: values.status,
        priority: values.priority,
        due_date: values.due_date?.toISOString(),
        service_type: values.service_type,
        tax_info: values.tax_info || {},
        accounting_info: values.accounting_info || {},
        payroll_info: values.payroll_info || {},
        tax_return_id: values.tax_return_id,
        team_members: values.team_members || [],
        tasks: sortedTasks.map((task, index) => ({
          title: task.title.trim(),
          description: task.description?.trim(),
          priority: task.priority,
          dependencies: task.dependencies || [],
          order_index: index,
          assignee_id: task.assignee_id,
        })),
      };

      // Submit project through API
      const response = await fetch("/api/projects", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(projectData),
      });

      const responseData = await response.json();

      if (!response.ok) {
        throw new Error(responseData.message || "Failed to create project");
      }

      toast.success("Project created successfully");
      onSuccess();
      return { data: responseData, error: null };
    } catch (err) {
      const message =
        err instanceof Error ? err.message : "Failed to create project";
      console.error("Project creation error:", err);
      toast.error(message);
      return { data: null, error: message };
    } finally {
      setIsLoading(false);
    }
  };

  return {
    isLoading,
    submitProject,
  };
};
```

### `src\hooks\useProjectTabProgress.ts`

```ts
import { UseFormReturn } from "react-hook-form";

export function useProjectTabProgress(form: UseFormReturn<any>) {
  const getTabProgress = (tab: string): number => {
    const fields = {
      "basic-info": ["name", "description", "client_id", "priority"],
      "service-details": ["service_type"],
      tasks: ["tasks"],
    };

    const tabFields = fields[tab as keyof typeof fields] || [];
    if (!tabFields.length) return 100;

    const completedFields = tabFields.filter((field) => {
      const value = form.getValues(field);
      return value !== undefined && value !== "" && value !== null;
    });

    return Math.round((completedFields.length / tabFields.length) * 100);
  };

  return { getTabProgress };
}
```

### `src\hooks\useProjectTemplates.ts`

```ts
"use client";

import { useState, useCallback, useEffect } from "react";
import { useAuth } from "@/providers/unified-auth-provider";
import type { Database } from "@/types/database.types";

type ProjectTemplate = Database["public"]["Tables"]["project_templates"]["Row"];

export function useProjectTemplates() {
  const { supabase } = useAuth();
  const [templates, setTemplates] = useState<ProjectTemplate[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  const fetchTemplates = useCallback(async () => {
    try {
      setIsLoading(true);
      const { data, error } = await supabase
        .from("project_templates")
        .select("*")
        .order("created_at", { ascending: false });

      if (error) throw error;
      setTemplates(data || []);
    } catch (e) {
      setError(
        e instanceof Error ? e : new Error("Failed to fetch project templates"),
      );
    } finally {
      setIsLoading(false);
    }
  }, [supabase]);

  useEffect(() => {
    fetchTemplates();
  }, [fetchTemplates]);

  const createTemplate = useCallback(
    async (templateData: Partial<ProjectTemplate>) => {
      try {
        const { data, error } = await supabase
          .from("project_templates")
          .insert([templateData])
          .select()
          .single();

        if (error) throw error;
        setTemplates((prev) => [data, ...prev]);
        return data;
      } catch (e) {
        throw e instanceof Error
          ? e
          : new Error("Failed to create project template");
      }
    },
    [supabase],
  );

  const updateTemplate = useCallback(
    async (id: string, templateData: Partial<ProjectTemplate>) => {
      try {
        const { data, error } = await supabase
          .from("project_templates")
          .update(templateData)
          .eq("id", id)
          .select()
          .single();

        if (error) throw error;
        setTemplates((prev) =>
          prev.map((template) => (template.id === id ? data : template)),
        );
        return data;
      } catch (e) {
        throw e instanceof Error
          ? e
          : new Error("Failed to update project template");
      }
    },
    [supabase],
  );

  const deleteTemplate = useCallback(
    async (id: string) => {
      try {
        const { error } = await supabase
          .from("project_templates")
          .delete()
          .eq("id", id);

        if (error) throw error;
        setTemplates((prev) => prev.filter((template) => template.id !== id));
      } catch (e) {
        throw e instanceof Error
          ? e
          : new Error("Failed to delete project template");
      }
    },
    [supabase],
  );

  return {
    templates,
    isLoading,
    error,
    createTemplate,
    updateTemplate,
    deleteTemplate,
    refetch: fetchTemplates,
  };
}
```

### `src\hooks\useServiceFields.ts`

```ts
import { UseFormReturn } from "react-hook-form";
import { ProjectFormValues, ServiceType, ServiceCategory } from "@/types/hooks";

export function useServiceFields(form: UseFormReturn<ProjectFormValues>) {
  const handleServiceTypeChange = (
    currentType: ServiceType | ServiceCategory,
  ) => {
    if (currentType !== "uncategorized") {
      // Reset specific service fields based on type
      switch (currentType) {
        case "tax_return":
          form.setValue("tax_return_id", undefined);
          form.setValue("tax_return_status", undefined);
          break;
        case "accounting":
          form.setValue("accounting_period", undefined);
          break;
        // Add other service type specific resets
      }
    }
  };

  const calculateProgress = (serviceType: string) => {
    // Progress calculation logic
    return 50; // Placeholder
  };

  const validateServiceSpecificFields = () => {
    const currentType = form.getValues("service_type");
    const currentTasks = form.getValues("tasks") || [];

    if (currentType !== "uncategorized" && currentTasks.length > 0) {
      // Validation logic
      return true;
    }

    return false;
  };

  return {
    handleServiceTypeChange,
    calculateProgress,
    validateServiceSpecificFields,
  };
}
```

### `src\hooks\useSmartProjectFilters.ts`

```ts
import { useCallback } from "react";
import { ProjectFilters } from "@/types/hooks";
import { ProjectWithRelations } from "@/types/projects";

export function useSmartProjectFilters() {
  const suggestFilters = useCallback(
    async (projects: ProjectWithRelations[]) => {
      try {
        // Analyze project patterns and suggest relevant filters
        const patterns = analyzeProjectPatterns(projects);

        return {
          recommendedFilters: patterns.map((pattern) => ({
            type: pattern.type,
            value: pattern.value,
            confidence: pattern.confidence,
            reason: pattern.reason,
          })),
          autoGroups: generateSmartGroups(projects),
        };
      } catch (error) {
        console.error("Error suggesting filters:", error);
        return null;
      }
    },
    [],
  );

  return {
    suggestFilters,
  };
}
```

### `src\hooks\useSmartTemplates.ts`

```ts
import { useCallback } from "react";
import { ProjectTemplate } from "@/types/projects";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";

export function useSmartTemplates() {
  const supabase = createClientComponentClient();

  const suggestTemplate = useCallback(
    async (projectData: any) => {
      try {
        // Analyze project requirements and suggest best template
        const analysis = await analyzeProjectRequirements(projectData);
        const recommendations = generateTemplateRecommendations(analysis);

        return {
          suggestedTemplate: recommendations.bestMatch,
          alternatives: recommendations.alternatives,
          customizations: recommendations.suggestedCustomizations,
        };
      } catch (error) {
        console.error("Error suggesting template:", error);
        return null;
      }
    },
    [supabase],
  );

  return {
    suggestTemplate,
  };
}
```

### `src\hooks\useStorage.ts`

```ts
import { useState } from "react";
import { StorageService } from "@/lib/storage/storage";
import { type FileObject } from "@supabase/storage-js";

interface UseStorageReturn {
  uploadFile: (file: File, path: string) => Promise<FileObject | null>;
  downloadFile: (path: string) => Promise<Blob | null>;
  deleteFile: (path: string) => Promise<boolean>;
  listFiles: (prefix?: string) => Promise<FileObject[] | null>;
  getPublicUrl: (path: string) => string | null;
  loading: boolean;
  error: Error | null;
}

export function useStorage(): UseStorageReturn {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  const storageService = StorageService.getInstance();

  const handleOperation = async <T>(
    operation: () => Promise<T>,
    errorMessage: string,
  ): Promise<T | null> => {
    setLoading(true);
    setError(null);
    try {
      const result = await operation();
      return result;
    } catch (err) {
      console.error(errorMessage, err);
      setError(err instanceof Error ? err : new Error(errorMessage));
      return null;
    } finally {
      setLoading(false);
    }
  };

  const uploadFile = async (file: File, path: string) => {
    return handleOperation(
      () => storageService.uploadFile(file, path),
      "Error uploading file",
    );
  };

  const downloadFile = async (path: string) => {
    return handleOperation(
      () => storageService.downloadFile(path),
      "Error downloading file",
    );
  };

  const deleteFile = async (path: string) => {
    return handleOperation(
      () => storageService.deleteFile(path),
      "Error deleting file",
    );
  };

  const listFiles = async (prefix?: string) => {
    return handleOperation(
      () => storageService.listFiles(prefix),
      "Error listing files",
    );
  };

  const getPublicUrl = (path: string) => {
    try {
      return storageService.getPublicUrl(path);
    } catch (err) {
      console.error("Error getting public URL:", err);
      setError(
        err instanceof Error ? err : new Error("Error getting public URL"),
      );
      return null;
    }
  };

  return {
    uploadFile,
    downloadFile,
    deleteFile,
    listFiles,
    getPublicUrl,
    loading,
    error,
  };
}
```

### `src\hooks\useTaskManagement.ts`

```ts
"use client";

import { useCallback } from "react";
import { useForm } from "react-hook-form";
import { TaskSchema } from "@/types/tasks";

export function useTaskManagement() {
  const form = useForm<{ tasks: TaskSchema[] }>();

  const validateTaskDependencies = useCallback((tasks: TaskSchema[]) => {
    const errors: Record<string, { message: string; type: string }> = {};

    tasks.forEach((task) => {
      // Validate dates
      if (task.start_date && isNaN(new Date(task.start_date).getTime())) {
        errors[task.id] = {
          message: "Invalid start date format",
          type: "date",
        };
      }

      if (task.due_date && isNaN(new Date(task.due_date).getTime())) {
        errors[task.id] = {
          message: "Invalid due date format",
          type: "date",
        };
      }

      // Validate date order
      if (task.start_date && task.due_date) {
        const start = new Date(task.start_date);
        const due = new Date(task.due_date);
        if (start > due) {
          errors[task.id] = {
            message: "Start date must be before due date",
            type: "date",
          };
        }
      }
    });

    return errors;
  }, []);

  const addTask = useCallback(
    (task: Partial<TaskSchema>) => {
      const currentTasks = form.getValues("tasks") || [];
      const newId = crypto.randomUUID?.() || `${Date.now()}-${Math.random()}`;

      const newTask: TaskSchema = {
        id: task.id || newId,
        title: task.title || "",
        description: task.description || "",
        status: task.status || "todo",
        priority: task.priority || "medium",
        dependencies: task.dependencies || [],
        start_date: task.start_date,
        due_date: task.due_date,
      };

      const errors = validateTaskDependencies([...currentTasks, newTask]);
      if (Object.keys(errors).length > 0) {
        return { success: false, errors };
      }

      form.setValue("tasks", [...currentTasks, newTask]);
      return { success: true };
    },
    [form, validateTaskDependencies],
  );

  const removeTask = useCallback(
    (taskId: string) => {
      const currentTasks = form.getValues("tasks") || [];
      form.setValue(
        "tasks",
        currentTasks.filter((t) => t.id !== taskId),
      );
    },
    [form],
  );

  const updateTask = useCallback(
    (taskId: string, updates: Partial<TaskSchema>) => {
      const currentTasks = form.getValues("tasks") || [];
      const taskIndex = currentTasks.findIndex((t) => t.id === taskId);

      if (taskIndex === -1) return { success: false, error: "Task not found" };

      const updatedTask = { ...currentTasks[taskIndex], ...updates };
      const updatedTasks = [...currentTasks];
      updatedTasks[taskIndex] = updatedTask;

      const errors = validateTaskDependencies(updatedTasks);
      if (Object.keys(errors).length > 0) {
        return { success: false, errors };
      }

      form.setValue("tasks", updatedTasks);
      return { success: true };
    },
    [form, validateTaskDependencies],
  );

  return {
    form,
    addTask,
    removeTask,
    updateTask,
  };
}
```

### `src\hooks\useTaskRelations.ts`

```ts
"use client";

import { useState } from "react";
import { supabaseBrowserClient } from "@/lib/supabaseBrowserClient";
import type { Database } from "@/types/database.types";

type TaskRelation = Database["public"]["Tables"]["task_relations"]["Row"];
type TaskRelationInsert =
  Database["public"]["Tables"]["task_relations"]["Insert"];

export function useTaskRelations() {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  async function getTaskRelations(taskId: string) {
    setLoading(true);
    try {
      const { data, error } = await supabaseBrowserClient
        .from("task_relations")
        .select("*")
        .eq("task_id", taskId);

      if (error) throw error;
      return data;
    } catch (err) {
      setError(err as Error);
      throw err;
    } finally {
      setLoading(false);
    }
  }

  async function createTaskRelation(relation: TaskRelationInsert) {
    setLoading(true);
    try {
      const { data, error } = await supabaseBrowserClient
        .from("task_relations")
        .insert(relation)
        .select()
        .single();

      if (error) throw error;
      return data;
    } catch (err) {
      setError(err as Error);
      throw err;
    } finally {
      setLoading(false);
    }
  }

  async function updateTaskRelation(
    id: string,
    updates: Partial<TaskRelation>,
  ) {
    setLoading(true);
    try {
      const { data, error } = await supabaseBrowserClient
        .from("task_relations")
        .update(updates)
        .eq("id", id)
        .select()
        .single();

      if (error) throw error;
      return data;
    } catch (err) {
      setError(err as Error);
      throw err;
    } finally {
      setLoading(false);
    }
  }

  async function deleteTaskRelation(id: string) {
    setLoading(true);
    try {
      const { error } = await supabaseBrowserClient
        .from("task_relations")
        .delete()
        .eq("id", id);

      if (error) throw error;
    } catch (err) {
      setError(err as Error);
      throw err;
    } finally {
      setLoading(false);
    }
  }

  return {
    loading,
    error,
    getTaskRelations,
    createTaskRelation,
    updateTaskRelation,
    deleteTaskRelation,
  };
}
```

### `src\hooks\useTasks.ts`

```ts
"use client";

import { useState } from "react";
import { supabaseBrowserClient } from "@/lib/supabaseBrowserClient";
import type { Database } from "@/types/database.types";

type Task = Database["public"]["Tables"]["tasks"]["Row"];
type TaskInsert = Database["public"]["Tables"]["tasks"]["Insert"];

export function useTasks() {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  async function getTasks() {
    setLoading(true);
    try {
      const { data, error } = await supabaseBrowserClient
        .from("tasks")
        .select("*")
        .order("created_at", { ascending: false });

      if (error) throw error;
      return data;
    } catch (err) {
      setError(err as Error);
      throw err;
    } finally {
      setLoading(false);
    }
  }

  async function getTasksByProject(projectId: string) {
    setLoading(true);
    try {
      const { data, error } = await supabaseBrowserClient
        .from("tasks")
        .select("*")
        .eq("project_id", projectId)
        .order("created_at", { ascending: false });

      if (error) throw error;
      return data;
    } catch (err) {
      setError(err as Error);
      throw err;
    } finally {
      setLoading(false);
    }
  }

  async function createTask(task: TaskInsert) {
    setLoading(true);
    try {
      const { data, error } = await supabaseBrowserClient
        .from("tasks")
        .insert(task)
        .select()
        .single();

      if (error) throw error;
      return data;
    } catch (err) {
      setError(err as Error);
      throw err;
    } finally {
      setLoading(false);
    }
  }

  async function updateTask(id: string, updates: Partial<Task>) {
    setLoading(true);
    try {
      const { data, error } = await supabaseBrowserClient
        .from("tasks")
        .update(updates)
        .eq("id", id)
        .select()
        .single();

      if (error) throw error;
      return data;
    } catch (err) {
      setError(err as Error);
      throw err;
    } finally {
      setLoading(false);
    }
  }

  async function deleteTask(id: string) {
    setLoading(true);
    try {
      const { error } = await supabaseBrowserClient
        .from("tasks")
        .delete()
        .eq("id", id);

      if (error) throw error;
    } catch (err) {
      setError(err as Error);
      throw err;
    } finally {
      setLoading(false);
    }
  }

  return {
    loading,
    error,
    getTasks,
    getTasksByProject,
    createTask,
    updateTask,
    deleteTask,
  };
}
```

### `src\hooks\useTaskValidation.ts`

```ts
import { useState } from "react";
import { type TaskSchema } from "@/lib/validations/project";

export type TaskDependencyError = Record<string, string>;

export const useTaskValidation = () => {
  const [taskDependencyErrors, setTaskDependencyErrors] =
    useState<TaskDependencyError>({});

  const detectCircularDependencies = (
    tasks: TaskSchema[],
    taskId: string,
    visited: Set<string>,
    path: string[],
  ): boolean => {
    if (visited.has(taskId)) {
      if (path.includes(taskId)) {
        // Found a circular dependency
        const cycle = path.slice(path.indexOf(taskId));
        cycle.push(taskId);
        return true;
      }
      return false;
    }

    visited.add(taskId);
    path.push(taskId);

    const task = tasks.find((t) => t.title === taskId);
    if (task?.dependencies) {
      for (const depId of task.dependencies) {
        if (detectCircularDependencies(tasks, depId, visited, path)) {
          return true;
        }
      }
    }

    path.pop();
    return false;
  };

  const validateTaskDependencies = (tasks: TaskSchema[] | undefined) => {
    if (!tasks || tasks.length === 0) return true;

    const errors: TaskDependencyError = {};

    tasks.forEach((task) => {
      // Ensure dependencies is an array
      if (task.dependencies && !Array.isArray(task.dependencies)) {
        errors[task.title] = "Dependencies must be an array";
        return;
      }

      // Validate dependency IDs exist in the task list
      if (task.dependencies) {
        const invalidDeps = task.dependencies.filter(
          (dep) => !tasks.some((t) => t.title === dep),
        );
        if (invalidDeps.length > 0) {
          errors[task.title] =
            `Invalid dependencies: ${invalidDeps.join(", ")}`;
          return;
        }

        // Check for circular dependencies
        const visited = new Set<string>();
        if (detectCircularDependencies(tasks, task.title, visited, [])) {
          errors[task.title] = "Circular dependency detected";
          return;
        }
      }

      // Validate task order if provided
      if (task.order_index !== undefined) {
        const duplicateOrder = tasks.some(
          (t) => t !== task && t.order_index === task.order_index,
        );
        if (duplicateOrder) {
          errors[task.title] = "Duplicate task order detected";
        }
      }
    });

    setTaskDependencyErrors(errors);
    return Object.keys(errors).length === 0;
  };

  return {
    taskDependencyErrors,
    validateTaskDependencies,
  };
};
```

### `src\hooks\useTaxProjectManagement.ts`

```ts
"use client";

import { useState, useCallback } from "react";
import { addDays, isAfter, isBefore, startOfDay } from "date-fns";
import { ProjectWithRelations, TaxReturnType } from "@/types/projects";

// Constants for tax deadlines
const TAX_DEADLINES = {
  "1040": {
    normal: "04-15",
    extended: "10-15",
  },
  "1120": {
    normal: "03-15",
    extended: "09-15",
  },
  "1065": {
    normal: "03-15",
    extended: "09-15",
  },
  "1120S": {
    normal: "03-15",
    extended: "09-15",
  },
};

const ESTIMATED_TAX_DEADLINES = ["04-15", "06-15", "09-15", "01-15"];

export function useTaxProjectManagement() {
  const [view, setView] = useState<
    "deadline" | "return_type" | "review_status"
  >("deadline");

  const getDeadline = useCallback(
    (returnType: TaxReturnType, isExtended: boolean = false): Date => {
      const currentYear = new Date().getFullYear();
      const deadlineType = isExtended ? "extended" : "normal";
      const monthDay = TAX_DEADLINES[returnType]?.[deadlineType] || "04-15";
      return new Date(`${currentYear}-${monthDay}`);
    },
    [],
  );

  const getNextEstimatedTaxDeadline = useCallback(() => {
    const today = startOfDay(new Date());
    const currentYear = today.getFullYear();

    for (const deadline of ESTIMATED_TAX_DEADLINES) {
      const deadlineDate = new Date(`${currentYear}-${deadline}`);
      if (isAfter(deadlineDate, today)) {
        return deadlineDate;
      }
    }

    // If all deadlines have passed, return first deadline of next year
    return new Date(`${currentYear + 1}-${ESTIMATED_TAX_DEADLINES[0]}`);
  }, []);

  const groupProjectsByDeadline = useCallback(
    (projects: ProjectWithRelations[]) => {
      const groups: Record<string, ProjectWithRelations[]> = {
        "Due This Week": [],
        "Due This Month": [],
        "Due Later": [],
        "Past Due": [],
      };

      const today = startOfDay(new Date());
      const nextWeek = addDays(today, 7);
      const nextMonth = addDays(today, 30);

      projects.forEach((project) => {
        if (!project.tax_info?.filing_deadline) return;

        const deadline = new Date(project.tax_info.filing_deadline);

        if (isBefore(deadline, today)) {
          groups["Past Due"].push(project);
        } else if (isBefore(deadline, nextWeek)) {
          groups["Due This Week"].push(project);
        } else if (isBefore(deadline, nextMonth)) {
          groups["Due This Month"].push(project);
        } else {
          groups["Due Later"].push(project);
        }
      });

      return groups;
    },
    [],
  );

  const groupProjectsByReturnType = useCallback(
    (projects: ProjectWithRelations[]) => {
      return projects.reduce(
        (groups, project) => {
          const returnType = project.tax_info?.return_type || "Other";
          if (!groups[returnType]) {
            groups[returnType] = [];
          }
          groups[returnType].push(project);
          return groups;
        },
        {} as Record<string, ProjectWithRelations[]>,
      );
    },
    [],
  );

  const groupProjectsByReviewStatus = useCallback(
    (projects: ProjectWithRelations[]) => {
      return projects.reduce(
        (groups, project) => {
          const status = project.tax_info?.review_status || "Not Started";
          if (!groups[status]) {
            groups[status] = [];
          }
          groups[status].push(project);
          return groups;
        },
        {} as Record<string, ProjectWithRelations[]>,
      );
    },
    [],
  );

  return {
    view,
    setView,
    getDeadline,
    getNextEstimatedTaxDeadline,
    groupProjectsByDeadline,
    groupProjectsByReturnType,
    groupProjectsByReviewStatus,
  };
}
```

### `src\hooks\useTaxReturns.ts`

```ts
"use client";

import { useState, useEffect } from "react";
import { supabaseBrowserClient } from "@/lib/supabaseBrowserClient";
import { handleError } from "@/lib/error-handler";
import { Database } from "@/types/database.types";

type TaxReturn = Database["public"]["Tables"]["tax_returns"]["Row"];

export function useTaxReturns(initialReturns?: TaxReturn[] | null) {
  const [taxReturns, setTaxReturns] = useState<TaxReturn[]>(
    initialReturns || [],
  );
  const [loading, setLoading] = useState(!initialReturns);
  const [error, setError] = useState("");

  useEffect(() => {
    if (!initialReturns) {
      fetchTaxReturns();
    }

    const channel = supabaseBrowserClient
      .channel("tax_returns")
      .on(
        "postgres_changes",
        { event: "*", schema: "public", table: "tax_returns" },
        () => {
          fetchTaxReturns();
        },
      )
      .subscribe();

    return () => {
      channel.unsubscribe();
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  async function fetchTaxReturns() {
    setLoading(true);
    try {
      const { data, error } = await supabaseBrowserClient
        .from("tax_returns")
        .select("*");
      if (error) throw error;
      if (data) setTaxReturns(data);
    } catch (err: any) {
      setError(handleError(err).message);
    } finally {
      setLoading(false);
    }
  }

  async function createReturn(newReturn: Partial<TaxReturn>) {
    try {
      setLoading(true);
      const { error } = await supabaseBrowserClient
        .from("tax_returns")
        .insert(newReturn);
      if (error) throw error;
      await fetchTaxReturns();
    } catch (err: any) {
      setError(handleError(err).message);
    } finally {
      setLoading(false);
    }
  }

  async function updateReturn(
    returnId: string,
    updatedFields: Partial<TaxReturn>,
  ) {
    try {
      setLoading(true);
      const { error } = await supabaseBrowserClient
        .from("tax_returns")
        .update(updatedFields)
        .eq("id", returnId);
      if (error) throw error;
      await fetchTaxReturns();
    } catch (err: any) {
      setError(handleError(err).message);
    } finally {
      setLoading(false);
    }
  }

  async function deleteReturn(returnId: string) {
    try {
      setLoading(true);
      const { error } = await supabaseBrowserClient
        .from("tax_returns")
        .delete()
        .eq("id", returnId);
      if (error) throw error;
      await fetchTaxReturns();
    } catch (err: any) {
      setError(handleError(err).message);
    } finally {
      setLoading(false);
    }
  }

  return {
    taxReturns,
    loading,
    error,
    createReturn,
    updateReturn,
    deleteReturn,
  };
}
```

### `src\hooks\useTemplateTasks.ts`

```ts
"use client";

import { useState, useCallback, useEffect } from "react";
import { useAuth } from "@/providers/unified-auth-provider";
import type { Database } from "@/types/database.types";

type TemplateTask = Database["public"]["Tables"]["template_tasks"]["Row"];

export function useTemplateTasks(templateId: string) {
  const { supabase } = useAuth();
  const [tasks, setTasks] = useState<TemplateTask[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  const fetchTasks = useCallback(async () => {
    try {
      setIsLoading(true);
      const { data, error } = await supabase
        .from("template_tasks")
        .select("*")
        .eq("template_id", templateId)
        .order("created_at", { ascending: false });

      if (error) throw error;
      setTasks(data || []);
    } catch (e) {
      setError(
        e instanceof Error ? e : new Error("Failed to fetch template tasks"),
      );
    } finally {
      setIsLoading(false);
    }
  }, [supabase, templateId]);

  useEffect(() => {
    fetchTasks();
  }, [fetchTasks]);

  const createTask = useCallback(
    async (taskData: Partial<TemplateTask>) => {
      try {
        const { data, error } = await supabase
          .from("template_tasks")
          .insert([{ ...taskData, template_id: templateId }])
          .select()
          .single();

        if (error) throw error;
        setTasks((prev) => [data, ...prev]);
        return data;
      } catch (e) {
        throw e instanceof Error
          ? e
          : new Error("Failed to create template task");
      }
    },
    [supabase, templateId],
  );

  const updateTask = useCallback(
    async (id: string, taskData: Partial<TemplateTask>) => {
      try {
        const { data, error } = await supabase
          .from("template_tasks")
          .update(taskData)
          .eq("id", id)
          .select()
          .single();

        if (error) throw error;
        setTasks((prev) => prev.map((task) => (task.id === id ? data : task)));
        return data;
      } catch (e) {
        throw e instanceof Error
          ? e
          : new Error("Failed to update template task");
      }
    },
    [supabase],
  );

  const deleteTask = useCallback(
    async (id: string) => {
      try {
        const { error } = await supabase
          .from("template_tasks")
          .delete()
          .eq("id", id);

        if (error) throw error;
        setTasks((prev) => prev.filter((task) => task.id !== id));
      } catch (e) {
        throw e instanceof Error
          ? e
          : new Error("Failed to delete template task");
      }
    },
    [supabase],
  );

  return {
    tasks,
    isLoading,
    error,
    createTask,
    updateTask,
    deleteTask,
    refetch: fetchTasks,
  };
}
```

### `src\hooks\useTimeEntries.ts`

```ts
import { useState } from "react";
import { supabaseBrowserClient } from "@/lib/supabaseBrowserClient";
import type { Database } from "@/types/database.types";

type TimeEntry = Database["public"]["Tables"]["time_entries"]["Row"];
type TimeEntryInsert = Database["public"]["Tables"]["time_entries"]["Insert"];

export function useTimeEntries() {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  async function getTimeEntries(taskId?: string) {
    setLoading(true);
    try {
      const {
        data: { user },
      } = await supabaseBrowserClient.auth.getUser();
      if (!user) throw new Error("User not authenticated");

      let query = supabaseBrowserClient
        .from("time_entries")
        .select("*")
        .eq("user_id", user.id)
        .order("start_time", { ascending: false });

      if (taskId) {
        query = query.eq("task_id", taskId);
      }

      const { data, error } = await query;
      if (error) throw error;
      return data;
    } catch (err) {
      setError(err as Error);
      throw err;
    } finally {
      setLoading(false);
    }
  }

  async function createTimeEntry(entry: TimeEntryInsert) {
    setLoading(true);
    try {
      const { data, error } = await supabaseBrowserClient
        .from("time_entries")
        .insert(entry)
        .select()
        .single();

      if (error) throw error;
      return data;
    } catch (err) {
      setError(err as Error);
      throw err;
    } finally {
      setLoading(false);
    }
  }

  async function updateTimeEntry(id: string, updates: Partial<TimeEntry>) {
    setLoading(true);
    try {
      const { data, error } = await supabaseBrowserClient
        .from("time_entries")
        .update(updates)
        .eq("id", id)
        .select()
        .single();

      if (error) throw error;
      return data;
    } catch (err) {
      setError(err as Error);
      throw err;
    } finally {
      setLoading(false);
    }
  }

  async function deleteTimeEntry(id: string) {
    setLoading(true);
    try {
      const { error } = await supabaseBrowserClient
        .from("time_entries")
        .delete()
        .eq("id", id);

      if (error) throw error;
    } catch (err) {
      setError(err as Error);
      throw err;
    } finally {
      setLoading(false);
    }
  }

  return {
    loading,
    error,
    getTimeEntries,
    createTimeEntry,
    updateTimeEntry,
    deleteTimeEntry,
  };
}
```

### `src\hooks\useUsers.ts`

```ts
"use client";

import { useState } from "react";
import { supabaseBrowserClient } from "@/lib/supabaseBrowserClient";
import type { Database } from "@/types/database.types";

type User = Database["public"]["Tables"]["users"]["Row"];
type UserInsert = Database["public"]["Tables"]["users"]["Insert"];

export function useUsers() {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  async function getCurrentUser() {
    setLoading(true);
    try {
      const {
        data: { user },
        error,
      } = await supabaseBrowserClient.auth.getUser();
      if (error) throw error;
      if (!user) throw new Error("No user found");
      return user;
    } catch (err) {
      setError(err as Error);
      throw err;
    } finally {
      setLoading(false);
    }
  }

  async function getUsers() {
    setLoading(true);
    try {
      const { data, error } = await supabaseBrowserClient
        .from("users")
        .select("*")
        .order("created_at", { ascending: false });

      if (error) throw error;
      return data;
    } catch (err) {
      setError(err as Error);
      throw err;
    } finally {
      setLoading(false);
    }
  }

  async function createUser(user: UserInsert) {
    setLoading(true);
    try {
      const { data, error } = await supabaseBrowserClient
        .from("users")
        .insert(user)
        .select()
        .single();

      if (error) throw error;
      return data;
    } catch (err) {
      setError(err as Error);
      throw err;
    } finally {
      setLoading(false);
    }
  }

  async function updateUser(id: string, updates: Partial<User>) {
    setLoading(true);
    try {
      const { data, error } = await supabaseBrowserClient
        .from("users")
        .update(updates)
        .eq("id", id)
        .select()
        .single();

      if (error) throw error;
      return data;
    } catch (err) {
      setError(err as Error);
      throw err;
    } finally {
      setLoading(false);
    }
  }

  async function deleteUser(id: string) {
    setLoading(true);
    try {
      const { error } = await supabaseBrowserClient
        .from("users")
        .delete()
        .eq("id", id);

      if (error) throw error;
    } catch (err) {
      setError(err as Error);
      throw err;
    } finally {
      setLoading(false);
    }
  }

  return {
    loading,
    error,
    getCurrentUser,
    getUsers,
    createUser,
    updateUser,
    deleteUser,
  };
}
```

### `src\hooks\useWorkflows.ts`

```ts
import { useState } from "react";
import { supabaseBrowserClient } from "@/lib/supabaseBrowserClient";
import type { Database } from "@/types/database.types";

type Workflow = Database["public"]["Tables"]["workflows"]["Row"];
type WorkflowInsert = Database["public"]["Tables"]["workflows"]["Insert"];

export function useWorkflows() {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  async function getWorkflows() {
    setLoading(true);
    try {
      const { data, error } = await supabaseBrowserClient
        .from("workflows")
        .select("*")
        .order("created_at", { ascending: false });

      if (error) throw error;
      return data;
    } catch (err) {
      setError(err as Error);
      throw err;
    } finally {
      setLoading(false);
    }
  }

  async function createWorkflow(workflow: WorkflowInsert) {
    setLoading(true);
    try {
      const { data, error } = await supabaseBrowserClient
        .from("workflows")
        .insert(workflow)
        .select()
        .single();

      if (error) throw error;
      return data;
    } catch (err) {
      setError(err as Error);
      throw err;
    } finally {
      setLoading(false);
    }
  }

  async function updateWorkflow(id: string, updates: Partial<Workflow>) {
    setLoading(true);
    try {
      const { data, error } = await supabaseBrowserClient
        .from("workflows")
        .update(updates)
        .eq("id", id)
        .select()
        .single();

      if (error) throw error;
      return data;
    } catch (err) {
      setError(err as Error);
      throw err;
    } finally {
      setLoading(false);
    }
  }

  async function deleteWorkflow(id: string) {
    setLoading(true);
    try {
      const { error } = await supabaseBrowserClient
        .from("workflows")
        .delete()
        .eq("id", id);

      if (error) throw error;
    } catch (err) {
      setError(err as Error);
      throw err;
    } finally {
      setLoading(false);
    }
  }

  return {
    loading,
    error,
    getWorkflows,
    createWorkflow,
    updateWorkflow,
    deleteWorkflow,
  };
}
```

### `src\hooks\__tests__\useProjects.test.ts`

```ts
import { renderHook, act } from "@testing-library/react";
import { useProjects } from "../useProjects";
import { ProjectWithRelations } from "@/types/projects";
import { Database } from "@/types/database.types";
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";

// Mock Supabase client
jest.mock("@supabase/auth-helpers-nextjs", () => ({
  createClientComponentClient: jest.fn(),
}));

interface MockSupabaseClient {
  from: jest.Mock;
  select: jest.Mock;
  in: jest.Mock;
  eq: jest.Mock;
  or: jest.Mock;
  gte: jest.Mock;
  lte: jest.Mock;
  order: jest.Mock;
  range: jest.Mock;
  single: jest.Mock;
  insert: jest.Mock;
  update: jest.Mock;
  delete: jest.Mock;
}

describe("useProjects", () => {
  const mockSupabase = {
    from: jest.fn(() => mockSupabase),
    select: jest.fn(() => mockSupabase),
    in: jest.fn(() => mockSupabase),
    eq: jest.fn(() => mockSupabase),
    or: jest.fn(() => mockSupabase),
    gte: jest.fn(() => mockSupabase),
    lte: jest.fn(() => mockSupabase),
    order: jest.fn(() => mockSupabase),
    range: jest.fn(() => mockSupabase),
    single: jest.fn(() => mockSupabase),
    insert: jest.fn(() => mockSupabase),
    update: jest.fn(() => mockSupabase),
    delete: jest.fn(() => mockSupabase),
  } as MockSupabaseClient;

  const mockProjects: Partial<ProjectWithRelations>[] = [
    {
      id: "1",
      name: "Project 1",
      client_id: "client1",
      status: "in_progress",
      service_type: "tax_return",
      tax_return_id: 1,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
    },
    {
      id: "2",
      name: "Project 2",
      client_id: "client2",
      status: "not_started",
      service_type: "accounting",
      tax_return_id: null,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
    },
  ];

  const mockTaxReturns: Database["public"]["Tables"]["tax_returns"]["Row"][] = [
    {
      id: 1,
      tax_year: 2024,
      filing_type: "1040",
      status: "in_progress",
      client_id: "client1",
      created_at: new Date().toISOString(),
      updated_at: null,
      assigned_to: null,
      due_date: null,
      extension_date: null,
      filed_date: null,
      notes: null,
    },
  ];

  beforeEach(() => {
    jest.clearAllMocks();
    (createClientComponentClient as jest.Mock).mockReturnValue(mockSupabase);
  });

  it("fetches projects successfully", async () => {
    mockSupabase.select.mockResolvedValueOnce({
      data: mockProjects,
      error: null,
      count: mockProjects.length,
    });

    mockSupabase.select.mockResolvedValueOnce({
      data: mockTaxReturns,
      error: null,
    });

    const { result } = renderHook(() => useProjects({}));

    await act(async () => {
      await new Promise((resolve) => setTimeout(resolve, 0));
    });

    expect(result.current.projects).toHaveLength(mockProjects.length);
    expect(result.current.loading).toBe(false);
    expect(result.current.totalCount).toBe(mockProjects.length);
    expect(result.current.projects[0].tax_return).toEqual(mockTaxReturns[0]);
  });

  it("handles fetch error", async () => {
    mockSupabase.select.mockResolvedValueOnce({
      data: null,
      error: new Error("Failed to fetch projects"),
      count: null,
    });

    const { result } = renderHook(() => useProjects({}));

    await act(async () => {
      await new Promise((resolve) => setTimeout(resolve, 0));
    });

    expect(result.current.loading).toBe(false);
    expect(result.current.projects).toEqual([]);
  });

  it("filters projects by status", async () => {
    const filteredProjects = mockProjects.filter(
      (p) => p.status === "in_progress",
    );
    mockSupabase.select.mockResolvedValueOnce({
      data: filteredProjects,
      error: null,
      count: filteredProjects.length,
    });

    mockSupabase.select.mockResolvedValueOnce({
      data: mockTaxReturns,
      error: null,
    });

    const { result } = renderHook(() =>
      useProjects({ status: ["in_progress"] }),
    );

    await act(async () => {
      await new Promise((resolve) => setTimeout(resolve, 0));
    });

    expect(result.current.projects).toHaveLength(1);
    expect(result.current.projects[0].status).toBe("in_progress");
  });

  it("filters projects by service type", async () => {
    const filteredProjects = mockProjects.filter(
      (p) => p.service_type === "tax_return",
    );
    mockSupabase.select.mockResolvedValueOnce({
      data: filteredProjects,
      error: null,
      count: filteredProjects.length,
    });

    mockSupabase.select.mockResolvedValueOnce({
      data: mockTaxReturns,
      error: null,
    });

    const { result } = renderHook(() =>
      useProjects({ serviceType: ["tax_return"] }),
    );

    await act(async () => {
      await new Promise((resolve) => setTimeout(resolve, 0));
    });

    expect(result.current.projects).toHaveLength(1);
    expect(result.current.projects[0].service_type).toBe("tax_return");
    expect(result.current.projects[0].tax_return).toEqual(mockTaxReturns[0]);
  });
});
```

### `src\hooks\__tests__\useProjectSubmission.test.ts`

```ts
import { jest } from "@jest/globals";
import { renderHook, act } from "@testing-library/react";
import { useProjectSubmission } from "../useProjectSubmission";
import { ProjectFormValues } from "@/lib/validations/project";

// Mock fetch globally
global.fetch = jest.fn() as jest.Mock;

describe("useProjectSubmission", () => {
  const mockOnSuccess = jest.fn();

  beforeEach(() => {
    jest.clearAllMocks();
  });

  const mockProjectData: ProjectFormValues = {
    creation_type: "custom",
    name: "Test Project",
    client_id: "client-123",
    status: "not_started",
    priority: "medium",
    service_type: "tax_return",
    tax_info: {},
    tasks: [
      {
        title: "Task 1",
        priority: "medium",
        dependencies: [],
      },
    ],
  };

  it("should successfully create a project", async () => {
    const mockResponse = { id: "project-123", ...mockProjectData };
    (global.fetch as jest.Mock).mockResolvedValueOnce({
      ok: true,
      json: async () => mockResponse,
    });

    const { result } = renderHook(() => useProjectSubmission(mockOnSuccess));

    let submissionResult;
    await act(async () => {
      submissionResult = await result.current.submitProject(mockProjectData);
    });

    expect(submissionResult?.data).toEqual(mockResponse);
    expect(submissionResult?.error).toBeNull();
    expect(mockOnSuccess).toHaveBeenCalled();
    expect(global.fetch).toHaveBeenCalledWith("/api/projects", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(
        expect.objectContaining({
          name: mockProjectData.name,
          client_id: mockProjectData.client_id,
        }),
      ),
    });
  });

  it("should handle validation errors", async () => {
    const errorMessage = "Client is required";
    (global.fetch as jest.Mock).mockResolvedValueOnce({
      ok: false,
      json: async () => ({ message: errorMessage }),
    });

    const { result } = renderHook(() => useProjectSubmission(mockOnSuccess));

    let submissionResult;
    await act(async () => {
      submissionResult = await result.current.submitProject({
        ...mockProjectData,
        client_id: "", // Invalid data
      });
    });

    expect(submissionResult?.data).toBeNull();
    expect(submissionResult?.error).toBe(errorMessage);
    expect(mockOnSuccess).not.toHaveBeenCalled();
  });

  it("should handle network errors", async () => {
    (global.fetch as jest.Mock).mockRejectedValueOnce(
      new Error("Network error"),
    );

    const { result } = renderHook(() => useProjectSubmission(mockOnSuccess));

    let submissionResult;
    await act(async () => {
      submissionResult = await result.current.submitProject(mockProjectData);
    });

    expect(submissionResult?.data).toBeNull();
    expect(submissionResult?.error).toBe("Failed to create project");
    expect(mockOnSuccess).not.toHaveBeenCalled();
  });

  it("should validate task dependencies", async () => {
    const { result } = renderHook(() => useProjectSubmission(mockOnSuccess));

    const invalidProjectData = {
      ...mockProjectData,
      tasks: [
        {
          title: "Task 1",
          priority: "medium",
          dependencies: ["Non-existent Task"],
        },
      ],
    };

    let submissionResult;
    await act(async () => {
      submissionResult = await result.current.submitProject(invalidProjectData);
    });

    expect(submissionResult?.data).toBeNull();
    expect(submissionResult?.error).toBe("Invalid task dependencies");
    expect(mockOnSuccess).not.toHaveBeenCalled();
    expect(global.fetch).not.toHaveBeenCalled();
  });
});
```

### `src\hooks\__tests__\useTasks.test.ts`

```ts
import { renderHook, act } from '@testing-library/react'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { useTasks } from '../useTasks'
import { createClient } from '@supabase/supabase-js'

// Mock supabase client
jest.mock('@supabase/supabase-js', () => ({
  createClient: jest.fn(() => ({
    from: jest.fn(() => ({
      select: jest.fn().mockReturnThis(),
      insert: jest.fn().mockReturnThis(),
      update: jest.fn().mockReturnThis(),
      delete: jest.fn().mockReturnThis(),
      eq: jest.fn().mockReturnThis(),
      single: jest.fn().mockReturnThis(),
    })),
  })),
}))

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: false,
    },
  },
})

const wrapper = ({ children }: { children: React.ReactNode }) => (
  <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
)

describe('useTasks', () => {
  beforeEach(() => {
    queryClient.clear()
    jest.clearAllMocks()
  })

  it('should fetch tasks', async () => {
    const mockTasks = [
      { id: '1', title: 'Task 1', status: 'todo' as const },
      { id: '2', title: 'Task 2', status: 'in_progress' as const },
    ]

    const mockSupabase = createClient('', '')
    ;(mockSupabase.from as jest.Mock).mockImplementationOnce(() => ({
      select: jest.fn().mockResolvedValueOnce({ data: mockTasks, error: null }),
    }))

    const { result } = renderHook(() => useTasks(), { wrapper })

    expect(result.current.isLoading).toBe(true)
    expect(result.current.tasks).toEqual([])

    await act(async () => {
      await new Promise(resolve => setTimeout(resolve, 0))
    })

    expect(result.current.isLoading).toBe(false)
    expect(result.current.tasks).toEqual(mockTasks)
  })

  it('should create a task with optimistic update', async () => {
    const newTask = {
      title: 'New Task',
      status: 'todo' as const,
      description: '',
      priority: null,
      project_id: null,
      assignee_id: null,
      due_date: null,
      start_date: null,
      tax_form_type: null,
      category: null,
    }
    const createdTask = { id: '1', ...newTask }

    const mockSupabase = createClient('', '')
    ;(mockSupabase.from as jest.Mock).mockImplementationOnce(() => ({
      select: jest.fn().mockResolvedValueOnce({ data: [], error: null }),
      insert: jest.fn().mockResolvedValueOnce({ data: createdTask, error: null }),
    }))

    const { result } = renderHook(() => useTasks(), { wrapper })

    await act(async () => {
      await result.current.createTask(newTask)
    })

    expect(result.current.tasks).toContainEqual(expect.objectContaining(newTask))
  })

  it('should update a task with optimistic update', async () => {
    const initialTask = { id: '1', title: 'Task 1', status: 'todo' }
    const updatedTask = { ...initialTask, status: 'in_progress' }

    ;(supabase.from as jest.Mock).mockImplementationOnce(() => ({
      select: jest.fn().mockResolvedValueOnce({ data: [initialTask], error: null }),
      update: jest.fn().mockResolvedValueOnce({ data: updatedTask, error: null }),
      eq: jest.fn().mockReturnThis(),
      single: jest.fn().mockReturnThis(),
    }))

    const { result } = renderHook(() => useTasks(), { wrapper })

    await act(async () => {
      await new Promise(resolve => setTimeout(resolve, 0))
    })

    await act(async () => {
      await result.current.updateTask(updatedTask)
    })

    expect(result.current.tasks).toContainEqual(expect.objectContaining(updatedTask))
  })

  it('should delete a task with optimistic update', async () => {
    const task = { id: '1', title: 'Task 1', status: 'todo' }

    ;(supabase.from as jest.Mock).mockImplementationOnce(() => ({
      select: jest.fn().mockResolvedValueOnce({ data: [task], error: null }),
      delete: jest.fn().mockResolvedValueOnce({ error: null }),
      eq: jest.fn().mockReturnThis(),
    }))

    const { result } = renderHook(() => useTasks(), { wrapper })

    await act(async () => {
      await new Promise(resolve => setTimeout(resolve, 0))
    })

    await act(async () => {
      await result.current.deleteTask(task.id)
    })

    expect(result.current.tasks).not.toContainEqual(expect.objectContaining(task))
  })

  it('should handle errors', async () => {
    const error = new Error('Failed to fetch tasks')

    ;(supabase.from as jest.Mock).mockImplementationOnce(() => ({
      select: jest.fn().mockResolvedValueOnce({ data: null, error }),
    }))

    const { result } = renderHook(() => useTasks(), { wrapper })

    await act(async () => {
      await new Promise(resolve => setTimeout(resolve, 0))
    })

    expect(result.current.error).toBeTruthy()
    expect(result.current.tasks).toEqual([])
  })
})
```

### `src\hooks\__tests__\useTasks.test.tsx`

```tsx
/** @jest-environment jsdom */
import { renderHook, act } from "@testing-library/react";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { useTasks } from "../useTasks";
import type {
  TaskStatus,
  TaskWithRelations,
  TaskFormData,
} from "@/types/tasks";

const mockSupabaseClient = {
  from: jest.fn(() => ({
    select: jest.fn().mockReturnThis(),
    insert: jest.fn().mockReturnThis(),
    update: jest.fn().mockReturnThis(),
    delete: jest.fn().mockReturnThis(),
    eq: jest.fn().mockReturnThis(),
    single: jest.fn().mockReturnThis(),
    order: jest.fn().mockReturnThis(),
  })),
};

jest.mock("@/lib/supabase/browser-client", () => ({
  getBrowserClient: () => mockSupabaseClient,
}));

// Mock toast
const mockToast = jest.fn();
jest.mock("@/components/ui/use-toast", () => ({
  useToast: () => ({ toast: mockToast }),
}));

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: false,
    },
  },
});

function createWrapper() {
  return function Wrapper({ children }: { children: React.ReactNode }) {
    return (
      <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
    );
  };
}

describe("useTasks", () => {
  beforeEach(() => {
    queryClient.clear();
    jest.clearAllMocks();
  });

  it("should fetch tasks with relationships", async () => {
    const mockTasks: TaskWithRelations[] = [
      {
        id: "1",
        title: "Task 1",
        description: null,
        status: "todo" as TaskStatus,
        priority: null,
        project_id: null,
        assignee_id: null,
        due_date: null,
        start_date: null,
        tax_form_type: null,
        category: null,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
        completed_at: null,
        assigned_team: null,
        dependencies: null,
        parent_task_id: null,
        progress: null,
        recurring_config: null,
        tax_return_id: null,
        template_id: null,
        project: null,
        assignee: null,
        parent_task: null,
        checklist_items: null,
        activity_log_entries: null,
      },
    ];

    mockSupabaseClient.from.mockImplementationOnce(() => ({
      select: jest.fn().mockResolvedValueOnce({ data: mockTasks, error: null }),
      order: jest.fn().mockReturnThis(),
    }));

    const { result } = renderHook(() => useTasks(), {
      wrapper: createWrapper(),
    });

    expect(result.current.isLoading).toBe(true);
    expect(result.current.tasks).toEqual([]);

    await act(async () => {
      await new Promise((resolve) => setTimeout(resolve, 0));
    });

    expect(result.current.isLoading).toBe(false);
    expect(result.current.tasks).toEqual(mockTasks);
  });

  it("should filter tasks by project ID when provided", async () => {
    const projectId = "123";
    const mockTasks: TaskWithRelations[] = [];

    mockSupabaseClient.from.mockImplementationOnce(() => ({
      select: jest.fn().mockReturnThis(),
      order: jest.fn().mockReturnThis(),
      eq: jest.fn().mockResolvedValueOnce({ data: mockTasks, error: null }),
    }));

    renderHook(() => useTasks({ projectId }), { wrapper: createWrapper() });

    expect(mockSupabaseClient.from).toHaveBeenCalledWith("tasks");
    expect(mockSupabaseClient.from().eq).toHaveBeenCalledWith(
      "project_id",
      projectId,
    );
  });

  it("should create a task with optimistic update", async () => {
    const newTask: TaskFormData = {
      title: "New Task",
      description: "",
      status: "todo",
      priority: null,
      project_id: null,
      assignee_id: null,
      due_date: null,
      start_date: null,
      tax_form_type: null,
      category: null,
      checklist: null,
      activity_log: null,
      recurring_config: null,
    };

    const createdTask: TaskWithRelations = {
      id: "1",
      ...newTask,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
      completed_at: null,
      assigned_team: null,
      dependencies: null,
      parent_task_id: null,
      progress: null,
      recurring_config: null,
      tax_return_id: null,
      template_id: null,
      project: null,
      assignee: null,
      parent_task: null,
      checklist_items: null,
      activity_log_entries: null,
    };

    mockSupabaseClient.from.mockImplementationOnce(() => ({
      select: jest.fn().mockResolvedValueOnce({ data: [], error: null }),
      order: jest.fn().mockReturnThis(),
    }));

    mockSupabaseClient.from.mockImplementationOnce(() => ({
      insert: jest.fn().mockReturnThis(),
      select: jest.fn().mockReturnThis(),
      single: jest
        .fn()
        .mockResolvedValueOnce({ data: createdTask, error: null }),
    }));

    const { result } = renderHook(() => useTasks(), {
      wrapper: createWrapper(),
    });

    await act(async () => {
      await result.current.createTask(newTask);
    });

    expect(result.current.tasks).toContainEqual(
      expect.objectContaining(newTask),
    );
    expect(mockToast).toHaveBeenCalledWith({
      title: "Success",
      description: "Task created successfully.",
    });
  });

  it("should handle create task error", async () => {
    const newTask: TaskFormData = {
      title: "New Task",
      description: "",
      status: "todo",
      priority: null,
      project_id: null,
      assignee_id: null,
      due_date: null,
      start_date: null,
      tax_form_type: null,
      category: null,
      checklist: null,
      activity_log: null,
      recurring_config: null,
    };

    const error = new Error("Failed to create task");

    mockSupabaseClient.from.mockImplementationOnce(() => ({
      select: jest.fn().mockResolvedValueOnce({ data: [], error: null }),
      order: jest.fn().mockReturnThis(),
    }));

    mockSupabaseClient.from.mockImplementationOnce(() => ({
      insert: jest.fn().mockReturnThis(),
      select: jest.fn().mockReturnThis(),
      single: jest.fn().mockResolvedValueOnce({ data: null, error }),
    }));

    const { result } = renderHook(() => useTasks(), {
      wrapper: createWrapper(),
    });

    await act(async () => {
      try {
        await result.current.createTask(newTask);
      } catch (e) {
        // Expected error
      }
    });

    expect(mockToast).toHaveBeenCalledWith({
      title: "Error",
      description: "Failed to create task. Please try again.",
      variant: "destructive",
    });
  });

  it("should update a task with optimistic update", async () => {
    const initialTask: TaskWithRelations = {
      id: "1",
      title: "Task 1",
      description: null,
      status: "todo" as TaskStatus,
      priority: null,
      project_id: null,
      assignee_id: null,
      due_date: null,
      start_date: null,
      tax_form_type: null,
      category: null,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
      completed_at: null,
      assigned_team: null,
      dependencies: null,
      parent_task_id: null,
      progress: null,
      recurring_config: null,
      tax_return_id: null,
      template_id: null,
      project: null,
      assignee: null,
      parent_task: null,
      checklist_items: null,
      activity_log_entries: null,
    };

    const updatedTask = { ...initialTask, status: "in_progress" as TaskStatus };

    mockSupabaseClient.from.mockImplementationOnce(() => ({
      select: jest
        .fn()
        .mockResolvedValueOnce({ data: [initialTask], error: null }),
      order: jest.fn().mockReturnThis(),
    }));

    mockSupabaseClient.from.mockImplementationOnce(() => ({
      update: jest.fn().mockReturnThis(),
      eq: jest.fn().mockReturnThis(),
      select: jest.fn().mockReturnThis(),
      single: jest
        .fn()
        .mockResolvedValueOnce({ data: updatedTask, error: null }),
    }));

    const { result } = renderHook(() => useTasks(), {
      wrapper: createWrapper(),
    });

    await act(async () => {
      await new Promise((resolve) => setTimeout(resolve, 0));
    });

    await act(async () => {
      await result.current.updateTask(updatedTask);
    });

    expect(result.current.tasks).toContainEqual(
      expect.objectContaining(updatedTask),
    );
    expect(mockToast).toHaveBeenCalledWith({
      title: "Success",
      description: "Task updated successfully.",
    });
  });

  it("should delete a task with optimistic update", async () => {
    const task: TaskWithRelations = {
      id: "1",
      title: "Task 1",
      description: null,
      status: "todo" as TaskStatus,
      priority: null,
      project_id: null,
      assignee_id: null,
      due_date: null,
      start_date: null,
      tax_form_type: null,
      category: null,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
      completed_at: null,
      assigned_team: null,
      dependencies: null,
      parent_task_id: null,
      progress: null,
      recurring_config: null,
      tax_return_id: null,
      template_id: null,
      project: null,
      assignee: null,
      parent_task: null,
      checklist_items: null,
      activity_log_entries: null,
    };

    mockSupabaseClient.from.mockImplementationOnce(() => ({
      select: jest.fn().mockResolvedValueOnce({ data: [task], error: null }),
      order: jest.fn().mockReturnThis(),
    }));

    mockSupabaseClient.from.mockImplementationOnce(() => ({
      delete: jest.fn().mockReturnThis(),
      eq: jest.fn().mockResolvedValueOnce({ error: null }),
    }));

    const { result } = renderHook(() => useTasks(), {
      wrapper: createWrapper(),
    });

    await act(async () => {
      await new Promise((resolve) => setTimeout(resolve, 0));
    });

    await act(async () => {
      await result.current.deleteTask(task.id);
    });

    expect(result.current.tasks).not.toContainEqual(
      expect.objectContaining(task),
    );
    expect(mockToast).toHaveBeenCalledWith({
      title: "Success",
      description: "Task deleted successfully.",
    });
  });

  it("should handle fetch error", async () => {
    const error = new Error("Failed to fetch tasks");

    mockSupabaseClient.from.mockImplementationOnce(() => ({
      select: jest.fn().mockResolvedValueOnce({ data: null, error }),
      order: jest.fn().mockReturnThis(),
    }));

    const { result } = renderHook(() => useTasks(), {
      wrapper: createWrapper(),
    });

    await act(async () => {
      await new Promise((resolve) => setTimeout(resolve, 0));
    });

    expect(result.current.error).toBeTruthy();
    expect(result.current.tasks).toEqual([]);
  });
});
```

### `src\integrations\aiIntegration.ts`

```ts
export function handleAIFallback(error: Error, context: Record<string, any>) {
  console.warn("AI fallback triggered:", error.message);
  return {
    success: false,
    fallbackUsed: true,
    message: "An error occurred, defaulting to fallback response.",
  };
}

export async function invokeAI(input: any) {
  try {
    // Hypothetical AI call
    const response = await someAICall(input);
    return { success: true, data: response };
  } catch (err) {
    return handleAIFallback(err, { input });
  }
}

async function someAICall(input: any) {
  // Example: call to an external AI service
  if (!input) {
    throw new Error("Invalid AI input.");
  }
  // Placeholder for the real AI integration
  return { prediction: "AI response here" };
}
```

### `src\lib\api-handler.ts`

```ts
import { withPerformanceMonitoring } from "./performance";
import { logger } from "./logger";
import { rateLimit } from "./rate-limit";
import { sanitizeRequest } from "./sanitize";
import { ResponseCache } from "./cache";

const cache = new ResponseCache();

export function createApiHandler(options: {
  requireAuth?: boolean;
  requiredRole?: string;
  rateLimitKey?: string;
  cacheKey?: string;
  cacheTtl?: number;
}) {
  return function (handler: (req: Request) => Promise<Response>) {
    return withPerformanceMonitoring(async (req: Request) => {
      try {
        // Rate limiting check
        if (options.rateLimitKey) {
          await rateLimit(options.rateLimitKey);
        }

        // Check cache
        if (options.cacheKey) {
          const cached = await cache.get(options.cacheKey);
          if (cached) {
            return cached;
          }
        }

        // Sanitize request data
        const sanitizedReq = await sanitizeRequest(req.clone());

        // Handle the request
        const response = await handler(sanitizedReq);

        // Cache the response if needed
        if (options.cacheKey && options.cacheTtl) {
          await cache.set(options.cacheKey, response.clone(), options.cacheTtl);
        }

        return response;
      } catch (error) {
        logger.error("API request failed", { error });

        const status =
          error instanceof Error && "status" in error
            ? (error as any).status
            : 500;

        return new Response(
          JSON.stringify({
            error:
              error instanceof Error ? error.message : "Internal server error",
          }),
          { status },
        );
      }
    });
  };
}
```

### `src\lib\api.ts`

```ts
import { supabaseBrowserClient } from "@/lib/supabaseBrowserClient";

export async function fetchProjectsWithTasks() {
  const { data, error } = await supabaseBrowserClient.from("projects").select(`
      id, name, status, completed_tasks, tasks (id, title, status, progress)
    `);
  if (error) throw new Error(error.message);
  return data;
}

export async function createProject(projectData: any) {
  const { data, error } = await supabaseBrowserClient
    .from("projects")
    .insert(projectData)
    .select()
    .single();
  if (error) throw new Error(error.message);
  return data;
}

export async function fetchTasksByProject(projectId: string) {
  const { data, error } = await supabaseBrowserClient
    .from("tasks")
    .select("*")
    .eq("project_id", projectId);
  if (error) throw new Error(error.message);
  return data;
}

export async function createTasks(tasks: any[]) {
  const { data, error } = await supabaseBrowserClient
    .from("tasks")
    .insert(tasks)
    .select();
  if (error) throw new Error(error.message);
  return data;
}

export async function applyTemplate(templateId: string, projectData: any) {
  const { data: templateTasks, error: templateError } =
    await supabaseBrowserClient
      .from("template_tasks")
      .select("*")
      .eq("template_id", templateId);

  if (templateError) throw new Error(templateError.message);

  const { data: project, error: projectError } = await supabaseBrowserClient
    .from("projects")
    .insert(projectData)
    .select()
    .single();

  if (projectError) throw new Error(projectError.message);

  const tasks = templateTasks.map((task: any) => ({
    ...task,
    project_id: project.id,
    template_id: null, // Remove template linkage
  }));

  return await createTasks(tasks);
}
```

### `src\lib\auth.ts`

```ts
"use client";

import { supabaseBrowserClient } from "@/lib/supabaseBrowserClient";
import { type SignInValues, type SignUpValues } from "@/lib/validations/auth";
import { createClient } from "@/lib/supabase/server";
import { redirect } from "next/navigation";
import type { AuthError } from "@supabase/supabase-js";

export async function signIn(email: string, password: string) {
  const { data, error } = await supabaseBrowserClient.auth.signInWithPassword({
    email,
    password,
  });
  if (error) throw error;
  return data;
}

export async function signUp(email: string, password: string) {
  const { data, error } = await supabaseBrowserClient.auth.signUp({
    email,
    password,
  });
  if (error) throw error;
  return data;
}

export async function signOut() {
  const { error } = await supabaseBrowserClient.auth.signOut();
  if (error) throw error;
}

export async function getSession() {
  const {
    data: { session },
    error,
  } = await supabaseBrowserClient.auth.getSession();
  if (error) throw error;
  return session;
}

export async function requireAuth() {
  const supabase = createClient();
  const {
    data: { session },
  } = await supabase.auth.getSession();

  if (!session) {
    redirect("/auth/login");
  }

  return session;
}

export async function requireRole(role: string) {
  const session = await requireAuth();

  if (session.user.app_metadata?.role !== role) {
    redirect("/unauthorized");
  }

  return session;
}

export async function getCurrentUser() {
  const session = await requireAuth();
  return session.user;
}
```

### `src\lib\cache.ts`

```ts
import { LRUCache } from "lru-cache";
import { NextResponse } from "next/server";

interface CacheOptions {
  maxAge?: number; // Time in milliseconds
  maxSize?: number; // Maximum number of items
  staleWhileRevalidate?: number; // Time in milliseconds
}

interface CacheEntry {
  response: Response;
  createdAt: number;
  expiresAt: number;
}

const DEFAULT_OPTIONS: Required<CacheOptions> = {
  maxAge: 5 * 60 * 1000, // 5 minutes
  maxSize: 100,
  staleWhileRevalidate: 60 * 1000, // 1 minute
};

class ResponseCache {
  private cache: LRUCache<string, CacheEntry>;
  private options: Required<CacheOptions>;

  constructor(options: CacheOptions = {}) {
    this.options = { ...DEFAULT_OPTIONS, ...options };
    this.cache = new LRUCache({
      max: this.options.maxSize,
      ttl: this.options.maxAge + this.options.staleWhileRevalidate,
    });
  }

  private generateCacheKey(req: Request): string {
    const url = new URL(req.url);
    return `${req.method}:${url.pathname}${url.search}`;
  }

  private async cloneResponse(response: Response): Promise<Response> {
    const clonedResponse = response.clone();
    const body = await clonedResponse.blob();

    return new Response(body, {
      status: response.status,
      statusText: response.statusText,
      headers: new Headers(response.headers),
    });
  }

  private isCacheable(req: Request, res: Response): boolean {
    // Only cache GET requests
    if (req.method !== "GET") return false;

    // Only cache successful responses
    if (!res.ok) return false;

    // Check cache-control headers
    const cacheControl = res.headers.get("cache-control");
    if (cacheControl?.includes("no-store")) return false;
    if (cacheControl?.includes("private")) return false;

    return true;
  }

  async get(req: Request): Promise<Response | null> {
    const key = this.generateCacheKey(req);
    const entry = this.cache.get(key);

    if (!entry) return null;

    const now = Date.now();
    const isStale = now > entry.expiresAt;

    // If the entry is stale but within staleWhileRevalidate window,
    // return stale data and trigger background refresh
    if (isStale && now < entry.expiresAt + this.options.staleWhileRevalidate) {
      this.backgroundRefresh(req, key);
    }

    return this.cloneResponse(entry.response);
  }

  async set(req: Request, res: Response): Promise<void> {
    if (!this.isCacheable(req, res)) return;

    const key = this.generateCacheKey(req);
    const now = Date.now();

    this.cache.set(key, {
      response: await this.cloneResponse(res),
      createdAt: now,
      expiresAt: now + this.options.maxAge,
    });
  }

  private async backgroundRefresh(req: Request, key: string): Promise<void> {
    try {
      const freshResponse = await fetch(req.clone());
      if (this.isCacheable(req, freshResponse)) {
        const now = Date.now();
        this.cache.set(key, {
          response: await this.cloneResponse(freshResponse),
          createdAt: now,
          expiresAt: now + this.options.maxAge,
        });
      }
    } catch (error) {
      console.error("Background refresh failed:", error);
    }
  }

  clear(): void {
    this.cache.clear();
  }

  delete(req: Request): void {
    const key = this.generateCacheKey(req);
    this.cache.delete(key);
  }
}

// Create a singleton instance
export const responseCache = new ResponseCache();

// Middleware to handle caching
export async function withCache(
  req: Request,
  handler: () => Promise<Response>,
  options?: CacheOptions,
): Promise<Response> {
  // Try to get from cache
  const cachedResponse = await responseCache.get(req);
  if (cachedResponse) {
    return cachedResponse;
  }

  // Get fresh response
  const response = await handler();

  // Cache the response if appropriate
  await responseCache.set(req, response);

  return response;
}
```

### `src\lib\constants.ts`

```ts
import { TaskStatus, TaskPriority } from "@/types/tasks";
import { type UserRole } from "@/types/auth";

interface TaskOption {
  value: string;
  label: string;
}

export const taskStatusOptions: { value: TaskStatus; label: string }[] = [
  { value: "todo", label: "To Do" },
  { value: "in_progress", label: "In Progress" },
  { value: "review", label: "Review" },
  { value: "completed", label: "Completed" },
];

export const taskPriorityOptions: { value: TaskPriority; label: string }[] = [
  { value: "low", label: "Low" },
  { value: "medium", label: "Medium" },
  { value: "high", label: "High" },
  { value: "urgent", label: "Urgent" },
];

export const TASKS_PER_PAGE = 10;

// Authentication constants
export const AUTH_COOKIE_OPTIONS = {
  secure: process.env.NODE_ENV === "production",
  httpOnly: true,
  sameSite: "lax" as const,
  path: "/",
} as const;

// Rate limiting constants
export const RATE_LIMITS = {
  AUTH: {
    LOGIN: { limit: 5, interval: 60 * 1000 }, // 5 attempts per minute
    SIGNUP: { limit: 3, interval: 60 * 1000 }, // 3 attempts per minute
    PASSWORD_RESET: { limit: 3, interval: 60 * 1000 }, // 3 attempts per minute
  },
  API: {
    DEFAULT: { limit: 100, interval: 60 * 1000 }, // 100 requests per minute
    PUBLIC: { limit: 20, interval: 60 * 1000 }, // 20 requests per minute
  },
} as const;

// Role-based access constants
export const ROLES: Record<string, UserRole> = {
  ADMIN: "admin",
  TEAM_MEMBER: "team_member",
} as const;

export const ROLE_PERMISSIONS = {
  [ROLES.ADMIN]: ["read", "write", "delete", "manage_users"],
  [ROLES.TEAM_MEMBER]: ["read", "write"],
} as const;

// Session constants
export const SESSION_CONFIG = {
  REFRESH_INTERVAL: 10 * 60 * 1000, // 10 minutes
  MAX_AGE: 7 * 24 * 60 * 60 * 1000, // 7 days
  REMEMBER_ME_MAX_AGE: 30 * 24 * 60 * 60 * 1000, // 30 days
} as const;

// Error messages
export const AUTH_ERRORS = {
  INVALID_CREDENTIALS: "Invalid email or password",
  SESSION_EXPIRED: "Your session has expired. Please sign in again.",
  UNAUTHORIZED: "You are not authorized to access this resource",
  FORBIDDEN: "You do not have permission to perform this action",
  RATE_LIMITED: "Too many attempts. Please try again later.",
  INVALID_TOKEN: "Invalid or expired token",
  WEAK_PASSWORD: "Password does not meet security requirements",
} as const;

// Validation constants
export const VALIDATION = {
  PASSWORD: {
    MIN_LENGTH: 8,
    MAX_LENGTH: 100,
    PATTERN:
      /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/,
  },
  EMAIL: {
    MIN_LENGTH: 5,
    MAX_LENGTH: 254,
  },
  NAME: {
    MIN_LENGTH: 2,
    MAX_LENGTH: 100,
    PATTERN: /^[a-zA-Z\s'-]+$/,
  },
} as const;
```

### `src\lib\data.ts`

```ts
import { Database } from "@/types/database.types";

export interface TaxReturn {
  id: string;
  name: string;
  status: string;
  year: number;
}

export interface TeamMember {
  id: string;
  name: string;
  role: string;
  email: string;
}

// Mock data for tax returns
export const taxReturns: TaxReturn[] = [
  {
    id: "1",
    name: "2023 Tax Return - Individual",
    status: "In Progress",
    year: 2023,
  },
  {
    id: "2",
    name: "2023 Tax Return - Business",
    status: "Not Started",
    year: 2023,
  },
];

// Mock data for team members
export const teamMembers: TeamMember[] = [
  {
    id: "1",
    name: "John Doe",
    role: "Tax Preparer",
    email: "john@example.com",
  },
  {
    id: "2",
    name: "Jane Smith",
    role: "Reviewer",
    email: "jane@example.com",
  },
  {
    id: "3",
    name: "Mike Johnson",
    role: "Manager",
    email: "mike@example.com",
  },
];
```

### `src\lib\date-utils.ts`

```ts
import {
  format,
  isValid,
  parseISO,
  startOfDay,
  endOfDay,
  isBefore,
  isAfter,
  isSameDay,
} from "date-fns";

export const DATE_FORMATS = {
  FULL: "MMM d, yyyy",
  SHORT: "MMM d",
  ISO: "yyyy-MM-dd",
  TIME: "h:mm a",
  FULL_WITH_TIME: "MMM d, yyyy h:mm a",
} as const;

export function formatDate(
  dateString: string | null | undefined,
  formatStr: string = DATE_FORMATS.FULL,
): string {
  if (!dateString) return "";

  try {
    const date = parseISO(dateString);
    if (!isValid(date)) return "";
    return format(date, formatStr);
  } catch {
    return "";
  }
}

export function isOverdue(dateString: string | null | undefined): boolean {
  if (!dateString) return false;

  try {
    const date = parseISO(dateString);
    if (!isValid(date)) return false;
    return isBefore(endOfDay(date), new Date());
  } catch {
    return false;
  }
}

export function isDueToday(dateString: string | null | undefined): boolean {
  if (!dateString) return false;

  try {
    const date = parseISO(dateString);
    if (!isValid(date)) return false;
    return isSameDay(date, new Date());
  } catch {
    return false;
  }
}

export function isInDateRange(
  dateString: string | null | undefined,
  startDate: Date,
  endDate: Date,
): boolean {
  if (!dateString) return false;

  try {
    const date = parseISO(dateString);
    if (!isValid(date)) return false;
    return (
      isAfter(date, startOfDay(startDate)) && isBefore(date, endOfDay(endDate))
    );
  } catch {
    return false;
  }
}

export function validateDateString(
  dateString: string | null | undefined,
): string | null {
  if (!dateString) return null;

  try {
    const date = parseISO(dateString);
    if (!isValid(date)) return null;
    return date.toISOString();
  } catch {
    return null;
  }
}
```

### `src\lib\error-handler.ts`

```ts
import { AuthError } from "@supabase/supabase-js";

export function handleError(error: unknown): Error {
  console.error("Operation failed:", error);

  // Handle Supabase Auth errors
  if (error instanceof AuthError) {
    switch (error.status) {
      case 400:
        return new Error("Invalid request. Please check your input.");
      case 401:
        return new Error("Please sign in to continue.");
      case 403:
        return new Error("You do not have permission to perform this action.");
      case 404:
        return new Error("The requested resource was not found.");
      default:
        return new Error("An authentication error occurred.");
    }
  }

  // Handle standard errors
  if (error instanceof Error) {
    if (error.message.includes("permission denied")) {
      return new Error("You do not have permission to perform this action.");
    }
    if (error.message.includes("not found")) {
      return new Error("The requested resource was not found.");
    }
    if (error.message.includes("duplicate key")) {
      return new Error("This record already exists.");
    }
    if (error.message.includes("foreign key")) {
      return new Error("This operation would violate data integrity.");
    }
    return error;
  }

  // Handle unknown errors
  return new Error("An unexpected error occurred.");
}
```

### `src\lib\error-reporting.ts`

```ts
/**
 * Simple error reporting utility
 */

export type ErrorDetails = {
  message: string;
  stack?: string;
  context?: Record<string, unknown>;
};

export const captureError = (
  error: Error | unknown,
  context?: Record<string, unknown>,
) => {
  if (process.env.NODE_ENV === "development") {
    console.error("Error captured:", error);
    if (context) {
      console.error("Error context:", context);
    }
  }

  // In production, you could add error logging to your backend
  // or use a simple analytics service

  if (error instanceof Error) {
    return {
      message: error.message,
      stack: process.env.NODE_ENV === "development" ? error.stack : undefined,
      context,
    };
  }

  return {
    message: "An unknown error occurred",
    context,
  };
};

export const formatErrorMessage = (error: Error | unknown): string => {
  if (error instanceof Error) {
    return error.message;
  }
  return "An unknown error occurred";
};
```

### `src\lib\logger.ts`

```ts
type LogLevel = "debug" | "info" | "warn" | "error";

interface LogEntry {
  timestamp: string;
  level: LogLevel;
  message: string;
  data?: any;
  error?: Error;
}

const LOG_LEVELS: Record<LogLevel, number> = {
  debug: 0,
  info: 1,
  warn: 2,
  error: 3,
};

const CURRENT_LOG_LEVEL = (process.env.LOG_LEVEL || "info") as LogLevel;

function shouldLog(level: LogLevel): boolean {
  return LOG_LEVELS[level] >= LOG_LEVELS[CURRENT_LOG_LEVEL];
}

function formatError(error: Error): Record<string, any> {
  return {
    name: error.name,
    message: error.message,
    stack: error.stack,
    cause: error.cause,
  };
}

function createLogEntry(
  level: LogLevel,
  message: string,
  data?: any,
  error?: Error,
): LogEntry {
  return {
    timestamp: new Date().toISOString(),
    level,
    message,
    data: data ? (typeof data === "object" ? { ...data } : data) : undefined,
    error: error ? formatError(error) : undefined,
  };
}

function writeLog(entry: LogEntry) {
  const logString = JSON.stringify(entry);

  if (process.env.NODE_ENV === "development") {
    switch (entry.level) {
      case "error":
        console.error(logString);
        break;
      case "warn":
        console.warn(logString);
        break;
      case "info":
        console.info(logString);
        break;
      case "debug":
        console.debug(logString);
        break;
    }
  } else {
    // In production, always use console.log for consistent log collection
    console.log(logString);
  }
}

export const logger = {
  debug(message: string, data?: any) {
    if (shouldLog("debug")) {
      writeLog(createLogEntry("debug", message, data));
    }
  },

  info(message: string, data?: any) {
    if (shouldLog("info")) {
      writeLog(createLogEntry("info", message, data));
    }
  },

  warn(message: string, data?: any, error?: Error) {
    if (shouldLog("warn")) {
      writeLog(createLogEntry("warn", message, data, error));
    }
  },

  error(message: string, error?: Error, data?: any) {
    if (shouldLog("error")) {
      writeLog(createLogEntry("error", message, data, error));
    }
  },

  // Helper for logging API requests
  logRequest(req: Request, context?: any) {
    if (shouldLog("debug")) {
      this.debug("API Request", {
        method: req.method,
        url: req.url,
        headers: Object.fromEntries(req.headers),
        context,
      });
    }
  },

  // Helper for logging API responses
  logResponse(req: Request, response: Response, duration: number) {
    const level = response.ok ? "debug" : "error";
    if (shouldLog(level)) {
      this[level]("API Response", {
        method: req.method,
        url: req.url,
        status: response.status,
        duration: `${duration}ms`,
      });
    }
  },
};
```

### `src\lib\permissions.ts`

```ts
import { type UserRole } from "@/types/auth";
import { ROLE_PERMISSIONS, ROLES } from "./constants";

type Permission = "read" | "write" | "delete" | "manage_users";

export class PermissionError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "PermissionError";
  }
}

export function hasPermission(
  userRole: UserRole | undefined,
  permission: Permission,
): boolean {
  if (!userRole) return false;
  return ROLE_PERMISSIONS[userRole]?.includes(permission) || false;
}

export function requirePermission(
  userRole: UserRole | undefined,
  permission: Permission,
): void {
  if (!hasPermission(userRole, permission)) {
    throw new PermissionError(`Missing required permission: ${permission}`);
  }
}

export function isAdmin(userRole: UserRole | undefined): boolean {
  return userRole === ROLES.ADMIN;
}

export function requireAdmin(userRole: UserRole | undefined): void {
  if (!isAdmin(userRole)) {
    throw new PermissionError("Admin access required");
  }
}

export function canManageResource(
  userRole: UserRole | undefined,
  resourceOwnerId: string | undefined,
  userId: string | undefined,
): boolean {
  if (!userRole || !userId) return false;
  if (isAdmin(userRole)) return true;
  return resourceOwnerId === userId;
}

export function requireResourceAccess(
  userRole: UserRole | undefined,
  resourceOwnerId: string | undefined,
  userId: string | undefined,
): void {
  if (!canManageResource(userRole, resourceOwnerId, userId)) {
    throw new PermissionError("Access to this resource is not allowed");
  }
}

// Helper for checking multiple permissions
export function hasAllPermissions(
  userRole: UserRole | undefined,
  permissions: Permission[],
): boolean {
  return permissions.every((permission) => hasPermission(userRole, permission));
}

// Helper for checking if user has any of the specified permissions
export function hasAnyPermission(
  userRole: UserRole | undefined,
  permissions: Permission[],
): boolean {
  return permissions.some((permission) => hasPermission(userRole, permission));
}

// Helper for role-based component rendering
export function canRender(
  requiredRole: UserRole | UserRole[],
  userRole: UserRole | undefined,
): boolean {
  if (!userRole) return false;
  if (Array.isArray(requiredRole)) {
    return requiredRole.includes(userRole);
  }
  return userRole === requiredRole || isAdmin(userRole);
}
```

### `src\lib\priority-calculator.ts`

```ts
import { Task, Project } from "@/types/hooks";

interface PriorityFactors {
  dueDate: number; // Weight: 0.3
  clientPriority: number; // Weight: 0.2
  taskType: number; // Weight: 0.15
  timeEstimate: number; // Weight: 0.15
  dependencies: number; // Weight: 0.2
}

const WEIGHTS = {
  dueDate: 0.3,
  clientPriority: 0.2,
  taskType: 0.15,
  timeEstimate: 0.15,
  dependencies: 0.2,
};

// Priority categories and their weights
const CATEGORY_WEIGHTS: { [key: string]: number } = {
  "tax-return": 1.0,
  bookkeeping: 0.8,
  payroll: 0.9,
  "business-services": 0.7,
  other: 0.5,
};

export function calculatePriority(task: Task, projects?: Project[]): number {
  const factors: PriorityFactors = {
    dueDate: calculateDueDateScore(task.due_date),
    clientPriority: calculateClientPriorityScore(task.priority),
    taskType: calculateTaskTypeScore(task),
    timeEstimate: calculateTimeEstimateScore(task),
    dependencies: calculateDependenciesScore(task, projects),
  };

  return (
    factors.dueDate * WEIGHTS.dueDate +
    factors.clientPriority * WEIGHTS.clientPriority +
    factors.taskType * WEIGHTS.taskType +
    factors.timeEstimate * WEIGHTS.timeEstimate +
    factors.dependencies * WEIGHTS.dependencies
  );
}

function calculateDueDateScore(dueDate: string | null): number {
  if (!dueDate) return 0.5; // Middle priority for tasks without due dates

  const now = new Date();
  const due = new Date(dueDate);
  const daysUntilDue = Math.ceil(
    (due.getTime() - now.getTime()) / (1000 * 60 * 60 * 24),
  );

  if (daysUntilDue < 0) return 1; // Overdue tasks get highest priority
  if (daysUntilDue === 0) return 0.9; // Due today
  if (daysUntilDue <= 2) return 0.8; // Due in next 2 days
  if (daysUntilDue <= 7) return 0.6; // Due this week
  if (daysUntilDue <= 14) return 0.4; // Due next week
  if (daysUntilDue <= 30) return 0.2; // Due this month
  return 0.1; // Due later
}

function calculateClientPriorityScore(priority: string | null): number {
  if (!priority) return 0.5; // Middle priority for tasks without priority set

  switch (priority.toLowerCase()) {
    case "high":
      return 1;
    case "medium":
      return 0.6;
    case "low":
      return 0.3;
    default:
      return 0.5;
  }
}

function calculateTaskTypeScore(task: Task): number {
  // Consider task category
  if (task.category) {
    const categoryWeight =
      CATEGORY_WEIGHTS[task.category.toLowerCase()] || CATEGORY_WEIGHTS.other;
    return categoryWeight;
  }

  // Fallback to title-based scoring if no category
  if (task.title.toLowerCase().includes("tax")) return 0.9;
  if (task.title.toLowerCase().includes("deadline")) return 0.8;
  if (task.title.toLowerCase().includes("review")) return 0.7;
  return 0.5;
}

function calculateTimeEstimateScore(task: Task): number {
  if (!task.estimated_minutes) return 0.5;

  // Tasks that take longer get slightly higher priority
  // This helps prevent long tasks from being perpetually delayed
  if (task.estimated_minutes > 240) return 0.8; // > 4 hours
  if (task.estimated_minutes > 120) return 0.7; // > 2 hours
  if (task.estimated_minutes > 60) return 0.6; // > 1 hour
  return 0.5; // <= 1 hour
}

function calculateDependenciesScore(task: Task, projects?: Project[]): number {
  if (!task.dependencies || task.dependencies.length === 0) {
    return 0.5; // No dependencies
  }

  // Higher priority for tasks that are blocking others
  const blockingScore = 0.7;

  // If this task is part of a project, check project deadline
  if (projects && task.project_id) {
    const project = projects.find((p) => p.id === task.project_id);
    if (project && project.due_date) {
      const projectDue = new Date(project.due_date);
      const now = new Date();
      const daysUntilProjectDue = Math.ceil(
        (projectDue.getTime() - now.getTime()) / (1000 * 60 * 60 * 24),
      );

      if (daysUntilProjectDue <= 7) {
        return 0.9; // Critical path task in a project due soon
      }
    }
  }

  return blockingScore;
}
```

### `src\lib\rate-limit.ts`

```ts
import { AUTH_ERRORS, RATE_LIMITS } from "./constants";

type RateLimitRecord = {
  count: number;
  resetTime: number;
};

export class RateLimitError extends Error {
  constructor(retryAfter: number) {
    super(AUTH_ERRORS.RATE_LIMITED);
    this.name = "RateLimitError";
    this.retryAfter = retryAfter;
  }
  retryAfter: number;
}

// Use Map instead of LRUCache for Edge Runtime compatibility
const tokenCache = new Map<string, RateLimitRecord>();

// Cleanup function to remove expired entries
const cleanup = () => {
  const now = Date.now();
  for (const [key, record] of tokenCache.entries()) {
    if (now >= record.resetTime) {
      tokenCache.delete(key);
    }
  }
};

export const rateLimit = {
  check: async (limit: number, token: string) => {
    cleanup();
    const now = Date.now();
    const record = tokenCache.get(token);

    if (!record) {
      tokenCache.set(token, {
        count: 1,
        resetTime: now + RATE_LIMITS.API.DEFAULT.interval,
      });
      return;
    }

    if (now >= record.resetTime) {
      tokenCache.set(token, {
        count: 1,
        resetTime: now + RATE_LIMITS.API.DEFAULT.interval,
      });
      return;
    }

    record.count++;
    tokenCache.set(token, record);

    if (record.count > limit) {
      const retryAfter = Math.ceil((record.resetTime - now) / 1000);
      throw new RateLimitError(retryAfter);
    }
  },

  resetToken: (token: string) => {
    tokenCache.delete(token);
  },

  getRemainingRequests: (token: string) => {
    cleanup();
    const record = tokenCache.get(token);
    if (!record) return RATE_LIMITS.API.DEFAULT.limit;
    return Math.max(0, RATE_LIMITS.API.DEFAULT.limit - record.count);
  },
};

export const middlewareRateLimit = rateLimit;
```

### `src\lib\react-query.ts`

```ts
import { QueryClient } from "@tanstack/react-query";

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000, // 5 minutes
      cacheTime: 10 * 60 * 1000, // 10 minutes
      retry: 1,
      refetchOnWindowFocus: false,
    },
  },
});
```

### `src\lib\sanitize.ts`

```ts
import { ValidationError } from "./error-handler";

// Common XSS attack patterns
const XSS_PATTERNS = [
  /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
  /javascript:/gi,
  /on\w+\s*=/gi,
  /data:\s*[^,]+/gi,
];

// SQL Injection patterns
const SQL_PATTERNS = [
  /(\%27)|(\')|(\-\-)|(\%23)|(#)/gi,
  /((\%3D)|(=))[^\n]*((\%27)|(\')|(\-\-)|(\%3B)|(;))/gi,
  /\w*((\%27)|(\'))((\%6F)|o|(\%4F))((\%72)|r|(\%52))/gi,
  /exec(\s|\+)+(s|x)p\w+/gi,
];

interface SanitizeOptions {
  allowHtml?: boolean;
  maxLength?: number;
  trim?: boolean;
}

/**
 * Sanitizes a string value by removing potential XSS and SQL injection patterns
 */
export function sanitizeString(
  value: string,
  options: SanitizeOptions = {},
): string {
  if (typeof value !== "string") {
    return "";
  }

  let sanitized = value;

  // Trim if requested
  if (options.trim !== false) {
    sanitized = sanitized.trim();
  }

  // Remove XSS patterns unless HTML is allowed
  if (!options.allowHtml) {
    XSS_PATTERNS.forEach((pattern) => {
      sanitized = sanitized.replace(pattern, "");
    });
  }

  // Always remove SQL injection patterns
  SQL_PATTERNS.forEach((pattern) => {
    sanitized = sanitized.replace(pattern, "");
  });

  // Enforce maximum length if specified
  if (options.maxLength && sanitized.length > options.maxLength) {
    sanitized = sanitized.slice(0, options.maxLength);
  }

  return sanitized;
}

/**
 * Sanitizes an object by recursively sanitizing all string values
 */
export function sanitizeObject<T extends Record<string, any>>(
  obj: T,
  options: SanitizeOptions = {},
): T {
  const result: Record<string, any> = {};

  for (const [key, value] of Object.entries(obj)) {
    if (typeof value === "string") {
      result[key] = sanitizeString(value, options);
    } else if (value && typeof value === "object" && !Array.isArray(value)) {
      result[key] = sanitizeObject(value, options);
    } else if (Array.isArray(value)) {
      result[key] = value.map((item) =>
        typeof item === "string"
          ? sanitizeString(item, options)
          : typeof item === "object"
            ? sanitizeObject(item, options)
            : item,
      );
    } else {
      result[key] = value;
    }
  }

  return result as T;
}

/**
 * Sanitizes form data by cleaning all string values
 */
export function sanitizeFormData(
  formData: FormData,
  options: SanitizeOptions = {},
): FormData {
  const sanitized = new FormData();

  for (const [key, value] of formData.entries()) {
    if (typeof value === "string") {
      sanitized.append(key, sanitizeString(value, options));
    } else {
      sanitized.append(key, value);
    }
  }

  return sanitized;
}

/**
 * Validates and sanitizes an email address
 */
export function sanitizeEmail(email: string): string {
  const sanitized = sanitizeString(email, { trim: true });

  // Basic email validation
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  if (!emailRegex.test(sanitized)) {
    throw new ValidationError("Invalid email format");
  }

  return sanitized.toLowerCase();
}

/**
 * Sanitizes a filename to prevent directory traversal and invalid characters
 */
export function sanitizeFilename(filename: string): string {
  return sanitizeString(filename, { trim: true })
    .replace(/[/\\?%*:|"<>]/g, "-") // Replace invalid characters
    .replace(/\.{2,}/g, "."); // Prevent directory traversal
}
```

### `src\lib\supabaseBrowserClient.ts`

```ts
import { createBrowserClient } from "@supabase/ssr";
import { Database } from "@/types/database.types";

export const supabaseBrowserClient = createBrowserClient<Database>(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
);
```

### `src\lib\supabaseServerClient.ts`

```ts
import { createServerClient } from "@supabase/ssr";
import { cookies } from "next/headers";
import { Database } from "@/types/database.types";

export function getSupabaseServerClient() {
  const cookieStore = cookies();
  return createServerClient<Database>(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get: (name: string) => cookieStore.get(name)?.value,
      },
    },
  );
}
```

### `src\lib\test-utils.tsx`

```tsx
import React from "react";
import { render } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import { FormProvider, useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { clientFormSchema } from "@/lib/validations/client";
import { ToastProvider } from "@/components/ui/use-toast";
import { vi } from "vitest";

// Create a more robust mock Supabase client
export const mockSupabaseClient = {
  from: vi.fn().mockReturnValue({
    select: vi.fn().mockResolvedValue({ data: [], error: null }),
    insert: vi.fn().mockResolvedValue({ data: null, error: null }),
    update: vi.fn().mockResolvedValue({ data: null, error: null }),
    delete: vi.fn().mockResolvedValue({ data: null, error: null }),
  }),
};

// Mock Supabase client
vi.mock("@supabase/auth-helpers-react", () => ({
  useSupabaseClient: () => mockSupabaseClient,
}));

// Helper function to render with form context
export const renderWithForm = (ui: React.ReactElement) => {
  const Wrapper = ({ children }: { children: React.ReactNode }) => {
    const form = useForm({
      resolver: zodResolver(clientFormSchema),
      defaultValues: {
        full_name: "",
        company_name: "",
        contact_email: "",
        onboarding_notes: "",
        status: "pending",
        type: "individual",
        contact_details: {
          phone: "",
          address: "",
          city: "",
          state: "",
          zip: "",
        },
        tax_info: {
          filing_status: "",
          tax_id: "",
          tax_year: new Date().getFullYear(),
          filing_type: null,
          tax_id_type: null,
          dependents: [],
          previous_returns: [],
        },
      },
    });

    return (
      <FormProvider {...form}>
        <ToastProvider>{children}</ToastProvider>
      </FormProvider>
    );
  };

  return {
    user: userEvent.setup(),
    mockSupabaseClient,
    ...render(ui, {
      wrapper: Wrapper,
    }),
  };
};
```

### `src\lib\toast.ts`

```ts
import { toast } from "sonner";

export const showSuccessToast = (message: string) => {
  toast.success(message);
};

export const showErrorToast = (message: string) => {
  toast.error(message);
};
```

### `src\lib\utils.ts`

```ts
import { type ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";
import { type Task } from "@/types/tasks";
import { type ProjectWithRelations } from "@/types/projects";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

export function filterTasks(tasks: Task[], filters: { dueDate?: Date }) {
  if (!filters.dueDate) return tasks;

  return tasks.filter((task) => {
    if (!task.due_date) return false;
    const taskDueDate = new Date(task.due_date);
    return taskDueDate <= filters.dueDate;
  });
}

export function groupTasks(tasks: Task[], groupBy: string) {
  if (!tasks?.length) return {};

  return tasks.reduce(
    (groups, task) => {
      const key = task[groupBy as keyof Task] as string;
      if (!key) return groups;

      return {
        ...groups,
        [key]: [...(groups[key] || []), task],
      };
    },
    {} as { [key: string]: Task[] },
  );
}

export function calculateCompletionRate(project: ProjectWithRelations): number {
  if (!project.tasks?.length) return 0;
  const completedTasks = project.tasks.filter(
    (task) => task.status === "completed",
  );
  return (completedTasks.length / project.tasks.length) * 100;
}

export function assessProjectRisk(project: ProjectWithRelations): string {
  const completionRate = calculateCompletionRate(project);
  const dueDate = project.due_date ? new Date(project.due_date) : null;
  const today = new Date();

  if (!dueDate) return "unknown";
  if (dueDate < today && completionRate < 100) return "high";
  if (
    completionRate < 50 &&
    dueDate.getTime() - today.getTime() < 7 * 24 * 60 * 60 * 1000
  )
    return "high";
  if (completionRate < 75) return "medium";
  return "low";
}

export function predictDelay(project: ProjectWithRelations): number {
  const completionRate = calculateCompletionRate(project);
  if (completionRate === 100) return 0;

  const dueDate = project.due_date ? new Date(project.due_date) : null;
  if (!dueDate) return 0;

  const today = new Date();
  const remainingWork = 100 - completionRate;
  const daysUntilDue = Math.ceil(
    (dueDate.getTime() - today.getTime()) / (24 * 60 * 60 * 1000),
  );

  if (daysUntilDue <= 0) return Math.ceil(remainingWork / 10);
  return Math.max(0, Math.ceil(remainingWork / 10) - daysUntilDue);
}

export function analyzeResourceUtilization(
  project: ProjectWithRelations,
): number {
  if (!project.team_members?.length || !project.tasks?.length) return 0;

  const assignedTasks = project.tasks.filter((task) => task.assignee_id);
  return (assignedTasks.length / project.tasks.length) * 100;
}

export function generateRecommendations(
  project: ProjectWithRelations,
): string[] {
  const recommendations: string[] = [];
  const completionRate = calculateCompletionRate(project);
  const riskLevel = assessProjectRisk(project);
  const resourceUtilization = analyzeResourceUtilization(project);

  if (completionRate < 50) {
    recommendations.push(
      "Project progress is behind schedule. Consider allocating more resources.",
    );
  }

  if (riskLevel === "high") {
    recommendations.push("High risk detected. Immediate attention required.");
  }

  if (resourceUtilization < 70) {
    recommendations.push(
      "Resource utilization is low. Consider optimizing task assignments.",
    );
  }

  if (!project.tasks?.some((task) => task.priority === "high")) {
    recommendations.push(
      "No high-priority tasks identified. Review task prioritization.",
    );
  }

  return recommendations;
}

export const formatDate = (date: string | Date) => {
  return new Date(date).toLocaleDateString("en-US", {
    month: "short",
    day: "numeric",
    year: "numeric",
  });
};

export const formatDateTime = (date: string | Date) => {
  return new Date(date).toLocaleString("en-US", {
    month: "short",
    day: "numeric",
    year: "numeric",
    hour: "numeric",
    minute: "2-digit",
  });
};

export const formatCurrency = (amount: number) => {
  return new Intl.NumberFormat("en-US", {
    style: "currency",
    currency: "USD",
  }).format(amount);
};

export const generateSlug = (text: string) => {
  return text
    .toLowerCase()
    .replace(/[^\w ]+/g, "")
    .replace(/ +/g, "-");
};

export const truncateText = (text: string, maxLength: number) => {
  if (text.length <= maxLength) return text;
  return text.slice(0, maxLength) + "...";
};
```

### `src\lib\validate-request.ts`

```ts
import { z } from "zod";
import { ValidationError } from "./error-handler";

export async function validateRequest<T>(
  req: Request,
  schema: z.Schema<T>,
): Promise<T> {
  try {
    let data: unknown;

    // Parse request body based on content type
    const contentType = req.headers.get("content-type");
    if (contentType?.includes("application/json")) {
      data = await req.json();
    } else if (contentType?.includes("multipart/form-data")) {
      const formData = await req.formData();
      data = Object.fromEntries(formData);
    } else if (contentType?.includes("application/x-www-form-urlencoded")) {
      const formData = await req.formData();
      data = Object.fromEntries(formData);
    } else {
      throw new ValidationError("Unsupported content type");
    }

    // Validate the data against the schema
    const result = await schema.safeParseAsync(data);

    if (!result.success) {
      // Format Zod errors into a more readable structure
      const errors = result.error.errors.map((err) => ({
        path: err.path.join("."),
        message: err.message,
      }));

      throw new ValidationError(
        "Validation failed: " +
          errors.map((e) => `${e.path}: ${e.message}`).join(", "),
      );
    }

    return result.data;
  } catch (error) {
    if (error instanceof ValidationError) {
      throw error;
    }
    if (error instanceof z.ZodError) {
      throw new ValidationError(error.message);
    }
    throw new ValidationError("Failed to parse request body");
  }
}

// Helper for validating query parameters
export function validateQuery<T>(
  searchParams: URLSearchParams,
  schema: z.Schema<T>,
): T {
  try {
    const queryObj = Object.fromEntries(searchParams.entries());
    const result = schema.safeParse(queryObj);

    if (!result.success) {
      const errors = result.error.errors.map((err) => ({
        path: err.path.join("."),
        message: err.message,
      }));

      throw new ValidationError(
        "Query validation failed: " +
          errors.map((e) => `${e.path}: ${e.message}`).join(", "),
      );
    }

    return result.data;
  } catch (error) {
    if (error instanceof ValidationError) {
      throw error;
    }
    if (error instanceof z.ZodError) {
      throw new ValidationError(error.message);
    }
    throw new ValidationError("Failed to validate query parameters");
  }
}

// Helper for validating URL parameters
export function validateParams<T>(
  params: Record<string, string>,
  schema: z.Schema<T>,
): T {
  try {
    const result = schema.safeParse(params);

    if (!result.success) {
      const errors = result.error.errors.map((err) => ({
        path: err.path.join("."),
        message: err.message,
      }));

      throw new ValidationError(
        "Parameter validation failed: " +
          errors.map((e) => `${e.path}: ${e.message}`).join(", "),
      );
    }

    return result.data;
  } catch (error) {
    if (error instanceof ValidationError) {
      throw error;
    }
    if (error instanceof z.ZodError) {
      throw new ValidationError(error.message);
    }
    throw new ValidationError("Failed to validate URL parameters");
  }
}
```

### `src\lib\validations.ts`

```ts
export function isValidEmail(email: string) {
  return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
}

export function isValidPhone(phone: string) {
  return /^\+?[1-9]\d{1,14}$/.test(phone); // E.164 format
}

export function isValidFileName(fileName: string) {
  return fileName.length > 0 && fileName.length < 255;
}
```

### `src\lib\ai\classify.ts`

```ts
import { createChatCompletion } from "./openai-client";

// Define classification categories to match task categories
export type ClassificationCategory =
  | "Client Communication"
  | "Tax Preparation"
  | "Document Review"
  | "Financial Analysis"
  | "Task Management";

// Function to classify text input
export async function classifyText(
  text: string,
): Promise<ClassificationCategory> {
  const prompt = `Classify the following text into one of these categories: 
  - Client Communication
  - Tax Preparation
  - Document Review
  - Financial Analysis
  - Task Management

Text: "${text}"

Return only the category name.`;

  const result = await createChatCompletion([
    { role: "user", content: prompt },
  ]);

  if (!result) {
    throw new Error("Classification failed");
  }

  return result.trim() as ClassificationCategory;
}
```

### `src\lib\ai\openai-client.ts`

```ts
import { OpenAI } from "openai";

// Initialize OpenAI client with environment variable
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

// Utility function for making API calls
export async function createChatCompletion(
  messages: OpenAI.ChatCompletionMessageParam[],
  model: string = "gpt-4",
) {
  try {
    const response = await openai.chat.completions.create({
      model,
      messages,
      temperature: 0.7,
      max_tokens: 1000,
    });
    return response.choices[0].message?.content;
  } catch (error) {
    console.error("OpenAI API Error:", error);
    throw new Error("Failed to process AI request");
  }
}
```

### `src\lib\ai\summarize.ts`

```ts
import { createChatCompletion } from "./openai-client";

// Function to summarize text input
export async function summarizeText(
  text: string,
  maxLength: number = 200,
): Promise<string> {
  const prompt = `Summarize the following text in less than ${maxLength} characters:

Text: "${text}"

Return only the summary.`;

  const result = await createChatCompletion([
    { role: "user", content: prompt },
  ]);

  if (!result) {
    throw new Error("Summarization failed");
  }

  return result.trim();
}
```

### `src\lib\ai\tasks.ts`

```ts
import { classifyText } from "./classify";
import { createChatCompletion } from "./openai-client";

// Define task categories based on analysis
export const TASK_CATEGORIES = [
  "Payroll Processing",
  "Tax Preparation",
  "Documentation",
  "Client Management",
  "Employee Management",
] as const;

export type TaskCategory = (typeof TASK_CATEGORIES)[number];

/**
 * Classifies a task based on its title and description
 * @param title Task title
 * @param description Task description
 * @returns Promise resolving to the predicted task category
 */
export async function classifyTask(
  title: string,
  description: string,
): Promise<TaskCategory> {
  const input = `Task: ${title}\nDescription: ${description}`;

  // Use existing classification utility
  const result = await classifyText(input);

  // Map result to task categories
  const category = TASK_CATEGORIES.find(
    (c) => c.toLowerCase() === result.toLowerCase(),
  );
  return category || "Documentation"; // Default fallback
}

/**
 * Gets category suggestions for a task with confidence scores
 * @param title Task title
 * @param description Task description
 * @returns Promise resolving to array of category suggestions with scores
 */
export async function getCategorySuggestions(
  title: string,
  description: string,
): Promise<Array<{ category: TaskCategory; confidence: number }>> {
  const input = `Task: ${title}\nDescription: ${description}`;

  const response = await createChatCompletion(
    [
      {
        role: "system",
        content: `Analyze this task and provide category suggestions with confidence scores in JSON format. 
    Categories: ${TASK_CATEGORIES.join(", ")}
    Example response format:
    [
      {"category": "Payroll Processing", "confidence": 0.95},
      {"category": "Documentation", "confidence": 0.75}
    ]
    Return only valid JSON without any additional text or formatting.`,
      },
      {
        role: "user",
        content: input,
      },
    ],
    "gpt-4o-mini",
  );

  if (!response) {
    throw new Error("No content in AI response");
  }

  console.log("Raw AI Response:", response); // Log raw response

  try {
    // Remove any non-JSON content
    const jsonStart = response.indexOf("[");
    const jsonEnd = response.lastIndexOf("]") + 1;
    const jsonContent = response.slice(jsonStart, jsonEnd);

    console.log("Extracted JSON:", jsonContent); // Log extracted JSON

    // Parse and validate the response
    const parsed = JSON.parse(jsonContent);

    if (!Array.isArray(parsed)) {
      throw new Error("Response is not an array");
    }

    // Validate each suggestion
    const validSuggestions = parsed.map((suggestion) => {
      if (!TASK_CATEGORIES.includes(suggestion.category)) {
        throw new Error(`Invalid category: ${suggestion.category}`);
      }
      if (
        typeof suggestion.confidence !== "number" ||
        suggestion.confidence < 0 ||
        suggestion.confidence > 1
      ) {
        throw new Error(`Invalid confidence value: ${suggestion.confidence}`);
      }
      return suggestion;
    });

    return validSuggestions;
  } catch (error) {
    console.error("Failed to parse AI response:", response);
    throw new Error(
      `Failed to parse AI response: ${error instanceof Error ? error.message : "Unknown error"}`,
    );
  }
}
```

### `src\lib\api\projects.ts`

```ts
import { getRouteClient } from "@/lib/supabase/server-client";
import type { Database } from "@/types/database.types";

export async function getProjects() {
  const supabase = getRouteClient();
  const { data, error } = await supabase
    .from("projects")
    .select("*")
    .order("created_at", { ascending: false });

  if (error) throw error;
  return data;
}

export async function createProject(project: any) {
  const supabase = getRouteClient();
  const { data, error } = await supabase
    .from("projects")
    .insert(project)
    .select()
    .single();

  if (error) throw error;
  return data;
}

export async function updateProject(id: string, project: any) {
  const supabase = getRouteClient();
  const { data, error } = await supabase
    .from("projects")
    .update(project)
    .eq("id", id)
    .select()
    .single();

  if (error) throw error;
  return data;
}

export async function deleteProject(id: string) {
  const supabase = getRouteClient();
  const { error } = await supabase.from("projects").delete().eq("id", id);

  if (error) throw error;
}
```

### `src\lib\api\templates.ts`

```ts
import { getRouteClient } from "@/lib/supabase/server-client";
import type { Database } from "@/types/database.types";

export async function getTemplates() {
  const supabase = getRouteClient();
  const { data, error } = await supabase
    .from("templates")
    .select("*")
    .order("created_at", { ascending: false });

  if (error) throw error;
  return data;
}

export async function createTemplate(template: any) {
  const supabase = getRouteClient();
  const { data, error } = await supabase
    .from("templates")
    .insert(template)
    .select()
    .single();

  if (error) throw error;
  return data;
}

export async function updateTemplate(id: string, template: any) {
  const supabase = getRouteClient();
  const { data, error } = await supabase
    .from("templates")
    .update(template)
    .eq("id", id)
    .select()
    .single();

  if (error) throw error;
  return data;
}

export async function deleteTemplate(id: string) {
  const supabase = getRouteClient();
  const { error } = await supabase.from("templates").delete().eq("id", id);

  if (error) throw error;
}
```

### `src\lib\services\document-categorization.ts`

```ts
import type { DocumentCategory } from "@/types/documents";

interface CategoryPattern {
  category: DocumentCategory;
  patterns: RegExp[];
  fileTypes?: string[];
}

const categoryPatterns: CategoryPattern[] = [
  {
    category: "tax_return",
    patterns: [
      /1040/i,
      /tax.?return/i,
      /schedule [a-e]/i,
      /form.?(w-2|1099|941|940)/i,
      /k-1/i,
      /1120s?/i,
      /1065/i,
    ],
    fileTypes: ["application/pdf"],
  },
  {
    category: "financial_statement",
    patterns: [
      /balance.?sheet/i,
      /income.?statement/i,
      /cash.?flow/i,
      /profit.?(and|&).?loss/i,
      /p&l/i,
      /financial.?statement/i,
      /trial.?balance/i,
    ],
    fileTypes: [
      "application/pdf",
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    ],
  },
  {
    category: "payroll",
    patterns: [
      /payroll/i,
      /form.?941/i,
      /form.?940/i,
      /w-2/i,
      /1099/i,
      /wage.?report/i,
      /time.?sheet/i,
      /pay.?stub/i,
    ],
  },
  {
    category: "corporate",
    patterns: [
      /articles.?of.?incorporation/i,
      /operating.?agreement/i,
      /bylaws/i,
      /board.?resolution/i,
      /meeting.?minutes/i,
      /ein/i,
      /certificate.?of.?(good.?standing|formation)/i,
    ],
  },
];

export async function categorizeDocument(
  fileName: string,
  fileType: string,
): Promise<DocumentCategory> {
  // First, try to match based on file name patterns
  for (const { category, patterns, fileTypes } of categoryPatterns) {
    if (fileTypes && !fileTypes.includes(fileType)) continue;
    if (patterns.some((pattern) => pattern.test(fileName))) {
      return category;
    }
  }

  // If no patterns match, try to categorize based on file type
  if (fileType.includes("pdf")) {
    return "tax_return"; // Most PDFs in tax practice are likely tax returns
  }

  if (fileType.includes("sheet") || fileType.includes("excel")) {
    return "financial_statement";
  }

  // Default category for unrecognized documents
  return "supporting";
}

export function suggestDocumentName(
  originalName: string,
  category: DocumentCategory,
  year?: number,
  metadata?: {
    tax_year?: number;
    form_type?: string;
    business_type?: string;
    quarter?: number;
    month?: number;
  },
): string {
  const cleanName = originalName
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "_")
    .replace(/^_|_$/g, "");

  const yearStr = year ? `_${year}` : "";
  const formType = metadata?.form_type ? `_${metadata.form_type}` : "";
  const businessType = metadata?.business_type
    ? `_${metadata.business_type}`
    : "";
  const quarter = metadata?.quarter ? `_q${metadata.quarter}` : "";
  const month = metadata?.month
    ? `_m${String(metadata.month).padStart(2, "0")}`
    : "";

  return `${category}/${cleanName}${yearStr}${formType}${businessType}${quarter}${month}`;
}

export function extractYearFromFileName(fileName: string): number | undefined {
  const yearMatch = fileName.match(/\b(19|20)\d{2}\b/);
  if (yearMatch) return parseInt(yearMatch[0]);

  // Try to extract year from common tax form patterns
  const taxYearMatch = fileName.match(/tax.?year.?(\d{4})/i);
  if (taxYearMatch) return parseInt(taxYearMatch[1]);

  // Try to extract year from quarter notation (e.g., Q2 2023)
  const quarterYearMatch = fileName.match(/q[1-4].?(\d{4})/i);
  if (quarterYearMatch) return parseInt(quarterYearMatch[1]);

  return undefined;
}

export function validateDocumentCategory(
  category: DocumentCategory,
  allowedCategories?: DocumentCategory[],
): boolean {
  if (!allowedCategories || allowedCategories.length === 0) {
    return true;
  }
  return allowedCategories.includes(category);
}
```

### `src\lib\services\task.service.ts`

```ts
import { supabaseBrowserClient } from "@/lib/supabaseBrowserClient";
import type { Database } from "@/types/database.types";

export class TaskService {
  static async getTasks() {
    const { data, error } = await supabaseBrowserClient
      .from("tasks")
      .select("*")
      .order("created_at", { ascending: false });

    if (error) throw error;
    return data;
  }

  static async createTask(
    task: Database["public"]["Tables"]["tasks"]["Insert"],
  ) {
    const { data, error } = await supabaseBrowserClient
      .from("tasks")
      .insert(task)
      .select()
      .single();

    if (error) throw error;
    return data;
  }

  static async updateTask(
    id: string,
    task: Partial<Database["public"]["Tables"]["tasks"]["Update"]>,
  ) {
    const { data, error } = await supabaseBrowserClient
      .from("tasks")
      .update(task)
      .eq("id", id)
      .select()
      .single();

    if (error) throw error;
    return data;
  }

  static async deleteTask(id: string) {
    const { error } = await supabaseBrowserClient
      .from("tasks")
      .delete()
      .eq("id", id);

    if (error) throw error;
  }
}
```

### `src\lib\storage\storage.ts`

```ts
import { supabaseBrowserClient } from "@/lib/supabaseBrowserClient";

export class StorageService {
  static readonly BUCKET_NAME = "documents";

  static async initializeBucket() {
    try {
      // Check if bucket exists
      const { data: buckets } =
        await supabaseBrowserClient.storage.listBuckets();
      const bucketExists = buckets?.some(
        (b) => b.name === StorageService.BUCKET_NAME,
      );

      if (!bucketExists) {
        // Create bucket if it doesn't exist
        await supabaseBrowserClient.storage.createBucket(
          StorageService.BUCKET_NAME,
          {
            public: false,
            fileSizeLimit: 52428800, // 50MB
          },
        );
      }
    } catch (error) {
      console.error("Error initializing storage bucket:", error);
      throw error;
    }
  }

  static async uploadFile(file: File, path: string) {
    try {
      const { data, error } = await supabaseBrowserClient.storage
        .from(StorageService.BUCKET_NAME)
        .upload(path, file, {
          cacheControl: "3600",
          upsert: false,
        });

      if (error) throw error;
      return data;
    } catch (error) {
      console.error("Error uploading file:", error);
      throw error;
    }
  }

  static async getFileUrl(path: string) {
    try {
      const { data } = supabaseBrowserClient.storage
        .from(StorageService.BUCKET_NAME)
        .getPublicUrl(path);

      return data.publicUrl;
    } catch (error) {
      console.error("Error getting file URL:", error);
      throw error;
    }
  }
}
```

### `src\lib\supabase\auth.ts`

```ts
import { supabaseBrowserClient } from "@/lib/supabaseBrowserClient";
import type { User } from "@supabase/supabase-js";

export const getAuthenticatedUser = async () => {
  const {
    data: { user },
    error,
  } = await supabaseBrowserClient.auth.getUser();

  if (error) throw error;
  return user;
};

export const validateUserSession = async () => {
  const user = await getAuthenticatedUser();
  if (!user) return false;

  // Check if user has necessary profile data
  const { data: profile, error } = await supabaseBrowserClient
    .from("profiles")
    .select("role, full_name")
    .eq("id", user.id)
    .single();

  if (error || !profile) return false;

  return true;
};

export const getUserRole = async (user: User) => {
  const { data: profile, error } = await supabaseBrowserClient
    .from("profiles")
    .select("role")
    .eq("id", user.id)
    .single();

  if (error || !profile) return null;
  return profile.role;
};

export const refreshUserSession = async () => {
  const {
    data: { session },
    error,
  } = await supabaseBrowserClient.auth.refreshSession();

  if (error) throw error;
  return session;
};
```

### `src\lib\supabase\browser.ts`

```ts
"use client";

import { createBrowserClient } from "@supabase/ssr";

let client: ReturnType<typeof createBrowserClient> | null = null;

export function createClient() {
  if (client) return client;

  client = createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
  );

  return client;
}
```

### `src\lib\supabase\dashboardQueries.ts`

```ts
import { getServerClient } from "@/lib/supabase/server-client";
import type { Database } from "@/types/database.types";

type TaxReturnStatus = Database["public"]["Enums"]["tax_return_status"];
type ProjectStatus = Database["public"]["Enums"]["project_status"];
type ClientStatus = Database["public"]["Enums"]["client_status"];

export async function getDashboardMetrics() {
  const supabase = getServerClient();

  try {
    // Get total active clients
    const { data: clients, error: clientsError } = await supabase
      .from("clients")
      .select("id")
      .eq("status", "active" satisfies ClientStatus);

    if (clientsError) throw clientsError;

    // Get pending tax returns
    const { data: taxReturns, error: taxReturnsError } = await supabase
      .from("tax_returns")
      .select("id")
      .eq("status", "pending" satisfies TaxReturnStatus);

    if (taxReturnsError) throw taxReturnsError;

    // Get active projects
    const { data: projects, error: projectsError } = await supabase
      .from("projects")
      .select("id")
      .eq("status", "in_progress" satisfies ProjectStatus);

    if (projectsError) throw projectsError;

    return {
      activeClients: clients?.length || 0,
      pendingReturns: taxReturns?.length || 0,
      activeProjects: projects?.length || 0,
    };
  } catch (error) {
    console.error("Error fetching dashboard metrics:", error);
    throw error;
  }
}
```

### `src\lib\supabase\database-utils.ts`

```ts
import { SupabaseClient } from "@supabase/supabase-js";
import { Database } from "@/types/database.types";
import { handleDatabaseError } from "./server";

type DbResult<T> =
  | {
      data: T;
      error: null;
    }
  | {
      data: null;
      error: Error;
    };

export async function safeQuery<T>(
  operation: () => Promise<{ data: T | null; error: any }>,
): Promise<DbResult<T>> {
  try {
    const { data, error } = await operation();
    if (error) throw error;
    if (!data) throw new Error("No data returned from the query");
    return { data, error: null };
  } catch (error) {
    return { data: null, error: handleDatabaseError(error) as Error };
  }
}

// Utility for checking if user has required permissions
export async function checkPermission(
  supabase: SupabaseClient<Database>,
  table: string,
  action: "SELECT" | "INSERT" | "UPDATE" | "DELETE",
): Promise<boolean> {
  try {
    switch (action) {
      case "SELECT":
        const { data } = await supabase.from(table).select("id").limit(1);
        return data !== null;
      case "INSERT":
        const { error: insertError } = await supabase.from(table).insert({})
          .abortSignal;
        return (
          !insertError || !insertError.message.includes("permission denied")
        );
      case "UPDATE":
        const { error: updateError } = await supabase
          .from(table)
          .update({})
          .match({ id: "test" }).abortSignal;
        return (
          !updateError || !updateError.message.includes("permission denied")
        );
      case "DELETE":
        const { error: deleteError } = await supabase
          .from(table)
          .delete()
          .match({ id: "test" }).abortSignal;
        return (
          !deleteError || !deleteError.message.includes("permission denied")
        );
      default:
        return false;
    }
  } catch {
    return false;
  }
}

// Type-safe database operations
export const dbOperations = {
  // Fetch a single record by ID
  async getById<T extends keyof Database["public"]["Tables"]>(
    supabase: SupabaseClient<Database>,
    table: T,
    id: string,
  ) {
    return safeQuery(() =>
      supabase.from(table).select("*").eq("id", id).single(),
    );
  },

  // Fetch multiple records with optional filters
  async getMany<T extends keyof Database["public"]["Tables"]>(
    supabase: SupabaseClient<Database>,
    table: T,
    options?: {
      filters?: Record<string, any>;
      limit?: number;
      offset?: number;
      orderBy?: { column: string; ascending?: boolean };
    },
  ) {
    let query = supabase.from(table).select("*");

    if (options?.filters) {
      Object.entries(options.filters).forEach(([key, value]) => {
        query = query.eq(key, value);
      });
    }

    if (options?.orderBy) {
      query = query.order(options.orderBy.column, {
        ascending: options.orderBy.ascending ?? true,
      });
    }

    if (options?.limit) {
      query = query.limit(options.limit);
    }

    if (options?.offset) {
      query = query.range(
        options.offset,
        options.offset + (options.limit || 10) - 1,
      );
    }

    return safeQuery(() => query);
  },

  // Insert a new record
  async insert<T extends keyof Database["public"]["Tables"]>(
    supabase: SupabaseClient<Database>,
    table: T,
    data: Database["public"]["Tables"][T]["Insert"],
  ) {
    return safeQuery(() => supabase.from(table).insert(data).select().single());
  },

  // Update a record
  async update<T extends keyof Database["public"]["Tables"]>(
    supabase: SupabaseClient<Database>,
    table: T,
    id: string,
    data: Partial<Database["public"]["Tables"][T]["Update"]>,
  ) {
    return safeQuery(() =>
      supabase.from(table).update(data).eq("id", id).select().single(),
    );
  },

  // Delete a record
  async delete<T extends keyof Database["public"]["Tables"]>(
    supabase: SupabaseClient<Database>,
    table: T,
    id: string,
  ) {
    return safeQuery(() =>
      supabase.from(table).delete().eq("id", id).select().single(),
    );
  },
};
```

### `src\lib\supabase\env.ts`

```ts
const requiredEnvVars = [
  "NEXT_PUBLIC_SUPABASE_URL",
  "NEXT_PUBLIC_SUPABASE_ANON_KEY",
  "SUPABASE_SERVICE_ROLE_KEY",
] as const;

export function checkSupabaseEnvVars() {
  const missingVars = requiredEnvVars.filter((envVar) => !process.env[envVar]);

  if (missingVars.length > 0) {
    throw new Error(
      `Missing required environment variables: ${missingVars.join(", ")}`,
    );
  }

  return {
    supabaseUrl: process.env.NEXT_PUBLIC_SUPABASE_URL!,
    supabaseAnonKey: process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    supabaseServiceRoleKey: process.env.SUPABASE_SERVICE_ROLE_KEY!,
  };
}
```

### `src\lib\supabase\server.ts`

```ts
import { createServerClient } from "@supabase/ssr";
import { cookies } from "next/headers";

export function createClient() {
  const cookieStore = cookies();

  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: any) {
          cookieStore.set(name, value, options);
        },
        remove(name: string, options: any) {
          cookieStore.set(name, "", { ...options, maxAge: 0 });
        },
      },
    },
  );
}
```

### `src\lib\supabase\tasks.ts`

```ts
"use client";

import { supabaseBrowserClient } from "@/lib/supabaseBrowserClient";
import type { Database } from "@/types/database.types";

type Task = Database["public"]["Tables"]["tasks"]["Row"];
type TaskInsert = Database["public"]["Tables"]["tasks"]["Insert"];
type TaskUpdate = Database["public"]["Tables"]["tasks"]["Update"];

export async function getTasks() {
  const { data, error } = await supabaseBrowserClient
    .from("tasks")
    .select("*")
    .order("created_at", { ascending: false });

  if (error) throw error;
  return data;
}

export async function getTasksByProject(projectId: string) {
  const { data, error } = await supabaseBrowserClient
    .from("tasks")
    .select("*")
    .eq("project_id", projectId)
    .order("created_at", { ascending: false });

  if (error) throw error;
  return data;
}

export async function createTask(task: TaskInsert) {
  const { data, error } = await supabaseBrowserClient
    .from("tasks")
    .insert(task)
    .select()
    .single();

  if (error) throw error;
  return data;
}

export async function updateTask(id: string, updates: Partial<TaskUpdate>) {
  const { data, error } = await supabaseBrowserClient
    .from("tasks")
    .update(updates)
    .eq("id", id)
    .select()
    .single();

  if (error) throw error;
  return data;
}

export async function deleteTask(id: string) {
  const { error } = await supabaseBrowserClient
    .from("tasks")
    .delete()
    .eq("id", id);

  if (error) throw error;
}
```

### `src\lib\supabase\__mocks__\supabase.ts`

```ts
import { jest } from "@jest/globals";

export const createMockSupabaseClient = () => ({
  auth: {
    getUser: jest.fn(),
    signOut: jest.fn(),
  },
  from: jest.fn().mockReturnThis(),
  select: jest.fn().mockReturnThis(),
  insert: jest.fn(),
  update: jest.fn(),
  delete: jest.fn(),
  eq: jest.fn(),
  in: jest.fn(),
  or: jest.fn(),
  and: jest.fn(),
  single: jest.fn(),
  order: jest.fn(),
  limit: jest.fn(),
  range: jest.fn(),
  match: jest.fn(),
  neq: jest.fn(),
  gt: jest.fn(),
  gte: jest.fn(),
  lt: jest.fn(),
  lte: jest.fn(),
  is: jest.fn(),
  contains: jest.fn(),
  containedBy: jest.fn(),
  overlaps: jest.fn(),
  textSearch: jest.fn(),
  filter: jest.fn(),
  not: jest.fn(),
  ilike: jest.fn(),
  like: jest.fn(),
  between: jest.fn(),
  maybeSingle: jest.fn(),
  count: jest.fn(),
  then: jest.fn(),
  catch: jest.fn(),
  finally: jest.fn(),
});
```

### `src\lib\templates\taskTemplates.ts`

```ts
import { Database } from "@/types/database.types";

type TaskPriority = Database["public"]["Enums"]["task_priority"];
type ServiceType = Database["public"]["Enums"]["service_type"];

export interface TaskTemplate {
  title: string;
  description: string;
  priority: TaskPriority;
  estimateDueDate?: () => Date;
  checklist?: string[];
}

export const onboardingTaskTemplates: Record<ServiceType, TaskTemplate[]> = {
  tax_return: [
    {
      title: "Initial Tax Return Consultation",
      description:
        "Schedule and conduct initial consultation to understand client tax situation and requirements",
      priority: "high",
      estimateDueDate: () => {
        const date = new Date();
        date.setDate(date.getDate() + 7);
        return date;
      },
      checklist: [
        "Review previous tax returns",
        "Identify required documents",
        "Discuss filing deadlines",
        "Explain tax preparation process",
        "Address client questions and concerns",
      ],
    },
    {
      title: "Document Collection Setup",
      description:
        "Set up document collection system and send document request list",
      priority: "high",
      estimateDueDate: () => {
        const date = new Date();
        date.setDate(date.getDate() + 3);
        return date;
      },
      checklist: [
        "Create client portal account",
        "Send document checklist",
        "Set up document reminders",
        "Verify client access to portal",
      ],
    },
  ],
  bookkeeping: [
    {
      title: "Bookkeeping System Setup",
      description:
        "Set up accounting software and initial bookkeeping structure",
      priority: "high",
      estimateDueDate: () => {
        const date = new Date();
        date.setDate(date.getDate() + 5);
        return date;
      },
      checklist: [
        "Set up chart of accounts",
        "Configure accounting software",
        "Import historical data",
        "Set up bank feeds",
        "Train client on basic usage",
      ],
    },
    {
      title: "Initial Financial Review",
      description: "Review current financial records and establish baseline",
      priority: "medium",
      estimateDueDate: () => {
        const date = new Date();
        date.setDate(date.getDate() + 10);
        return date;
      },
    },
  ],
  payroll: [
    {
      title: "Payroll System Setup",
      description: "Configure payroll system and employee information",
      priority: "high",
      estimateDueDate: () => {
        const date = new Date();
        date.setDate(date.getDate() + 3);
        return date;
      },
      checklist: [
        "Collect employee information",
        "Set up direct deposit",
        "Configure tax withholdings",
        "Set up payroll schedule",
        "Test payroll run",
      ],
    },
    {
      title: "Payroll Compliance Review",
      description: "Review and ensure compliance with payroll regulations",
      priority: "high",
      estimateDueDate: () => {
        const date = new Date();
        date.setDate(date.getDate() + 5);
        return date;
      },
    },
  ],
  advisory: [
    {
      title: "Initial Advisory Meeting",
      description:
        "Conduct initial advisory meeting to understand business goals and challenges",
      priority: "medium",
      estimateDueDate: () => {
        const date = new Date();
        date.setDate(date.getDate() + 7);
        return date;
      },
      checklist: [
        "Review business objectives",
        "Identify key challenges",
        "Discuss growth opportunities",
        "Create initial action plan",
      ],
    },
    {
      title: "Financial Analysis Setup",
      description: "Set up financial analysis and reporting framework",
      priority: "medium",
      estimateDueDate: () => {
        const date = new Date();
        date.setDate(date.getDate() + 14);
        return date;
      },
    },
  ],
};
```

### `src\lib\utils\error-handling.ts`

```ts
import { AuthError } from "@supabase/supabase-js";

export const handleSupabaseError = (error: any) => {
  if (error?.code === "42501") {
    console.error("Permission denied error:", error);
    return "You do not have permission to perform this action. Please contact your administrator.";
  }
  return "An unexpected error occurred. Please try again.";
};
```

### `src\lib\utils\project-form.ts`

```ts
import { ProjectFormValues, ProjectWithRelations } from "@/types/projects";

export function getProjectFormDefaults(
  project?: ProjectWithRelations,
): Partial<ProjectFormValues> {
  if (!project) return {};

  return {
    creation_type: project.template_id ? "template" : "custom",
    template_id: project.template_id,
    name: project.name,
    description: project.description,
    client_id: project.client_id || "",
    status: project.status,
    priority: project.priority,
    service_type: project.service_type || "tax_return",
    due_date: project.due_date,
    tax_info: project.tax_info,
    accounting_info: project.accounting_info,
    payroll_info: project.payroll_info,
    tasks: project.tasks || [],
    team_members: project.team_members?.map((member) => member.user_id) || [],
    tax_return_id: project.tax_return_id,
    tax_return_status: null,
    accounting_period: null,
    start_date: project.start_date,
    end_date: project.end_date,
    parent_project_id: project.parent_project_id,
    primary_manager: project.primary_manager,
    completed_tasks: project.completed_tasks || 0,
    completion_percentage: project.completion_percentage || 0,
    task_count: project.task_count || 0,
    stage: project.stage,
    service_info: project.service_info,
    project_defaults: null,
  };
}
```

### `src\lib\utils\time.ts`

```ts
export function hoursToMinutes(hours: number): number {
  return Math.round(hours * 60);
}

export function minutesToHours(minutes: number): number {
  return Math.round((minutes / 60) * 100) / 100;
}

export function roundToNearest(value: number, nearest: number = 1): number {
  return Math.round(value / nearest) * nearest;
}
```

### `src\lib\validations\auth.ts`

```ts
import { z } from "zod";
import { type UserRole } from "@/types/auth";

const passwordSchema = z
  .string()
  .min(8, "Password must be at least 8 characters")
  .max(100, "Password must not exceed 100 characters")
  .regex(
    /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/,
    "Password must contain at least one uppercase letter, one lowercase letter, one number, and one special character",
  );

export const signInSchema = z.object({
  email: z
    .string()
    .email("Invalid email address")
    .min(5, "Email must be at least 5 characters")
    .max(254, "Email must not exceed 254 characters"),
  password: passwordSchema,
  remember: z.boolean().optional(),
});

export const signUpSchema = z
  .object({
    email: z
      .string()
      .email("Invalid email address")
      .min(5, "Email must be at least 5 characters")
      .max(254, "Email must not exceed 254 characters"),
    password: passwordSchema,
    confirmPassword: passwordSchema,
    full_name: z
      .string()
      .min(2, "Full name must be at least 2 characters")
      .max(100, "Full name must not exceed 100 characters")
      .regex(
        /^[a-zA-Z\s'-]+$/,
        "Full name can only contain letters, spaces, hyphens, and apostrophes",
      ),
    role: z.enum([
      "admin",
      "team_member",
    ] as const satisfies readonly UserRole[]),
  })
  .refine((data) => data.password === data.confirmPassword, {
    message: "Passwords don't match",
    path: ["confirmPassword"],
  });

export const resetPasswordSchema = z.object({
  email: z
    .string()
    .email("Invalid email address")
    .min(5, "Email must be at least 5 characters")
    .max(254, "Email must not exceed 254 characters"),
});

export const updatePasswordSchema = z
  .object({
    currentPassword: passwordSchema,
    newPassword: passwordSchema,
    confirmNewPassword: passwordSchema,
  })
  .refine((data) => data.newPassword === data.confirmNewPassword, {
    message: "New passwords don't match",
    path: ["confirmNewPassword"],
  })
  .refine((data) => data.currentPassword !== data.newPassword, {
    message: "New password must be different from current password",
    path: ["newPassword"],
  });

export type SignInValues = z.infer<typeof signInSchema>;
export type SignUpValues = z.infer<typeof signUpSchema>;
export type ResetPasswordValues = z.infer<typeof resetPasswordSchema>;
export type UpdatePasswordValues = z.infer<typeof updatePasswordSchema>;
```

### `src\lib\validations\client.ts`

```ts
import { z } from "zod";
import type { Database } from "@/types/database.types";

type DbEnums = Database["public"]["Enums"];

// Main client form schema
export const clientFormSchema = z.object({
  // Required fields
  full_name: z.string().min(1, "Full name is required"),
  contact_email: z.string().email("invalid email format"),

  // Optional fields
  company_name: z.string().optional(),
  onboarding_notes: z.string().optional(),

  // Default fields
  status: z
    .enum([
      "active",
      "inactive",
      "pending",
      "archived",
    ] as const satisfies readonly DbEnums["client_status"])
    .default("pending"),
  type: z
    .enum([
      "business",
      "individual",
    ] as const satisfies readonly DbEnums["client_type"])
    .default("individual"),

  // Optional JSON fields
  contact_details: z
    .object({
      phone: z.string().optional(),
      address: z.string().optional(),
      city: z.string().optional(),
      state: z.string().optional(),
      zip: z.string().optional(),
    })
    .optional(),

  tax_info: z
    .object({
      filing_status: z.string().optional(),
      tax_id: z.string().optional(),
      tax_year: z.number().optional(),
      filing_type: z.string().optional(),
      tax_id_type: z.string().optional(),
      dependents: z.array(z.any()).optional(),
      previous_returns: z.array(z.any()).optional(),
    })
    .optional(),
});

// Export types
export type ClientFormSchema = z.infer<typeof clientFormSchema>;

// Validation helpers
export function validateClientForm(
  data: unknown,
):
  | { success: true; data: ClientFormSchema }
  | { success: false; error: z.ZodError } {
  const result = clientFormSchema.safeParse(data);
  return result;
}
```

### `src\lib\validations\project.ts`

```ts
import { z } from "zod";
import type { Database } from "@/types/database.types";

type DbTaskInsert = Database["public"]["Tables"]["tasks"]["Insert"];

// Main project form schema
export const projectSchema = z.object({
  name: z.string().min(1, "Project name is required"),
  description: z.string().optional(),
  client_id: z.string().uuid("Invalid client ID"),
  template_id: z.string().uuid("Invalid template ID").optional(),
  service_type: z
    .enum(["tax_return", "bookkeeping", "payroll", "advisory"])
    .nullable(),
  status: z.enum([
    "not_started",
    "on_hold",
    "cancelled",
    "todo",
    "in_progress",
    "review",
    "blocked",
    "completed",
    "archived",
  ]),
  priority: z.enum(["low", "medium", "high", "urgent"]).optional(),
  due_date: z.string().datetime().optional(),
  start_date: z.string().datetime().optional(),
  end_date: z.string().datetime().optional(),
  tax_info: z.any().nullable(),
  accounting_info: z.any().nullable(),
  payroll_info: z.any().nullable(),
  service_info: z.any().nullable(),
  tax_return_id: z.string().uuid("Invalid tax return ID").nullable(),
  parent_project_id: z.string().uuid("Invalid parent project ID").nullable(),
  primary_manager: z.string().uuid("Invalid manager ID").nullable(),
  stage: z.string().nullable(),
  completed_tasks: z.number().nullable(),
  completion_percentage: z.number().nullable(),
  task_count: z.number().nullable(),
  template_tasks: z.array(z.custom<DbTaskInsert>()).optional(),
});

// Export types
export type ProjectFormSchema = z.infer<typeof projectSchema>;
export type ProjectFormValues = ProjectFormSchema;
export type ProjectFormData = ProjectFormSchema;

// Validation helpers
export function validateProjectForm(
  data: unknown,
):
  | { success: true; data: ProjectFormSchema }
  | { success: false; error: z.ZodError } {
  const result = projectSchema.safeParse(data);
  return result;
}
```

### `src\lib\validations\schema.ts`

```ts
import { z } from "zod";
import { CLIENT_STATUS, CLIENT_TYPE, FILING_TYPE } from "@/types/clients";
import { PROJECT_STATUS, SERVICE_TYPE } from "@/types/projects";
import { TASK_STATUS, TASK_PRIORITY } from "@/types/tasks";

// Client Schemas
export const contactInfoSchema = z.object({
  email: z.string().email(),
  phone: z.string().optional(),
  address: z
    .object({
      street: z.string(),
      city: z.string(),
      state: z.string(),
      zip: z.string(),
    })
    .optional(),
  alternate_email: z.string().email().optional(),
  alternate_phone: z.string().optional(),
  preferred_contact_method: z.enum(["email", "phone"]).optional(),
  notes: z.string().optional(),
});

export const taxInfoSchema = z.object({
  filing_type: z.enum(FILING_TYPE),
  tax_id_type: z.enum(["ssn", "ein"]).optional(),
  tax_id: z.string().optional(),
  filing_status: z.string().optional(),
  dependents: z
    .array(
      z.object({
        name: z.string(),
        ssn: z.string().optional(),
        relationship: z.string().optional(),
        birth_date: z.string().optional(),
      }),
    )
    .optional(),
  previous_returns: z
    .array(
      z.object({
        year: z.number(),
        filed_date: z.string(),
        preparer: z.string().optional(),
        notes: z.string().optional(),
      }),
    )
    .optional(),
});

export const clientSchema = z.object({
  contact_email: z.string().email(),
  full_name: z.string().optional(),
  company_name: z.string().optional(),
  status: z.enum(CLIENT_STATUS),
  type: z.enum(CLIENT_TYPE),
  contact_info: contactInfoSchema,
  tax_info: taxInfoSchema.nullable(),
  business_tax_id: z.string().optional(),
  individual_tax_id: z.string().optional(),
});

// Project Schemas
export const projectTaxInfoSchema = z.object({
  return_type: z.enum(FILING_TYPE),
  tax_year: z.number(),
  filing_status: z.string().optional(),
  is_extension_filed: z.boolean().optional(),
  extension_date: z.string().optional(),
  documents_received: z.boolean().optional(),
  last_filed_date: z.string().optional(),
});

export const accountingInfoSchema = z.object({
  fiscal_year_end: z.string().optional(),
  accounting_method: z.enum(["cash", "accrual"]).optional(),
  last_reconciliation_date: z.string().optional(),
  software: z.string().optional(),
  chart_of_accounts_setup: z.boolean().optional(),
  notes: z.string().optional(),
});

export const payrollInfoSchema = z.object({
  frequency: z.enum(["weekly", "bi-weekly", "monthly"]).optional(),
  employee_count: z.number().optional(),
  last_payroll_date: z.string().optional(),
  next_payroll_date: z.string().optional(),
  tax_deposit_schedule: z.enum(["monthly", "semi-weekly"]).optional(),
  notes: z.string().optional(),
});

export const projectSchema = z.object({
  name: z.string(),
  description: z.string().optional(),
  status: z.enum(PROJECT_STATUS),
  service_type: z.enum(SERVICE_TYPE),
  client_id: z.string().optional(),
  primary_manager: z.string().optional(),
  start_date: z.string().optional(),
  due_date: z.string().optional(),
  end_date: z.string().optional(),
  tax_info: projectTaxInfoSchema.nullable(),
  accounting_info: accountingInfoSchema.nullable(),
  payroll_info: payrollInfoSchema.nullable(),
  service_info: z.record(z.unknown()).nullable(),
});

// Task Schemas
export const taskRecurringConfigSchema = z.object({
  frequency: z.enum(["daily", "weekly", "monthly", "yearly"]),
  interval: z.number(),
  end_date: z.string().optional(),
  end_occurrences: z.number().optional(),
});

export const taskSchema = z.object({
  title: z.string(),
  description: z.string().optional(),
  status: z.enum(TASK_STATUS),
  priority: z.enum(TASK_PRIORITY).optional(),
  project_id: z.string().optional(),
  assignee_id: z.string().optional(),
  due_date: z.string().optional(),
  start_date: z.string().optional(),
  progress: z.number().optional(),
  recurring_config: taskRecurringConfigSchema.nullable(),
  parent_task_id: z.string().optional(),
  dependencies: z.array(z.string()).optional(),
  category: z.string().optional(),
  tax_form_type: z.string().optional(),
  tax_return_id: z.string().optional(),
  template_id: z.string().optional(),
});
```

### `src\lib\validations\task.ts`

```ts
import { z } from "zod";
import {
  TaskStatus,
  TaskPriority,
  taskStatusOptions,
  taskPriorityOptions,
} from "@/types/tasks";

export const taskFormSchema = z.object({
  title: z.string().min(1, "Task title is required"),
  description: z.string().nullable().optional(),
  status: z.enum(taskStatusOptions),
  priority: z.enum(taskPriorityOptions).nullable().optional(),
  project_id: z.string().uuid("Invalid project ID").nullable().optional(),
  assignee_id: z.string().uuid("Invalid assignee ID").nullable().optional(),
  due_date: z.string().datetime().nullable().optional(),
  start_date: z.string().datetime().nullable().optional(),
  tax_form_type: z.string().nullable().optional(),
  category: z.string().nullable().optional(),
});

export type TaskFormSchema = z.infer<typeof taskFormSchema>;

// Task Status Transitions
export const taskStatusTransitions = {
  todo: ["in_progress", "review"],
  in_progress: ["todo", "review", "completed"],
  review: ["in_progress", "completed"],
  completed: ["review"],
} as const;

// Utility type for valid status transitions
export type ValidStatusTransition<T extends TaskStatus> =
  (typeof taskStatusTransitions)[T][number];
```

### `src\lib\validations\template-category.ts`

```ts
import { z } from "zod";
import { Database } from "@/types/database.types";

type TemplateCategoryRow =
  Database["public"]["Tables"]["template_categories"]["Row"];

// Helper type for dates
const dateSchema = z
  .union([z.string(), z.date(), z.null()])
  .transform((val) => {
    if (!val) return null;
    if (val instanceof Date) return val.toISOString();
    return val;
  });

// Template category schema
export const templateCategorySchema = z.object({
  id: z.string().optional(),
  name: z.string().min(1, "Category name is required"),
  description: z.string().optional().nullable(),
  parent_id: z.string().optional().nullable(),
  position: z.number().optional().nullable(),
  created_at: dateSchema,
  updated_at: dateSchema,
}) satisfies z.ZodType<TemplateCategoryRow>;

// Export types
export type TemplateCategoryFormValues = z.infer<typeof templateCategorySchema>;
```

### `src\lib\validations\template.ts`

```ts
import { z } from "zod";
import type { Database } from "@/types/database.types";

type DbEnums = Database["public"]["Enums"];

// Helper schemas
const dateSchema = z
  .string()
  .regex(/^\d{4}-\d{2}-\d{2}$/, "Invalid date format (YYYY-MM-DD)")
  .nullable();

// Define JSON field schemas
const taskTemplateSchema = z
  .object({
    id: z.string().uuid("Invalid UUID format"),
    title: z.string(),
    description: z.string().nullable(),
    order_index: z.number().min(0),
    required: z.boolean().nullable(),
    auto_assign: z.boolean().nullable(),
    assigned_to: z.string().uuid("Invalid UUID format").nullable(),
    estimated_duration: z.number().min(0).nullable(),
    dependencies: z.array(z.string().uuid("Invalid UUID format")).nullable(),
    checklist: z
      .array(
        z.object({
          title: z.string(),
          required: z.boolean().nullable(),
          description: z.string().nullable(),
        }),
      )
      .nullable(),
  })
  .nullable();

const workflowTemplateSchema = z
  .object({
    id: z.string().uuid("Invalid UUID format"),
    name: z.string(),
    description: z.string().nullable(),
    order_index: z.number().min(0),
    required: z.boolean().nullable(),
    auto_assign: z.boolean().nullable(),
    assigned_to: z.string().uuid("Invalid UUID format").nullable(),
    estimated_duration: z.number().min(0).nullable(),
    stages: z
      .array(
        z.object({
          title: z.string(),
          required: z.boolean().nullable(),
          description: z.string().nullable(),
          tasks: z.array(taskTemplateSchema).nullable(),
        }),
      )
      .nullable(),
  })
  .nullable();

const customFieldsSchema = z.record(z.string(), z.unknown()).nullable();

// Main template form schema
export const templateFormSchema = z.object({
  // Required fields
  name: z.string().min(1, "Template name is required"),
  status: z.enum([
    "active",
    "inactive",
    "draft",
    "archived",
  ] as const satisfies readonly DbEnums["template_status"]),
  type: z.enum([
    "project",
    "task",
    "workflow",
    "document",
    "email",
    "other",
  ] as const satisfies readonly DbEnums["template_type"]),

  // Optional fields with validation
  id: z.string().uuid("Invalid UUID format").optional(),
  description: z.string().nullable(),
  version: z.string().nullable(),
  category: z.string().nullable(),
  owner_id: z.string().uuid("Invalid owner ID").nullable(),
  team_id: z.string().uuid("Invalid team ID").nullable(),
  parent_template_id: z.string().uuid("Invalid parent template ID").nullable(),
  estimated_duration: z.number().min(0).nullable(),
  priority: z
    .enum([
      "low",
      "medium",
      "high",
      "urgent",
    ] as const satisfies readonly DbEnums["priority_level"])
    .nullable(),
  notes: z.string().nullable(),
  attachments: z.array(z.string().url("Invalid attachment URL")).nullable(),
  last_updated: dateSchema,
  created_at: dateSchema,
  updated_at: dateSchema,

  // JSON fields
  task_templates: z.array(taskTemplateSchema).nullable(),
  workflow_templates: z.array(workflowTemplateSchema).nullable(),
  custom_fields: customFieldsSchema,
});

// Export types
export type TemplateFormSchema = z.infer<typeof templateFormSchema>;

// Validation helpers
export function validateTemplateForm(
  data: unknown,
):
  | { success: true; data: TemplateFormSchema }
  | { success: false; error: z.ZodError } {
  const result = templateFormSchema.safeParse(data);
  return result;
}

export function validateTaskTemplates(data: unknown) {
  return z.array(taskTemplateSchema).safeParse(data);
}

export function validateWorkflowTemplates(data: unknown) {
  return z.array(workflowTemplateSchema).safeParse(data);
}

export function validateCustomFields(data: unknown) {
  return customFieldsSchema.safeParse(data);
}

// Helper function to ensure all required fields are present
export function ensureRequiredFields(
  data: Partial<TemplateFormSchema>,
):
  | { success: true; data: TemplateFormSchema }
  | { success: false; error: string[] } {
  const requiredFields = ["name", "status", "type"] as const;
  const missingFields = requiredFields.filter((field) => !data[field]);

  if (missingFields.length > 0) {
    return {
      success: false,
      error: missingFields.map((field) => `Missing required field: ${field}`),
    };
  }

  return {
    success: true,
    data: data as TemplateFormSchema,
  };
}
```

### `src\lib\validations\user.ts`

```ts
import { z } from "zod";
import type { Database } from "@/types/database.types";

type DbEnums = Database["public"]["Enums"];

// Helper schemas
const dateSchema = z
  .string()
  .regex(/^\d{4}-\d{2}-\d{2}$/, "Invalid date format (YYYY-MM-DD)")
  .nullable();

const emailSchema = z.string().email("Invalid email address").nullable();

const phoneSchema = z
  .string()
  .regex(/^\+?[\d\s-()]+$/, "Invalid phone number format")
  .nullable();

// Define JSON field schemas
const profileSchema = z
  .object({
    bio: z.string().nullable(),
    avatar_url: z.string().url("Invalid avatar URL").nullable(),
    timezone: z.string().nullable(),
    language: z.string().nullable(),
    theme: z.enum(["light", "dark", "system"]).nullable(),
    notification_preferences: z
      .object({
        email: z.boolean().nullable(),
        push: z.boolean().nullable(),
        sms: z.boolean().nullable(),
      })
      .nullable(),
    social_links: z
      .object({
        linkedin: z.string().url("Invalid LinkedIn URL").nullable(),
        twitter: z.string().url("Invalid Twitter URL").nullable(),
        github: z.string().url("Invalid GitHub URL").nullable(),
      })
      .nullable(),
  })
  .nullable();

const settingsSchema = z
  .object({
    email_notifications: z.boolean().nullable(),
    push_notifications: z.boolean().nullable(),
    sms_notifications: z.boolean().nullable(),
    two_factor_enabled: z.boolean().nullable(),
    default_view: z.enum(["list", "board", "calendar", "timeline"]).nullable(),
    default_project_view: z
      .enum(["list", "board", "calendar", "timeline"])
      .nullable(),
    default_task_view: z
      .enum(["list", "board", "calendar", "timeline"])
      .nullable(),
    default_client_view: z
      .enum(["list", "board", "calendar", "timeline"])
      .nullable(),
    theme: z.enum(["light", "dark", "system"]).nullable(),
    timezone: z.string().nullable(),
    language: z.string().nullable(),
    date_format: z.string().nullable(),
    time_format: z.string().nullable(),
    currency: z
      .string()
      .length(3, "Currency code must be 3 letters")
      .nullable(),
  })
  .nullable();

const customFieldsSchema = z.record(z.string(), z.unknown()).nullable();

// Main user form schema
export const userFormSchema = z.object({
  // Required fields
  email: z.string().email("Invalid email address"),
  role: z.enum([
    "admin",
    "manager",
    "preparer",
    "reviewer",
    "client",
  ] as const satisfies readonly DbEnums["user_role"]),
  status: z.enum([
    "active",
    "inactive",
    "pending",
    "archived",
  ] as const satisfies readonly DbEnums["user_status"]),

  // Optional fields with validation
  id: z.string().uuid("Invalid UUID format").optional(),
  full_name: z.string().min(1, "Full name is required").nullable(),
  first_name: z.string().nullable(),
  last_name: z.string().nullable(),
  phone: phoneSchema,
  alternate_email: emailSchema,
  alternate_phone: phoneSchema,
  title: z.string().nullable(),
  department: z.string().nullable(),
  manager_id: z.string().uuid("Invalid manager ID").nullable(),
  team_id: z.string().uuid("Invalid team ID").nullable(),
  permissions: z.array(z.string()).nullable(),
  last_login: dateSchema,
  last_active: dateSchema,
  created_at: dateSchema,
  updated_at: dateSchema,

  // JSON fields
  profile: profileSchema,
  settings: settingsSchema,
  custom_fields: customFieldsSchema,
});

// Export types
export type UserFormSchema = z.infer<typeof userFormSchema>;

// Validation helpers
export function validateUserForm(
  data: unknown,
):
  | { success: true; data: UserFormSchema }
  | { success: false; error: z.ZodError } {
  const result = userFormSchema.safeParse(data);
  return result;
}

export function validateProfile(data: unknown) {
  return profileSchema.safeParse(data);
}

export function validateSettings(data: unknown) {
  return settingsSchema.safeParse(data);
}

export function validateCustomFields(data: unknown) {
  return customFieldsSchema.safeParse(data);
}

// Helper function to ensure all required fields are present
export function ensureRequiredFields(
  data: Partial<UserFormSchema>,
):
  | { success: true; data: UserFormSchema }
  | { success: false; error: string[] } {
  const requiredFields = ["email", "role", "status"] as const;
  const missingFields = requiredFields.filter((field) => !data[field]);

  if (missingFields.length > 0) {
    return {
      success: false,
      error: missingFields.map((field) => `Missing required field: ${field}`),
    };
  }

  return {
    success: true,
    data: data as UserFormSchema,
  };
}
```

### `src\lib\validations\utils.ts`

```ts
import { z } from "zod";
import { clientSchema, projectSchema, taskSchema } from "./schema";

// Type inference helpers
export type InferredClient = z.infer<typeof clientSchema>;
export type InferredProject = z.infer<typeof projectSchema>;
export type InferredTask = z.infer<typeof taskSchema>;

// Validation helpers
export const validateClient = (data: unknown) => {
  return clientSchema.parse(data);
};

export const validateProject = (data: unknown) => {
  return projectSchema.parse(data);
};

export const validateTask = (data: unknown) => {
  return taskSchema.parse(data);
};

// Safe parsers that return Result type
export const safeParseClient = (data: unknown) => {
  return clientSchema.safeParse(data);
};

export const safeParseProject = (data: unknown) => {
  return projectSchema.safeParse(data);
};

export const safeParseTask = (data: unknown) => {
  return taskSchema.safeParse(data);
};

// Partial validators for updates
export const validatePartialClient = (data: unknown) => {
  return clientSchema.partial().parse(data);
};

export const validatePartialProject = (data: unknown) => {
  return projectSchema.partial().parse(data);
};

export const validatePartialTask = (data: unknown) => {
  return taskSchema.partial().parse(data);
};

// Type guards
export const isClient = (data: unknown): data is InferredClient => {
  return clientSchema.safeParse(data).success;
};

export const isProject = (data: unknown): data is InferredProject => {
  return projectSchema.safeParse(data).success;
};

export const isTask = (data: unknown): data is InferredTask => {
  return taskSchema.safeParse(data).success;
};

// Error formatting
export const formatZodError = (error: z.ZodError) => {
  return error.errors.map((err) => ({
    path: err.path.join("."),
    message: err.message,
  }));
};

// Validation with custom error messages
export const validateWithCustomErrors = <T>(
  schema: z.ZodSchema<T>,
  data: unknown,
  customErrors?: Record<string, string>,
) => {
  try {
    return { success: true, data: schema.parse(data) };
  } catch (error) {
    if (error instanceof z.ZodError) {
      const formattedErrors = error.errors.map((err) => ({
        path: err.path.join("."),
        message: customErrors?.[err.path.join(".")] || err.message,
      }));
      return { success: false, errors: formattedErrors };
    }
    throw error;
  }
};
```

### `src\lib\validations\workflow.ts`

```ts
import { z } from "zod";
import type { Database } from "@/types/database.types";

type DbEnums = Database["public"]["Enums"];

// Helper schemas
const dateSchema = z
  .string()
  .regex(/^\d{4}-\d{2}-\d{2}$/, "Invalid date format (YYYY-MM-DD)")
  .nullable();

// Define JSON field schemas
const stageSchema = z
  .object({
    id: z.string().uuid("Invalid UUID format"),
    name: z.string(),
    description: z.string().nullable(),
    order_index: z.number().min(0),
    required: z.boolean().nullable(),
    auto_assign: z.boolean().nullable(),
    assigned_to: z.string().uuid("Invalid UUID format").nullable(),
    estimated_duration: z.number().min(0).nullable(),
    checklist: z
      .array(
        z.object({
          title: z.string(),
          required: z.boolean().nullable(),
          description: z.string().nullable(),
        }),
      )
      .nullable(),
  })
  .nullable();

const triggerSchema = z
  .object({
    event: z.string(),
    condition: z.string().nullable(),
    action: z.string(),
    target: z.string().nullable(),
    parameters: z.record(z.string(), z.unknown()).nullable(),
    enabled: z.boolean().nullable(),
  })
  .nullable();

const customFieldsSchema = z.record(z.string(), z.unknown()).nullable();

// Main workflow form schema
export const workflowFormSchema = z.object({
  // Required fields
  name: z.string().min(1, "Workflow name is required"),
  status: z.enum([
    "active",
    "inactive",
    "draft",
    "archived",
  ] as const satisfies readonly DbEnums["workflow_status"]),
  type: z.enum([
    "tax_return",
    "audit",
    "advisory",
    "bookkeeping",
    "payroll",
    "other",
  ] as const satisfies readonly DbEnums["workflow_type"]),

  // Optional fields with validation
  id: z.string().uuid("Invalid UUID format").optional(),
  description: z.string().nullable(),
  version: z.string().nullable(),
  template_id: z.string().uuid("Invalid template ID").nullable(),
  project_id: z.string().uuid("Invalid project ID").nullable(),
  client_id: z.string().uuid("Invalid client ID").nullable(),
  owner_id: z.string().uuid("Invalid owner ID").nullable(),
  team_id: z.string().uuid("Invalid team ID").nullable(),
  start_date: dateSchema,
  end_date: dateSchema,
  due_date: dateSchema,
  completion_date: dateSchema,
  estimated_duration: z.number().min(0).nullable(),
  actual_duration: z.number().min(0).nullable(),
  progress: z.number().min(0).max(100).nullable(),
  priority: z
    .enum([
      "low",
      "medium",
      "high",
      "urgent",
    ] as const satisfies readonly DbEnums["priority_level"])
    .nullable(),
  notes: z.string().nullable(),
  attachments: z.array(z.string().url("Invalid attachment URL")).nullable(),
  last_updated: dateSchema,
  created_at: dateSchema,
  updated_at: dateSchema,

  // JSON fields
  stages: z.array(stageSchema).nullable(),
  triggers: z.array(triggerSchema).nullable(),
  custom_fields: customFieldsSchema,
});

// Export types
export type WorkflowFormSchema = z.infer<typeof workflowFormSchema>;

// Validation helpers
export function validateWorkflowForm(
  data: unknown,
):
  | { success: true; data: WorkflowFormSchema }
  | { success: false; error: z.ZodError } {
  const result = workflowFormSchema.safeParse(data);
  return result;
}

export function validateStages(data: unknown) {
  return z.array(stageSchema).safeParse(data);
}

export function validateTriggers(data: unknown) {
  return z.array(triggerSchema).safeParse(data);
}

export function validateCustomFields(data: unknown) {
  return customFieldsSchema.safeParse(data);
}

// Helper function to ensure all required fields are present
export function ensureRequiredFields(
  data: Partial<WorkflowFormSchema>,
):
  | { success: true; data: WorkflowFormSchema }
  | { success: false; error: string[] } {
  const requiredFields = ["name", "status", "type"] as const;
  const missingFields = requiredFields.filter((field) => !data[field]);

  if (missingFields.length > 0) {
    return {
      success: false,
      error: missingFields.map((field) => `Missing required field: ${field}`),
    };
  }

  return {
    success: true,
    data: data as WorkflowFormSchema,
  };
}
```

### `src\lib\validations\__tests__\project.test.ts`

```ts
import { describe, it, expect } from "vitest";
import { projectSchema } from "../project";
import { v4 as uuidv4 } from "uuid";

const validProject = {
  name: "Test Project",
  client_id: uuidv4(),
  parent_project_id: uuidv4(),
  primary_manager: uuidv4(),
  service_type: "tax_return",
  tax_info: {
    return_type: "1040",
    tax_year: "2023",
  },
};

describe("Project Schema Validation", () => {
  it("validates a valid project", () => {
    const result = projectSchema.safeParse(validProject);
    expect(result.success).toBe(true);
  });

  it("requires tax info for tax return service type", () => {
    const invalidProject = {
      ...validProject,
      tax_info: undefined,
    };
    const result = projectSchema.safeParse(invalidProject);
    expect(result.success).toBe(false);
    if (!result.success) {
      expect(result.error.issues).toEqual(
        expect.arrayContaining([
          expect.objectContaining({
            path: ["tax_info"],
            message: "Required",
          }),
        ]),
      );
    }
  });
});
```

### `src\management\documentManager.ts`

```ts
import { supabase } from "../lib/supabaseClient";

export async function updateDocumentStatus(
  documentId: string,
  newStatus: string,
) {
  const { data, error } = await supabase
    .from("documents")
    .update({ document_status: newStatus })
    .eq("id", documentId);

  if (error) {
    throw new Error(`Failed to update document status: ${error.message}`);
  }

  return data;
}
```

### `src\pages\ClientManagementPage.tsx`

```tsx
import React, { useState } from "react";
import { useClients } from "../hooks/useClients";

export default function ClientManagementPage() {
  const { clients, loading, error, createClient, updateClient, deleteClient } =
    useClients();
  const [newClientName, setNewClientName] = useState("");

  async function handleCreate() {
    if (newClientName.trim()) {
      await createClient({ name: newClientName });
      setNewClientName("");
    }
  }

  return (
    <div>
      <h1>Client Management</h1>
      {loading && <p>Loading...</p>}
      {error && <p style={{ color: "red" }}>{error}</p>}

      <div>
        <h2>Add New Client</h2>
        <input
          placeholder="Client Name"
          value={newClientName}
          onChange={(e) => setNewClientName(e.target.value)}
        />
        <button onClick={handleCreate}>Create Client</button>
      </div>

      <div>
        <h2>Existing Clients</h2>
        {clients.map((client) => (
          <div
            key={client.id}
            style={{
              border: "1px solid #ccc",
              margin: "6px 0",
              padding: "6px",
            }}
          >
            <strong>ID:</strong> {client.id} <br />
            <strong>Name:</strong> {client.name} <br />
            <button
              onClick={() =>
                updateClient(client.id, { name: client.name + " (Updated)" })
              }
            >
              Update
            </button>
            <button onClick={() => deleteClient(client.id)}>Delete</button>
          </div>
        ))}
      </div>
    </div>
  );
}
```

### `src\pages\DashboardHome.tsx`

```tsx
import React from "react";
import { useAuth } from "../hooks/useAuth";

export default function DashboardHome() {
  const { user } = useAuth();

  return (
    <div>
      <h1>Dashboard</h1>
      <p>Welcome, {user?.email || "User"}!</p>
      <ul>
        <li>
          <a href="/clients">Manage Clients</a>
        </li>
        <li>
          <a href="/documents">Document Center</a>
        </li>
        <li>
          <a href="/taxreturns">Tax Return Workspace</a>
        </li>
      </ul>
    </div>
  );
}
```

### `src\pages\DocumentCenterPage.tsx`

```tsx
import React, { useState, useEffect } from "react";
import { supabase } from "../lib/supabaseClient";
import { handleError } from "../lib/error-handler";
import { uploadFileToStorage } from "../lib/storage/storage";

type DocumentStatus = "uploaded" | "review" | "approved" | "rejected";

interface DocumentRecord {
  id: number;
  file_name: string;
  file_path: string;
  document_status: DocumentStatus;
}

export default function DocumentCenterPage() {
  const [documents, setDocuments] = useState<DocumentRecord[]>([]);
  const [uploading, setUploading] = useState(false);
  const [error, setError] = useState("");

  useEffect(() => {
    fetchDocuments();
  }, []);

  async function fetchDocuments() {
    try {
      const { data, error } = await supabase.from("documents").select("*");
      if (error) throw error;
      if (data) {
        setDocuments(data as DocumentRecord[]);
      }
    } catch (err: any) {
      setError(handleError(err).message);
    }
  }

  async function handleUpload(evt: React.ChangeEvent<HTMLInputElement>) {
    if (!evt.target.files) return;
    setUploading(true);

    try {
      const file = evt.target.files[0];
      // Use our custom storage service
      const storageResult = await uploadFileToStorage(file);
      if (!storageResult.filePath) throw new Error("Upload failed");

      // Insert record in 'documents' table
      const { error: docErr } = await supabase.from("documents").insert({
        file_name: file.name,
        file_path: storageResult.filePath,
        document_status: "uploaded",
      });
      if (docErr) throw docErr;

      await fetchDocuments();
    } catch (err: any) {
      setError(handleError(err).message);
    } finally {
      setUploading(false);
    }
  }

  return (
    <div>
      <h1>Document Center</h1>
      {error && <p style={{ color: "red" }}>{error}</p>}
      <div>
        <label>Upload Document: </label>
        <input type="file" onChange={handleUpload} disabled={uploading} />
      </div>

      <h2>Documents</h2>
      {documents.map((doc) => (
        <div
          key={doc.id}
          style={{
            border: "1px solid #ccc",
            margin: "6px 0",
            padding: "6px",
          }}
        >
          <p>File Name: {doc.file_name}</p>
          <p>File Path: {doc.file_path}</p>
          <p>Status: {doc.document_status}</p>
        </div>
      ))}
    </div>
  );
}
```

### `src\pages\LoginPage.tsx`

```tsx
import React, { useState } from "react";
import { supabaseBrowserClient } from "@/lib/supabaseBrowserClient";

export default function LoginPage() {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [error, setError] = useState("");

  const handleLogin = async (e: React.FormEvent) => {
    e.preventDefault();
    const { data, error } = await supabaseBrowserClient.auth.signInWithPassword(
      { email, password },
    );
    if (error) {
      setError(error.message);
    } else if (data?.user) {
      window.location.href = "/dashboard";
    }
  };

  return (
    <div>
      <h1>Login</h1>
      {error && <p style={{ color: "red" }}>{error}</p>}
      <form onSubmit={handleLogin}>
        <div>
          <label>Email</label>
          <input
            type="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            required
          />
        </div>
        <div>
          <label>Password</label>
          <input
            type="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            required
          />
        </div>
        <button type="submit">Log In</button>
      </form>
    </div>
  );
}
```

### `src\pages\PasswordResetPage.tsx`

```tsx
import React, { useState } from "react";
import { supabaseBrowserClient } from "@/lib/supabaseBrowserClient";

export default function PasswordResetPage() {
  const [email, setEmail] = useState("");
  const [message, setMessage] = useState("");
  const [error, setError] = useState("");

  const handleReset = async (e: React.FormEvent) => {
    e.preventDefault();
    const { error } = await supabaseBrowserClient.auth.resetPasswordForEmail(
      email,
      {
        redirectTo: `${window.location.origin}/auth/callback`,
      },
    );

    if (error) {
      setError(error.message);
    } else {
      setMessage("Check your email for the password reset link");
    }
  };

  return (
    <div>
      <h1>Reset Password</h1>
      {message && <p>{message}</p>}
      {error && <p>{error}</p>}
      <form onSubmit={handleReset}>
        <div>
          <label>Email</label>
          <input
            type="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            required
          />
        </div>
        <button type="submit">Send Reset Link</button>
      </form>
    </div>
  );
}
```

### `src\pages\RegisterPage.tsx`

```tsx
import React, { useState } from "react";
import { supabaseBrowserClient } from "@/lib/supabaseBrowserClient";

export default function RegisterPage() {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [confirm, setConfirm] = useState("");
  const [errorMsg, setErrorMsg] = useState("");
  const [successMsg, setSuccessMsg] = useState("");

  const handleRegister = async (evt: React.FormEvent) => {
    evt.preventDefault();
    if (password !== confirm) {
      setErrorMsg("Passwords do not match.");
      return;
    }
    const { data, error } = await supabaseBrowserClient.auth.signUp({
      email,
      password,
    });
    if (error) {
      setErrorMsg(error.message);
    } else if (data?.user) {
      setSuccessMsg(
        "Registration successful! Check your email for confirmation.",
      );
      setErrorMsg("");
    }
  };

  return (
    <div>
      <h1>Register</h1>
      {errorMsg && <p style={{ color: "red" }}>{errorMsg}</p>}
      {successMsg && <p style={{ color: "green" }}>{successMsg}</p>}
      <form onSubmit={handleRegister}>
        <div>
          <label>Email</label>
          <input
            type="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            required
          />
        </div>
        <div>
          <label>Password</label>
          <input
            type="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            required
          />
        </div>
        <div>
          <label>Confirm Password</label>
          <input
            type="password"
            value={confirm}
            onChange={(e) => setConfirm(e.target.value)}
            required
          />
        </div>
        <button type="submit">Sign Up</button>
      </form>
    </div>
  );
}
```

### `src\pages\TaxReturnWorkspacePage.tsx`

```tsx
import React, { useState } from "react";
import { useTaxReturns } from "../hooks/useTaxReturns";
import { handleError } from "../lib/error-handler";
import { createTaskForReturn } from "../lib/services/task.service";

export default function TaxReturnWorkspacePage() {
  const { taxReturns, loading, error, createReturn, updateReturnStatus } =
    useTaxReturns();
  const [newReturnName, setNewReturnName] = useState("");

  async function handleCreate() {
    try {
      if (!newReturnName.trim()) return;
      await createReturn({ name: newReturnName, status: "draft" });
      setNewReturnName("");
    } catch (err: any) {
      console.error(handleError(err).message);
    }
  }

  async function moveToQC(returnId: string) {
    try {
      await updateReturnStatus(returnId, "QC Check");
      // Example: create a QC task in the task service
      await createTaskForReturn(returnId, "QC Review Task");
    } catch (err: any) {
      console.error(handleError(err).message);
    }
  }

  return (
    <div>
      <h1>Tax Return Workspace</h1>
      {loading && <p>Loading Tax Returns...</p>}
      {error && <p style={{ color: "red" }}>{error}</p>}

      <div>
        <h2>Create New Return</h2>
        <input
          placeholder="Tax Return Name"
          value={newReturnName}
          onChange={(e) => setNewReturnName(e.target.value)}
        />
        <button onClick={handleCreate}>Create Return</button>
      </div>

      <div>
        <h2>Existing Returns</h2>
        {taxReturns.map((tr) => (
          <div
            key={tr.id}
            style={{
              border: "1px solid #ccc",
              margin: "6px 0",
              padding: "6px",
            }}
          >
            <p>Name: {tr.name}</p>
            <p>Status: {tr.status}</p>
            <button onClick={() => moveToQC(tr.id)}>Move to QC</button>
          </div>
        ))}
      </div>
    </div>
  );
}
```

### `src\providers\query-provider.tsx`

```tsx
"use client";

import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { ReactQueryDevtools } from "@tanstack/react-query-devtools";
import { useState, type ReactNode } from "react";

interface QueryProviderProps {
  children: ReactNode;
}

export function QueryProvider({ children }: QueryProviderProps) {
  const [queryClient] = useState(
    () =>
      new QueryClient({
        defaultOptions: {
          queries: {
            staleTime: 60 * 1000, // 1 minute
            retry: 1,
            refetchOnWindowFocus: false,
          },
        },
      }),
  );

  return (
    <QueryClientProvider client={queryClient}>
      {children}
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  );
}
```

### `src\providers\unified-auth-provider.tsx`

```tsx
"use client";

import React, { createContext, useContext, useEffect, useState } from "react";
import { Session, User } from "@supabase/supabase-js";
import { supabaseBrowserClient } from "@/lib/supabaseBrowserClient";
import {
  getAuthenticatedUser,
  validateUserSession,
  getUserRole,
  refreshUserSession,
} from "@/lib/supabase/auth";
import type { Database } from "@/types/database.types";

interface AuthContextProps {
  user: User | null;
  session: Session | null;
  loading: boolean;
  error: Error | null;
  signOut: () => Promise<void>;
  refreshSession: () => Promise<void>;
  hasRole: (role: string) => boolean;
  validateSession: () => Promise<boolean>;
}

const AuthContext = createContext<AuthContextProps | undefined>(undefined);

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  const [session, setSession] = useState<Session | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);
  const [userRole, setUserRole] = useState<string | null>(null);

  useEffect(() => {
    const initAuth = async () => {
      try {
        const {
          data: { session },
        } = await supabaseBrowserClient.auth.getSession();
        setSession(session);
        setUser(session?.user ?? null);
      } finally {
        setLoading(false);
      }
    };

    initAuth();

    const {
      data: { subscription },
    } = supabaseBrowserClient.auth.onAuthStateChange((_event, session) => {
      setSession(session);
      setUser(session?.user ?? null);
    });

    return () => {
      subscription.unsubscribe();
    };
  }, []);

  const signOut = async () => {
    try {
      const { error } = await supabaseBrowserClient.auth.signOut();
      if (error) throw error;
      setUser(null);
      setSession(null);
    } catch (error) {
      console.error("Error signing out:", error);
      throw error;
    }
  };

  const refreshSession = async () => {
    try {
      const session = await refreshUserSession();
      setSession(session);
      if (session?.user) {
        setUser(session.user);
        const role = await getUserRole(session.user);
        setUserRole(role);
      }
    } catch (error) {
      setError(error as Error);
      throw error;
    }
  };

  const hasRole = (role: string): boolean => {
    if (!userRole) return false;
    if (role === "admin") return userRole === "admin";
    if (role === "manager") return ["admin", "manager"].includes(userRole);
    return true;
  };

  const validateSession = async (): Promise<boolean> => {
    try {
      const isValid = await validateUserSession();
      if (!isValid) {
        setUser(null);
        setSession(null);
        setUserRole(null);
      }
      return isValid;
    } catch (error) {
      setError(error as Error);
      return false;
    }
  };

  const value = {
    user,
    session,
    loading,
    error,
    signOut,
    refreshSession,
    hasRole,
    validateSession,
  };

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
}

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error("useAuth must be used within an AuthProvider");
  }
  return context;
};
```

### `src\styles\globals.css`

```css
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;

    --muted: 210 40% 96.1%;
    --muted-foreground: 215.4 16.3% 46.9%;

    --popover: 0 0% 100%;
    --popover-foreground: 222.2 84% 4.9%;

    --card: 0 0% 100%;
    --card-foreground: 222.2 84% 4.9%;

    --border: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;

    --primary: 222.2 47.4% 11.2%;
    --primary-foreground: 210 40% 98%;

    --secondary: 210 40% 96.1%;
    --secondary-foreground: 222.2 47.4% 11.2%;

    --accent: 210 40% 96.1%;
    --accent-foreground: 222.2 47.4% 11.2%;

    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%;

    --ring: 215 20.2% 65.1%;

    --radius: 0.5rem;
  }

  .dark {
    --background: 222.2 84% 4.9%;
    --foreground: 210 40% 98%;

    --muted: 217.2 32.6% 17.5%;
    --muted-foreground: 215 20.2% 65.1%;

    --popover: 222.2 84% 4.9%;
    --popover-foreground: 210 40% 98%;

    --card: 222.2 84% 4.9%;
    --card-foreground: 210 40% 98%;

    --border: 217.2 32.6% 17.5%;
    --input: 217.2 32.6% 17.5%;

    --primary: 210 40% 98%;
    --primary-foreground: 222.2 47.4% 11.2%;

    --secondary: 217.2 32.6% 17.5%;
    --secondary-foreground: 210 40% 98%;

    --accent: 217.2 32.6% 17.5%;
    --accent-foreground: 210 40% 98%;

    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 85.7% 97.3%;

    --ring: 217.2 32.6% 17.5%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}
```

### `src\styles\high-contrast.css`

```css
/* High Contrast Theme */
[data-theme="high-contrast"] {
  /* Base colors */
  --background: #000000;
  --foreground: #ffffff;
  --muted: #1a1a1a;
  --muted-foreground: #ffffff;

  /* Primary colors */
  --primary: #ffff00;
  --primary-foreground: #000000;

  /* Secondary colors */
  --secondary: #00ffff;
  --secondary-foreground: #000000;

  /* Accent colors */
  --accent: #ff00ff;
  --accent-foreground: #000000;

  /* Border colors */
  --border: #ffffff;
  --input: #ffffff;
  --ring: #ffff00;

  /* Status colors */
  --destructive: #ff0000;
  --destructive-foreground: #ffffff;
  --success: #00ff00;
  --success-foreground: #000000;
  --warning: #ffff00;
  --warning-foreground: #000000;

  /* Focus styles */
  --focus-ring: 0 0 0 3px var(--ring);
  --focus-visible-ring: 0 0 0 3px var(--ring);

  /* Card styles */
  --card: #1a1a1a;
  --card-foreground: #ffffff;
  --card-border: #ffffff;

  /* Popover styles */
  --popover: #000000;
  --popover-foreground: #ffffff;

  /* Button styles */
  --btn-background: #ffffff;
  --btn-foreground: #000000;
  --btn-border: #ffffff;
  --btn-hover: #ffff00;
  --btn-hover-foreground: #000000;
  --btn-focus: #00ffff;
  --btn-focus-foreground: #000000;
  --btn-active: #ff00ff;
  --btn-active-foreground: #000000;
  --btn-disabled: #666666;
  --btn-disabled-foreground: #ffffff;
}

/* High contrast focus styles */
[data-theme="high-contrast"] *:focus-visible {
  outline: 3px solid var(--ring) !important;
  outline-offset: 2px !important;
}

/* High contrast button styles */
[data-theme="high-contrast"] .btn {
  border: 2px solid var(--btn-border);
}

[data-theme="high-contrast"] .btn:hover {
  background-color: var(--btn-hover);
  color: var(--btn-hover-foreground);
}

[data-theme="high-contrast"] .btn:focus {
  background-color: var(--btn-focus);
  color: var(--btn-focus-foreground);
}

[data-theme="high-contrast"] .btn:active {
  background-color: var(--btn-active);
  color: var(--btn-active-foreground);
}

[data-theme="high-contrast"] .btn:disabled {
  background-color: var(--btn-disabled);
  color: var(--btn-disabled-foreground);
  border-color: var(--btn-disabled);
}

/* High contrast form styles */
[data-theme="high-contrast"] input,
[data-theme="high-contrast"] textarea,
[data-theme="high-contrast"] select {
  border: 2px solid var(--border);
  background-color: var(--background);
  color: var(--foreground);
}

[data-theme="high-contrast"] input:focus,
[data-theme="high-contrast"] textarea:focus,
[data-theme="high-contrast"] select:focus {
  border-color: var(--ring);
  box-shadow: var(--focus-ring);
}

/* High contrast error states */
[data-theme="high-contrast"] .error {
  color: var(--destructive);
  border-color: var(--destructive);
}

/* High contrast success states */
[data-theme="high-contrast"] .success {
  color: var(--success);
  border-color: var(--success);
}

/* High contrast warning states */
[data-theme="high-contrast"] .warning {
  color: var(--warning);
  border-color: var(--warning);
}

/* High contrast badge styles */
[data-theme="high-contrast"] .badge {
  border: 2px solid var(--border);
}

/* High contrast dialog styles */
[data-theme="high-contrast"] .dialog {
  border: 2px solid var(--border);
  background-color: var(--background);
  color: var(--foreground);
}

/* High contrast tooltip styles */
[data-theme="high-contrast"] .tooltip {
  background-color: var(--foreground);
  color: var(--background);
  border: 2px solid var(--border);
}

/* High contrast link styles */
[data-theme="high-contrast"] a {
  color: var(--primary);
  text-decoration: underline;
}

[data-theme="high-contrast"] a:hover {
  color: var(--secondary);
}

[data-theme="high-contrast"] a:focus {
  color: var(--accent);
  outline: 3px solid var(--ring);
  outline-offset: 2px;
}

/* High contrast icon styles */
[data-theme="high-contrast"] .icon {
  color: var(--foreground);
}

/* High contrast loading states */
[data-theme="high-contrast"] .skeleton {
  background-color: var(--muted);
  border: 1px solid var(--border);
}

/* High contrast scrollbar styles */
[data-theme="high-contrast"] ::-webkit-scrollbar {
  width: 12px;
  height: 12px;
}

[data-theme="high-contrast"] ::-webkit-scrollbar-track {
  background: var(--background);
  border: 1px solid var(--border);
}

[data-theme="high-contrast"] ::-webkit-scrollbar-thumb {
  background: var(--foreground);
  border: 1px solid var(--border);
}

[data-theme="high-contrast"] ::-webkit-scrollbar-thumb:hover {
  background: var(--primary);
}
```

### `src\styles\theme.css`

```css
:root {
  --background: 0 0% 100%;
  --foreground: 222.2 47.4% 11.2%;
  --card: 0 0% 100%;
  --card-foreground: 222.2 47.4% 11.2%;
  --popover: 0 0% 100%;
  --popover-foreground: 222.2 47.4% 11.2%;
  --primary: 222.2 47.4% 11.2%;
  --primary-foreground: 210 40% 98%;
  --secondary: 210 40% 96.1%;
  --secondary-foreground: 222.2 47.4% 11.2%;
  --muted: 210 40% 98%;
  --muted-foreground: 215.4 16.3% 46.9%;
  --accent: 210 40% 96.1%;
  --accent-foreground: 222.2 47.4% 11.2%;
  --destructive: 0 84.2% 60.2%;
  --destructive-foreground: 210 40% 98%;
  --border: 214.3 31.8% 91.4%;
  --input: 214.3 31.8% 91.4%;
  --ring: 222.2 47.4% 11.2%;

  --radius: 8px;
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: 222.2 84% 4.9%;
    --foreground: 210 40% 98%;
    --card: 222.2 84% 4.9%;
    --card-foreground: 210 40% 98%;
    --popover: 222.2 84% 4.9%;
    --popover-foreground: 210 40% 98%;
    --primary: 210 40% 98%;
    --primary-foreground: 222.2 47.4% 11.2%;
    --secondary: 217.2 32.6% 17.5%;
    --secondary-foreground: 210 40% 98%;
    --muted: 217 32.2% 17.9%;
    --muted-foreground: 215 20.2% 65.1%;
    --accent: 217.2 32.6% 17.5%;
    --accent-foreground: 210 40% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 40% 98%;
    --border: 217.2 32.6% 17.5%;
    --input: 217.2 32.6% 17.5%;
    --ring: 212.7 26.8% 83.9%;
  }
}

body {
  min-height: 100vh;
  background-color: hsl(var(--background));
  color: hsl(var(--foreground));
  font-feature-settings:
    "rlig" 1,
    "calt" 1;
}
```

### `src\types\auth.ts`

```ts
import { Database } from "./database.types";

// Use database types for user role
export type UserRole = Database["public"]["Enums"]["user_role"];

// Use database types for user
export type User = {
  id: string;
  email: string;
  role: UserRole;
  full_name?: string | null;
  avatar_url?: string | null;
  created_at?: string | null;
  updated_at?: string | null;
};

// Strongly type the session
export type Session = {
  user: User;
  expires_at: number;
  access_token?: string;
  refresh_token?: string;
};

// Auth state with proper error typing
export type AuthState = {
  session: Session | null;
  loading: boolean;
  error: AuthError | null;
};

// Form data with validation
export type SignInFormData = {
  email: string;
  password: string;
};

export type SignUpFormData = {
  email: string;
  password: string;
  full_name: string;
  role: UserRole;
};

// Type guard for checking if user is authenticated
export function isAuthenticated(session: Session | null): session is Session {
  return (
    session !== null &&
    typeof session.user === "object" &&
    typeof session.user.id === "string" &&
    typeof session.user.email === "string" &&
    typeof session.expires_at === "number" &&
    session.expires_at > Date.now() / 1000
  );
}

// Type guard for checking user role
export function hasRole(user: User, role: UserRole): boolean {
  return user.role === role;
}

// Error types
export class AuthError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "AuthError";
  }
}

export class InvalidCredentialsError extends AuthError {
  constructor() {
    super("Invalid email or password");
    this.name = "InvalidCredentialsError";
  }
}

export class SessionExpiredError extends AuthError {
  constructor() {
    super("Session has expired");
    this.name = "SessionExpiredError";
  }
}

export class UnauthorizedError extends AuthError {
  constructor() {
    super("Unauthorized access");
    this.name = "UnauthorizedError";
  }
}

// Auth guard type
export type AuthGuard = {
  requireAuth: boolean;
  allowedRoles?: UserRole[];
};
```

### `src\types\clients.ts`

```ts
import type { Database } from "./database.types";
import type { Json } from "./database.types";
import { z } from "zod";
import { clientFormSchema } from "@/lib/validations/client";

// Database types
export type DbClient = Database["public"]["Tables"]["clients"]["Row"];
export type DbClientInsert = Database["public"]["Tables"]["clients"]["Insert"];
export type DbClientUpdate = Database["public"]["Tables"]["clients"]["Update"];
export type DbClientContactDetails =
  Database["public"]["Tables"]["client_contact_details"]["Row"];

// Enums from database
export type ClientStatus = Database["public"]["Enums"]["client_status"];
export type ClientType = Database["public"]["Enums"]["client_type"];
export type FilingType = Database["public"]["Enums"]["filing_type"];

export interface Dependent {
  name: string;
  ssn?: string | null;
  relationship?: string | null;
  birth_date?: string | null;
}

export interface PreviousReturn {
  year: number;
  filed_date: string;
  preparer?: string | null;
  notes?: string | null;
}

export interface TaxInfo {
  filing_status?: string | null;
  tax_id?: string | null;
  tax_year?: number | null;
  last_filed_date?: string | null;
  filing_type?: FilingType | null;
  tax_id_type?: "ssn" | "ein" | null;
  dependents?: Dependent[] | null;
  previous_returns?: PreviousReturn[] | null;
}

// Form data type that matches our schema
export type ClientFormData = z.infer<typeof clientFormSchema>;

// Enhanced client type with relationships
export interface ClientWithRelations extends Omit<DbClient, "tax_info"> {
  tax_info: TaxInfo | null;
  contact_details?: DbClientContactDetails | null;
  documents?: Database["public"]["Tables"]["client_documents"]["Row"][];
  workflows?: Database["public"]["Tables"]["client_onboarding_workflows"]["Row"][];
  assigned_preparer?: Database["public"]["Tables"]["users"]["Row"] | null;
  tax_returns?: Database["public"]["Tables"]["tax_returns"]["Row"][];
  projects?: Database["public"]["Tables"]["projects"]["Row"][];
}

export function isTaxInfo(value: unknown): value is TaxInfo {
  return (
    value !== null &&
    typeof value === "object" &&
    (!("filing_status" in value) ||
      typeof value.filing_status === "string" ||
      value.filing_status === null) &&
    (!("tax_id" in value) ||
      typeof value.tax_id === "string" ||
      value.tax_id === null) &&
    (!("tax_year" in value) ||
      typeof value.tax_year === "number" ||
      value.tax_year === null)
  );
}

export function isDbClient(client: unknown): client is DbClient {
  return (
    client !== null &&
    typeof client === "object" &&
    "id" in client &&
    "contact_email" in client &&
    "status" in client
  );
}

// Conversion utilities
export function toClientFormData(client: DbClient): ClientFormData {
  const { created_at, updated_at, ...formData } = client;

  const taxInfo = isTaxInfo(client.tax_info) ? client.tax_info : null;

  return {
    ...formData,
    tax_info: taxInfo,
  } as ClientFormData;
}

export function toDbClient(
  formData: ClientFormData,
): Omit<DbClientInsert, "id"> {
  const {
    id, // Exclude id as it's handled by the database
    tax_info,
    ...rest
  } = formData;

  // Ensure all required fields are present with defaults
  const dbClient: Omit<DbClientInsert, "id"> = {
    ...rest,
    contact_email: rest.contact_email,
    status: rest.status,
    tax_info: tax_info as Json,
    // Add any other required fields with defaults
    type: rest.type || null,
    accounting_method: rest.accounting_method || null,
    business_type: rest.business_type || null,
    company_name: rest.company_name || null,
    document_deadline: rest.document_deadline || null,
    fiscal_year_end: rest.fiscal_year_end || null,
    industry_code: rest.industry_code || null,
    last_contact_date: rest.last_contact_date || null,
    last_filed_date: rest.last_filed_date || null,
    next_appointment: rest.next_appointment || null,
    primary_contact_name: rest.primary_contact_name || null,
    tax_id: rest.tax_id || null,
    tax_return_status: rest.tax_return_status || null,
    user_id: rest.user_id || null,
    assigned_preparer_id: rest.assigned_preparer_id || null,
  };

  return dbClient;
}

// Constants
export const CLIENT_STATUS = {
  ACTIVE: "active",
  INACTIVE: "inactive",
  PENDING: "pending",
  ARCHIVED: "archived",
} as const satisfies Record<string, ClientStatus>;

export const CLIENT_TYPE = {
  BUSINESS: "business",
  INDIVIDUAL: "individual",
} as const satisfies Record<string, ClientType>;

// Helper functions for type checking
export function isValidClientStatus(status: string): status is ClientStatus {
  return Object.values(CLIENT_STATUS).includes(status as ClientStatus);
}

export function isValidClientType(type: string): type is ClientType {
  return Object.values(CLIENT_TYPE).includes(type as ClientType);
}

// Helper function for null safety
export function ensureNullable<T>(value: T | undefined): T | null {
  return value === undefined ? null : value;
}
```

### `src\types\database.types.ts`

```ts
export type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json | undefined }
  | Json[];

export type Database = {
  public: {
    Tables: {
      activity_log_entries: {
        Row: {
          action: string;
          created_at: string | null;
          details: Json | null;
          id: string;
          performed_by: string | null;
          task_id: string;
        };
        Insert: {
          action: string;
          created_at?: string | null;
          details?: Json | null;
          id?: string;
          performed_by?: string | null;
          task_id: string;
        };
        Update: {
          action?: string;
          created_at?: string | null;
          details?: Json | null;
          id?: string;
          performed_by?: string | null;
          task_id?: string;
        };
        Relationships: [
          {
            foreignKeyName: "activity_log_entries_performed_by_fkey";
            columns: ["performed_by"];
            isOneToOne: false;
            referencedRelation: "user_task_load";
            referencedColumns: ["user_id"];
          },
          {
            foreignKeyName: "activity_log_entries_performed_by_fkey";
            columns: ["performed_by"];
            isOneToOne: false;
            referencedRelation: "users";
            referencedColumns: ["id"];
          },
          {
            foreignKeyName: "activity_log_entries_task_id_fkey";
            columns: ["task_id"];
            isOneToOne: false;
            referencedRelation: "tasks";
            referencedColumns: ["id"];
          },
        ];
      };
      checklist_items: {
        Row: {
          completed: boolean;
          created_at: string | null;
          description: string | null;
          id: string;
          task_id: string;
          title: string;
          updated_at: string | null;
        };
        Insert: {
          completed?: boolean;
          created_at?: string | null;
          description?: string | null;
          id?: string;
          task_id: string;
          title: string;
          updated_at?: string | null;
        };
        Update: {
          completed?: boolean;
          created_at?: string | null;
          description?: string | null;
          id?: string;
          task_id?: string;
          title?: string;
          updated_at?: string | null;
        };
        Relationships: [
          {
            foreignKeyName: "checklist_items_task_id_fkey";
            columns: ["task_id"];
            isOneToOne: false;
            referencedRelation: "tasks";
            referencedColumns: ["id"];
          },
        ];
      };
      client_contact_details: {
        Row: {
          address: string | null;
          city: string | null;
          client_id: string;
          created_at: string | null;
          id: string;
          phone: string | null;
          state: string | null;
          updated_at: string | null;
          zip: string | null;
        };
        Insert: {
          address?: string | null;
          city?: string | null;
          client_id: string;
          created_at?: string | null;
          id?: string;
          phone?: string | null;
          state?: string | null;
          updated_at?: string | null;
          zip?: string | null;
        };
        Update: {
          address?: string | null;
          city?: string | null;
          client_id?: string;
          created_at?: string | null;
          id?: string;
          phone?: string | null;
          state?: string | null;
          updated_at?: string | null;
          zip?: string | null;
        };
        Relationships: [
          {
            foreignKeyName: "client_contact_details_client_id_fkey";
            columns: ["client_id"];
            isOneToOne: false;
            referencedRelation: "clients";
            referencedColumns: ["id"];
          },
        ];
      };
      client_documents: {
        Row: {
          client_id: string | null;
          created_at: string | null;
          document_name: string;
          document_type: string;
          id: string;
          reminder_sent: boolean | null;
          status: string;
          updated_at: string | null;
          uploaded_at: string | null;
        };
        Insert: {
          client_id?: string | null;
          created_at?: string | null;
          document_name: string;
          document_type: string;
          id?: string;
          reminder_sent?: boolean | null;
          status: string;
          updated_at?: string | null;
          uploaded_at?: string | null;
        };
        Update: {
          client_id?: string | null;
          created_at?: string | null;
          document_name?: string;
          document_type?: string;
          id?: string;
          reminder_sent?: boolean | null;
          status?: string;
          updated_at?: string | null;
          uploaded_at?: string | null;
        };
        Relationships: [];
      };
      client_onboarding_workflows: {
        Row: {
          client_id: string | null;
          created_at: string | null;
          id: string;
          progress: string | null;
          status: string;
          updated_at: string | null;
        };
        Insert: {
          client_id?: string | null;
          created_at?: string | null;
          id?: string;
          progress?: string | null;
          status: string;
          updated_at?: string | null;
        };
        Update: {
          client_id?: string | null;
          created_at?: string | null;
          id?: string;
          progress?: string | null;
          status?: string;
          updated_at?: string | null;
        };
        Relationships: [];
      };
      clients: {
        Row: {
          accounting_method: string | null;
          active_services: Database["public"]["Enums"]["service_type"][] | null;
          address: string | null;
          assigned_preparer_id: string | null;
          business_tax_id: string | null;
          business_type: string | null;
          city: string | null;
          company_name: string | null;
          contact_email: string;
          contact_info: Json | null;
          created_at: string | null;
          document_deadline: string | null;
          document_requirements: Json | null;
          ein: string | null;
          email: string | null;
          filing_status: string | null;
          fiscal_year_end: string | null;
          fts_search: unknown | null;
          full_name: string | null;
          id: string;
          individual_tax_id: string | null;
          industry_code: string | null;
          last_contact_date: string | null;
          last_filed_date: string | null;
          next_appointment: string | null;
          notes: string | null;
          onboarding_notes: string | null;
          onboarding_progress: Json | null;
          owner_id: string | null;
          phone: string | null;
          primary_contact_name: string | null;
          service_config: Json | null;
          service_history: Json | null;
          state: string | null;
          status: Database["public"]["Enums"]["client_status"];
          tax_id: string | null;
          tax_info: Json;
          tax_return_status: string | null;
          tax_year: number | null;
          type: Database["public"]["Enums"]["client_type"] | null;
          updated_at: string | null;
          user_id: string | null;
          zip: string | null;
        };
        Insert: {
          accounting_method?: string | null;
          active_services?:
            | Database["public"]["Enums"]["service_type"][]
            | null;
          address?: string | null;
          assigned_preparer_id?: string | null;
          business_tax_id?: string | null;
          business_type?: string | null;
          city?: string | null;
          company_name?: string | null;
          contact_email: string;
          contact_info?: Json | null;
          created_at?: string | null;
          document_deadline?: string | null;
          document_requirements?: Json | null;
          ein?: string | null;
          email?: string | null;
          filing_status?: string | null;
          fiscal_year_end?: string | null;
          fts_search?: unknown | null;
          full_name?: string | null;
          id: string;
          individual_tax_id?: string | null;
          industry_code?: string | null;
          last_contact_date?: string | null;
          last_filed_date?: string | null;
          next_appointment?: string | null;
          notes?: string | null;
          onboarding_notes?: string | null;
          onboarding_progress?: Json | null;
          owner_id?: string | null;
          phone?: string | null;
          primary_contact_name?: string | null;
          service_config?: Json | null;
          service_history?: Json | null;
          state?: string | null;
          status: Database["public"]["Enums"]["client_status"];
          tax_id?: string | null;
          tax_info?: Json;
          tax_return_status?: string | null;
          tax_year?: number | null;
          type?: Database["public"]["Enums"]["client_type"] | null;
          updated_at?: string | null;
          user_id?: string | null;
          zip?: string | null;
        };
        Update: {
          accounting_method?: string | null;
          active_services?:
            | Database["public"]["Enums"]["service_type"][]
            | null;
          address?: string | null;
          assigned_preparer_id?: string | null;
          business_tax_id?: string | null;
          business_type?: string | null;
          city?: string | null;
          company_name?: string | null;
          contact_email?: string;
          contact_info?: Json | null;
          created_at?: string | null;
          document_deadline?: string | null;
          document_requirements?: Json | null;
          ein?: string | null;
          email?: string | null;
          filing_status?: string | null;
          fiscal_year_end?: string | null;
          fts_search?: unknown | null;
          full_name?: string | null;
          id?: string;
          individual_tax_id?: string | null;
          industry_code?: string | null;
          last_contact_date?: string | null;
          last_filed_date?: string | null;
          next_appointment?: string | null;
          notes?: string | null;
          onboarding_notes?: string | null;
          onboarding_progress?: Json | null;
          owner_id?: string | null;
          phone?: string | null;
          primary_contact_name?: string | null;
          service_config?: Json | null;
          service_history?: Json | null;
          state?: string | null;
          status?: Database["public"]["Enums"]["client_status"];
          tax_id?: string | null;
          tax_info?: Json;
          tax_return_status?: string | null;
          tax_year?: number | null;
          type?: Database["public"]["Enums"]["client_type"] | null;
          updated_at?: string | null;
          user_id?: string | null;
          zip?: string | null;
        };
        Relationships: [];
      };
      document_templates: {
        Row: {
          business_types: Database["public"]["Enums"]["business_type"][] | null;
          category: Database["public"]["Enums"]["document_category"];
          created_at: string | null;
          id: string;
          name: string;
          required_for: Database["public"]["Enums"]["service_type"][] | null;
          updated_at: string | null;
          validation_rules: Json | null;
        };
        Insert: {
          business_types?:
            | Database["public"]["Enums"]["business_type"][]
            | null;
          category: Database["public"]["Enums"]["document_category"];
          created_at?: string | null;
          id?: string;
          name: string;
          required_for?: Database["public"]["Enums"]["service_type"][] | null;
          updated_at?: string | null;
          validation_rules?: Json | null;
        };
        Update: {
          business_types?:
            | Database["public"]["Enums"]["business_type"][]
            | null;
          category?: Database["public"]["Enums"]["document_category"];
          created_at?: string | null;
          id?: string;
          name?: string;
          required_for?: Database["public"]["Enums"]["service_type"][] | null;
          updated_at?: string | null;
          validation_rules?: Json | null;
        };
        Relationships: [];
      };
      document_tracking: {
        Row: {
          document_name: string | null;
          due_date: string | null;
          id: string;
          project_id: string | null;
          reminder_sent: boolean | null;
          status: string | null;
        };
        Insert: {
          document_name?: string | null;
          due_date?: string | null;
          id: string;
          project_id?: string | null;
          reminder_sent?: boolean | null;
          status?: string | null;
        };
        Update: {
          document_name?: string | null;
          due_date?: string | null;
          id?: string;
          project_id?: string | null;
          reminder_sent?: boolean | null;
          status?: string | null;
        };
        Relationships: [
          {
            foreignKeyName: "document_tracking_project_id_fkey";
            columns: ["project_id"];
            isOneToOne: false;
            referencedRelation: "project_dashboard";
            referencedColumns: ["id"];
          },
          {
            foreignKeyName: "document_tracking_project_id_fkey";
            columns: ["project_id"];
            isOneToOne: false;
            referencedRelation: "project_progress";
            referencedColumns: ["project_id"];
          },
          {
            foreignKeyName: "document_tracking_project_id_fkey";
            columns: ["project_id"];
            isOneToOne: false;
            referencedRelation: "projects";
            referencedColumns: ["id"];
          },
        ];
      };
      documents: {
        Row: {
          category: Database["public"]["Enums"]["document_category"];
          client_id: string | null;
          document_timeline: Json | null;
          extracted_data: Json | null;
          file_name: string;
          file_path: string;
          id: string;
          metadata: Json | null;
          processing_status: string | null;
          project_id: string | null;
          related_documents: string[] | null;
          tax_year: number | null;
          uploaded_at: string | null;
          uploaded_by: string | null;
          verification_status: string | null;
        };
        Insert: {
          category: Database["public"]["Enums"]["document_category"];
          client_id?: string | null;
          document_timeline?: Json | null;
          extracted_data?: Json | null;
          file_name: string;
          file_path: string;
          id?: string;
          metadata?: Json | null;
          processing_status?: string | null;
          project_id?: string | null;
          related_documents?: string[] | null;
          tax_year?: number | null;
          uploaded_at?: string | null;
          uploaded_by?: string | null;
          verification_status?: string | null;
        };
        Update: {
          category?: Database["public"]["Enums"]["document_category"];
          client_id?: string | null;
          document_timeline?: Json | null;
          extracted_data?: Json | null;
          file_name?: string;
          file_path?: string;
          id?: string;
          metadata?: Json | null;
          processing_status?: string | null;
          project_id?: string | null;
          related_documents?: string[] | null;
          tax_year?: number | null;
          uploaded_at?: string | null;
          uploaded_by?: string | null;
          verification_status?: string | null;
        };
        Relationships: [
          {
            foreignKeyName: "documents_client_id_fkey";
            columns: ["client_id"];
            isOneToOne: false;
            referencedRelation: "clients";
            referencedColumns: ["id"];
          },
          {
            foreignKeyName: "documents_project_id_fkey";
            columns: ["project_id"];
            isOneToOne: false;
            referencedRelation: "project_dashboard";
            referencedColumns: ["id"];
          },
          {
            foreignKeyName: "documents_project_id_fkey";
            columns: ["project_id"];
            isOneToOne: false;
            referencedRelation: "project_progress";
            referencedColumns: ["project_id"];
          },
          {
            foreignKeyName: "documents_project_id_fkey";
            columns: ["project_id"];
            isOneToOne: false;
            referencedRelation: "projects";
            referencedColumns: ["id"];
          },
        ];
      };
      individuals: {
        Row: {
          created_at: string | null;
          email: string;
          full_name: string;
          id: string;
          tax_id: string;
          updated_at: string | null;
        };
        Insert: {
          created_at?: string | null;
          email: string;
          full_name: string;
          id?: string;
          tax_id: string;
          updated_at?: string | null;
        };
        Update: {
          created_at?: string | null;
          email?: string;
          full_name?: string;
          id?: string;
          tax_id?: string;
          updated_at?: string | null;
        };
        Relationships: [];
      };
      notes: {
        Row: {
          client_id: string | null;
          content: string;
          created_at: string | null;
          id: string;
          project_id: string | null;
          updated_at: string | null;
          user_id: string | null;
        };
        Insert: {
          client_id?: string | null;
          content: string;
          created_at?: string | null;
          id?: string;
          project_id?: string | null;
          updated_at?: string | null;
          user_id?: string | null;
        };
        Update: {
          client_id?: string | null;
          content?: string;
          created_at?: string | null;
          id?: string;
          project_id?: string | null;
          updated_at?: string | null;
          user_id?: string | null;
        };
        Relationships: [
          {
            foreignKeyName: "notes_project_id_fkey";
            columns: ["project_id"];
            isOneToOne: false;
            referencedRelation: "project_dashboard";
            referencedColumns: ["id"];
          },
          {
            foreignKeyName: "notes_project_id_fkey";
            columns: ["project_id"];
            isOneToOne: false;
            referencedRelation: "project_progress";
            referencedColumns: ["project_id"];
          },
          {
            foreignKeyName: "notes_project_id_fkey";
            columns: ["project_id"];
            isOneToOne: false;
            referencedRelation: "projects";
            referencedColumns: ["id"];
          },
        ];
      };
      notifications: {
        Row: {
          created_at: string | null;
          id: string;
          message: string;
          sent_at: string | null;
          status: string;
          updated_at: string | null;
          user_id: string | null;
        };
        Insert: {
          created_at?: string | null;
          id?: string;
          message: string;
          sent_at?: string | null;
          status: string;
          updated_at?: string | null;
          user_id?: string | null;
        };
        Update: {
          created_at?: string | null;
          id?: string;
          message?: string;
          sent_at?: string | null;
          status?: string;
          updated_at?: string | null;
          user_id?: string | null;
        };
        Relationships: [];
      };
      owners: {
        Row: {
          client_id: string | null;
          created_at: string | null;
          id: string;
          individual_id: string | null;
          ownership_percentage: number | null;
          updated_at: string | null;
        };
        Insert: {
          client_id?: string | null;
          created_at?: string | null;
          id?: string;
          individual_id?: string | null;
          ownership_percentage?: number | null;
          updated_at?: string | null;
        };
        Update: {
          client_id?: string | null;
          created_at?: string | null;
          id?: string;
          individual_id?: string | null;
          ownership_percentage?: number | null;
          updated_at?: string | null;
        };
        Relationships: [
          {
            foreignKeyName: "owners_individual_id_fkey";
            columns: ["individual_id"];
            isOneToOne: false;
            referencedRelation: "individuals";
            referencedColumns: ["id"];
          },
        ];
      };
      payroll_services: {
        Row: {
          client_id: string | null;
          created_at: string | null;
          frequency: string;
          id: string;
          last_processed_date: string | null;
          next_due_date: string | null;
          progress: string | null;
          service_name: string;
          updated_at: string | null;
        };
        Insert: {
          client_id?: string | null;
          created_at?: string | null;
          frequency: string;
          id?: string;
          last_processed_date?: string | null;
          next_due_date?: string | null;
          progress?: string | null;
          service_name: string;
          updated_at?: string | null;
        };
        Update: {
          client_id?: string | null;
          created_at?: string | null;
          frequency?: string;
          id?: string;
          last_processed_date?: string | null;
          next_due_date?: string | null;
          progress?: string | null;
          service_name?: string;
          updated_at?: string | null;
        };
        Relationships: [];
      };
      profiles: {
        Row: {
          avatar_url: string | null;
          created_at: string | null;
          email: string | null;
          full_name: string | null;
          id: string;
          role: string | null;
          updated_at: string | null;
        };
        Insert: {
          avatar_url?: string | null;
          created_at?: string | null;
          email?: string | null;
          full_name?: string | null;
          id: string;
          role?: string | null;
          updated_at?: string | null;
        };
        Update: {
          avatar_url?: string | null;
          created_at?: string | null;
          email?: string | null;
          full_name?: string | null;
          id?: string;
          role?: string | null;
          updated_at?: string | null;
        };
        Relationships: [];
      };
      project_team_members: {
        Row: {
          created_at: string | null;
          id: string;
          project_id: string | null;
          role: string | null;
          updated_at: string | null;
          user_id: string | null;
        };
        Insert: {
          created_at?: string | null;
          id?: string;
          project_id?: string | null;
          role?: string | null;
          updated_at?: string | null;
          user_id?: string | null;
        };
        Update: {
          created_at?: string | null;
          id?: string;
          project_id?: string | null;
          role?: string | null;
          updated_at?: string | null;
          user_id?: string | null;
        };
        Relationships: [
          {
            foreignKeyName: "project_team_members_project_id_fkey";
            columns: ["project_id"];
            isOneToOne: false;
            referencedRelation: "project_dashboard";
            referencedColumns: ["id"];
          },
          {
            foreignKeyName: "project_team_members_project_id_fkey";
            columns: ["project_id"];
            isOneToOne: false;
            referencedRelation: "project_progress";
            referencedColumns: ["project_id"];
          },
          {
            foreignKeyName: "project_team_members_project_id_fkey";
            columns: ["project_id"];
            isOneToOne: false;
            referencedRelation: "projects";
            referencedColumns: ["id"];
          },
          {
            foreignKeyName: "project_team_members_user_id_fkey";
            columns: ["user_id"];
            isOneToOne: false;
            referencedRelation: "user_task_load";
            referencedColumns: ["user_id"];
          },
          {
            foreignKeyName: "project_team_members_user_id_fkey";
            columns: ["user_id"];
            isOneToOne: false;
            referencedRelation: "users";
            referencedColumns: ["id"];
          },
        ];
      };
      project_templates: {
        Row: {
          category: string;
          category_id: string | null;
          created_at: string | null;
          default_priority: string | null;
          description: string | null;
          id: string;
          project_defaults: Json | null;
          recurring_schedule: string | null;
          seasonal_priority: Json | null;
          title: string;
          updated_at: string | null;
        };
        Insert: {
          category: string;
          category_id?: string | null;
          created_at?: string | null;
          default_priority?: string | null;
          description?: string | null;
          id?: string;
          project_defaults?: Json | null;
          recurring_schedule?: string | null;
          seasonal_priority?: Json | null;
          title: string;
          updated_at?: string | null;
        };
        Update: {
          category?: string;
          category_id?: string | null;
          created_at?: string | null;
          default_priority?: string | null;
          description?: string | null;
          id?: string;
          project_defaults?: Json | null;
          recurring_schedule?: string | null;
          seasonal_priority?: Json | null;
          title?: string;
          updated_at?: string | null;
        };
        Relationships: [
          {
            foreignKeyName: "project_templates_category_id_fkey";
            columns: ["category_id"];
            isOneToOne: false;
            referencedRelation: "template_categories";
            referencedColumns: ["id"];
          },
        ];
      };
      projects: {
        Row: {
          accounting_info: Json | null;
          automation_config: Json | null;
          client_id: string | null;
          completed_tasks: number | null;
          completion_percentage: number | null;
          created_at: string | null;
          deadline: string | null;
          description: string | null;
          due_date: string | null;
          end_date: string | null;
          id: string;
          name: string;
          owner_id: string | null;
          parent_project_id: string | null;
          payroll_info: Json | null;
          primary_manager: string | null;
          priority: string;
          service_info: Json | null;
          service_type: string | null;
          stage: string | null;
          start_date: string | null;
          status: Database["public"]["Enums"]["project_status"];
          status_history: Json | null;
          task_count: number | null;
          tax_info: Json | null;
          tax_return_id: string | null;
          team_members: string[] | null;
          template_data: Json | null;
          template_id: string | null;
          updated_at: string | null;
          workflow_state: Json | null;
        };
        Insert: {
          accounting_info?: Json | null;
          automation_config?: Json | null;
          client_id?: string | null;
          completed_tasks?: number | null;
          completion_percentage?: number | null;
          created_at?: string | null;
          deadline?: string | null;
          description?: string | null;
          due_date?: string | null;
          end_date?: string | null;
          id?: string;
          name: string;
          owner_id?: string | null;
          parent_project_id?: string | null;
          payroll_info?: Json | null;
          primary_manager?: string | null;
          priority?: string;
          service_info?: Json | null;
          service_type?: string | null;
          stage?: string | null;
          start_date?: string | null;
          status: Database["public"]["Enums"]["project_status"];
          status_history?: Json | null;
          task_count?: number | null;
          tax_info?: Json | null;
          tax_return_id?: string | null;
          team_members?: string[] | null;
          template_data?: Json | null;
          template_id?: string | null;
          updated_at?: string | null;
          workflow_state?: Json | null;
        };
        Update: {
          accounting_info?: Json | null;
          automation_config?: Json | null;
          client_id?: string | null;
          completed_tasks?: number | null;
          completion_percentage?: number | null;
          created_at?: string | null;
          deadline?: string | null;
          description?: string | null;
          due_date?: string | null;
          end_date?: string | null;
          id?: string;
          name?: string;
          owner_id?: string | null;
          parent_project_id?: string | null;
          payroll_info?: Json | null;
          primary_manager?: string | null;
          priority?: string;
          service_info?: Json | null;
          service_type?: string | null;
          stage?: string | null;
          start_date?: string | null;
          status?: Database["public"]["Enums"]["project_status"];
          status_history?: Json | null;
          task_count?: number | null;
          tax_info?: Json | null;
          tax_return_id?: string | null;
          team_members?: string[] | null;
          template_data?: Json | null;
          template_id?: string | null;
          updated_at?: string | null;
          workflow_state?: Json | null;
        };
        Relationships: [
          {
            foreignKeyName: "fk_projects_tax_return";
            columns: ["tax_return_id"];
            isOneToOne: false;
            referencedRelation: "tax_returns";
            referencedColumns: ["id"];
          },
          {
            foreignKeyName: "projects_client_id_fkey";
            columns: ["client_id"];
            isOneToOne: false;
            referencedRelation: "clients";
            referencedColumns: ["id"];
          },
          {
            foreignKeyName: "projects_parent_project_id_fkey";
            columns: ["parent_project_id"];
            isOneToOne: false;
            referencedRelation: "project_dashboard";
            referencedColumns: ["id"];
          },
          {
            foreignKeyName: "projects_parent_project_id_fkey";
            columns: ["parent_project_id"];
            isOneToOne: false;
            referencedRelation: "project_progress";
            referencedColumns: ["project_id"];
          },
          {
            foreignKeyName: "projects_parent_project_id_fkey";
            columns: ["parent_project_id"];
            isOneToOne: false;
            referencedRelation: "projects";
            referencedColumns: ["id"];
          },
          {
            foreignKeyName: "projects_primary_manager_fkey";
            columns: ["primary_manager"];
            isOneToOne: false;
            referencedRelation: "user_task_load";
            referencedColumns: ["user_id"];
          },
          {
            foreignKeyName: "projects_primary_manager_fkey";
            columns: ["primary_manager"];
            isOneToOne: false;
            referencedRelation: "users";
            referencedColumns: ["id"];
          },
          {
            foreignKeyName: "projects_template_id_fkey";
            columns: ["template_id"];
            isOneToOne: false;
            referencedRelation: "project_templates";
            referencedColumns: ["id"];
          },
        ];
      };
      task_dependencies: {
        Row: {
          depends_on: string | null;
          task_id: string | null;
        };
        Insert: {
          depends_on?: string | null;
          task_id?: string | null;
        };
        Update: {
          depends_on?: string | null;
          task_id?: string | null;
        };
        Relationships: [
          {
            foreignKeyName: "task_dependencies_depends_on_fkey";
            columns: ["depends_on"];
            isOneToOne: false;
            referencedRelation: "tasks";
            referencedColumns: ["id"];
          },
          {
            foreignKeyName: "task_dependencies_task_id_fkey";
            columns: ["task_id"];
            isOneToOne: false;
            referencedRelation: "tasks";
            referencedColumns: ["id"];
          },
        ];
      };
      task_templates: {
        Row: {
          checklist: Json | null;
          created_at: string | null;
          description: string | null;
          id: string;
          name: string;
          priority: string | null;
          updated_at: string | null;
        };
        Insert: {
          checklist?: Json | null;
          created_at?: string | null;
          description?: string | null;
          id?: string;
          name: string;
          priority?: string | null;
          updated_at?: string | null;
        };
        Update: {
          checklist?: Json | null;
          created_at?: string | null;
          description?: string | null;
          id?: string;
          name?: string;
          priority?: string | null;
          updated_at?: string | null;
        };
        Relationships: [];
      };
      tasks: {
        Row: {
          assigned_team: string[] | null;
          assignee_id: string | null;
          category: string | null;
          completed_at: string | null;
          created_at: string | null;
          dependencies: string[] | null;
          description: string | null;
          due_date: string | null;
          id: string;
          parent_task_id: string | null;
          priority: string | null;
          progress: number | null;
          project_id: string | null;
          recurring_config: Json | null;
          start_date: string | null;
          status: string;
          tax_form_type: string | null;
          tax_return_id: string | null;
          template_id: string | null;
          title: string;
          updated_at: string | null;
        };
        Insert: {
          assigned_team?: string[] | null;
          assignee_id?: string | null;
          category?: string | null;
          completed_at?: string | null;
          created_at?: string | null;
          dependencies?: string[] | null;
          description?: string | null;
          due_date?: string | null;
          id?: string;
          parent_task_id?: string | null;
          priority?: string | null;
          progress?: number | null;
          project_id?: string | null;
          recurring_config?: Json | null;
          start_date?: string | null;
          status?: string;
          tax_form_type?: string | null;
          tax_return_id?: string | null;
          template_id?: string | null;
          title: string;
          updated_at?: string | null;
        };
        Update: {
          assigned_team?: string[] | null;
          assignee_id?: string | null;
          category?: string | null;
          completed_at?: string | null;
          created_at?: string | null;
          dependencies?: string[] | null;
          description?: string | null;
          due_date?: string | null;
          id?: string;
          parent_task_id?: string | null;
          priority?: string | null;
          progress?: number | null;
          project_id?: string | null;
          recurring_config?: Json | null;
          start_date?: string | null;
          status?: string;
          tax_form_type?: string | null;
          tax_return_id?: string | null;
          template_id?: string | null;
          title?: string;
          updated_at?: string | null;
        };
        Relationships: [
          {
            foreignKeyName: "fk_tasks_parent_task_id";
            columns: ["parent_task_id"];
            isOneToOne: false;
            referencedRelation: "tasks";
            referencedColumns: ["id"];
          },
          {
            foreignKeyName: "fk_tasks_project_id";
            columns: ["project_id"];
            isOneToOne: false;
            referencedRelation: "project_dashboard";
            referencedColumns: ["id"];
          },
          {
            foreignKeyName: "fk_tasks_project_id";
            columns: ["project_id"];
            isOneToOne: false;
            referencedRelation: "project_progress";
            referencedColumns: ["project_id"];
          },
          {
            foreignKeyName: "fk_tasks_project_id";
            columns: ["project_id"];
            isOneToOne: false;
            referencedRelation: "projects";
            referencedColumns: ["id"];
          },
          {
            foreignKeyName: "fk_tasks_template_id";
            columns: ["template_id"];
            isOneToOne: false;
            referencedRelation: "task_templates";
            referencedColumns: ["id"];
          },
          {
            foreignKeyName: "tasks_parent_task_id_fkey";
            columns: ["parent_task_id"];
            isOneToOne: false;
            referencedRelation: "tasks";
            referencedColumns: ["id"];
          },
          {
            foreignKeyName: "tasks_project_id_fkey";
            columns: ["project_id"];
            isOneToOne: false;
            referencedRelation: "project_dashboard";
            referencedColumns: ["id"];
          },
          {
            foreignKeyName: "tasks_project_id_fkey";
            columns: ["project_id"];
            isOneToOne: false;
            referencedRelation: "project_progress";
            referencedColumns: ["project_id"];
          },
          {
            foreignKeyName: "tasks_project_id_fkey";
            columns: ["project_id"];
            isOneToOne: false;
            referencedRelation: "projects";
            referencedColumns: ["id"];
          },
        ];
      };
      tax_returns: {
        Row: {
          assigned_to: string | null;
          client_id: string | null;
          created_at: string | null;
          due_date: string | null;
          extension_date: string | null;
          filed_date: string | null;
          filing_type: string;
          id: string;
          notes: string | null;
          status: string;
          tax_year: number;
          updated_at: string | null;
        };
        Insert: {
          assigned_to?: string | null;
          client_id?: string | null;
          created_at?: string | null;
          due_date?: string | null;
          extension_date?: string | null;
          filed_date?: string | null;
          filing_type: string;
          id?: string;
          notes?: string | null;
          status: string;
          tax_year: number;
          updated_at?: string | null;
        };
        Update: {
          assigned_to?: string | null;
          client_id?: string | null;
          created_at?: string | null;
          due_date?: string | null;
          extension_date?: string | null;
          filed_date?: string | null;
          filing_type?: string;
          id?: string;
          notes?: string | null;
          status?: string;
          tax_year?: number;
          updated_at?: string | null;
        };
        Relationships: [];
      };
      template_categories: {
        Row: {
          created_at: string | null;
          description: string | null;
          id: string;
          name: string;
          parent_id: string | null;
          position: number | null;
          updated_at: string | null;
        };
        Insert: {
          created_at?: string | null;
          description?: string | null;
          id?: string;
          name: string;
          parent_id?: string | null;
          position?: number | null;
          updated_at?: string | null;
        };
        Update: {
          created_at?: string | null;
          description?: string | null;
          id?: string;
          name?: string;
          parent_id?: string | null;
          position?: number | null;
          updated_at?: string | null;
        };
        Relationships: [];
      };
      template_tasks: {
        Row: {
          created_at: string | null;
          dependencies: string[] | null;
          description: string | null;
          id: string;
          order_index: number | null;
          priority: string | null;
          template_id: string | null;
          title: string;
          updated_at: string | null;
        };
        Insert: {
          created_at?: string | null;
          dependencies?: string[] | null;
          description?: string | null;
          id?: string;
          order_index?: number | null;
          priority?: string | null;
          template_id?: string | null;
          title: string;
          updated_at?: string | null;
        };
        Update: {
          created_at?: string | null;
          dependencies?: string[] | null;
          description?: string | null;
          id?: string;
          order_index?: number | null;
          priority?: string | null;
          template_id?: string | null;
          title?: string;
          updated_at?: string | null;
        };
        Relationships: [
          {
            foreignKeyName: "fk_template_tasks_template_id";
            columns: ["template_id"];
            isOneToOne: false;
            referencedRelation: "project_templates";
            referencedColumns: ["id"];
          },
          {
            foreignKeyName: "template_tasks_template_id_fkey";
            columns: ["template_id"];
            isOneToOne: false;
            referencedRelation: "project_templates";
            referencedColumns: ["id"];
          },
        ];
      };
      users: {
        Row: {
          created_at: string | null;
          email: string;
          full_name: string;
          id: string;
          projects_managed: string[] | null;
          role: Database["public"]["Enums"]["user_role"];
          updated_at: string | null;
        };
        Insert: {
          created_at?: string | null;
          email: string;
          full_name: string;
          id: string;
          projects_managed?: string[] | null;
          role: Database["public"]["Enums"]["user_role"];
          updated_at?: string | null;
        };
        Update: {
          created_at?: string | null;
          email?: string;
          full_name?: string;
          id?: string;
          projects_managed?: string[] | null;
          role?: Database["public"]["Enums"]["user_role"];
          updated_at?: string | null;
        };
        Relationships: [];
      };
      workflow_templates: {
        Row: {
          created_at: string | null;
          description: string | null;
          id: string;
          name: string;
          steps: Json;
        };
        Insert: {
          created_at?: string | null;
          description?: string | null;
          id?: string;
          name: string;
          steps: Json;
        };
        Update: {
          created_at?: string | null;
          description?: string | null;
          id?: string;
          name?: string;
          steps?: Json;
        };
        Relationships: [];
      };
    };
    Views: {
      project_dashboard: {
        Row: {
          assigned_team_members: string | null;
          client_name: string | null;
          company_name: string | null;
          completed_tasks: number | null;
          completion_percentage: number | null;
          due_date: string | null;
          id: string | null;
          name: string | null;
          service_type: string | null;
          status: Database["public"]["Enums"]["project_status"] | null;
          total_tasks: number | null;
        };
        Relationships: [];
      };
      project_progress: {
        Row: {
          completed_tasks: number | null;
          completion_percentage: number | null;
          project_id: string | null;
          project_name: string | null;
          project_status: Database["public"]["Enums"]["project_status"] | null;
          total_tasks: number | null;
        };
        Relationships: [];
      };
      user_task_load: {
        Row: {
          completed_tasks: number | null;
          full_name: string | null;
          in_progress_tasks: number | null;
          overdue_tasks: number | null;
          total_tasks: number | null;
          user_id: string | null;
        };
        Relationships: [];
      };
    };
    Functions: {
      _ltree_compress: {
        Args: {
          "": unknown;
        };
        Returns: unknown;
      };
      _ltree_gist_options: {
        Args: {
          "": unknown;
        };
        Returns: undefined;
      };
      archive_project: {
        Args: {
          project_id: string;
        };
        Returns: undefined;
      };
      are_dependencies_completed: {
        Args: {
          task_id: string;
        };
        Returns: boolean;
      };
      binary_quantize:
        | {
            Args: {
              "": string;
            };
            Returns: unknown;
          }
        | {
            Args: {
              "": unknown;
            };
            Returns: unknown;
          };
      clone_project_template:
        | {
            Args: {
              template_id: string;
              client_id: string;
              custom_config?: Json;
            };
            Returns: string;
          }
        | {
            Args: {
              template_id: string;
              new_client_id: string;
              new_tax_year: number;
            };
            Returns: string;
          };
      clone_workflow_template: {
        Args: {
          template_id: string;
          project_id: string;
          custom_config?: Json;
        };
        Returns: Json;
      };
      commit_transaction: {
        Args: Record<PropertyKey, never>;
        Returns: undefined;
      };
      create_project_tasks: {
        Args: {
          p_project_id: string;
          p_template_id: string;
        };
        Returns: undefined;
      };
      create_template_category: {
        Args: {
          p_name: string;
          p_description: string;
        };
        Returns: string;
      };
      create_template_with_tasks: {
        Args: {
          title: string;
          description: string;
          default_priority: Database["public"]["Enums"]["task_priority"];
          project_defaults: Json;
          template_category_id: string;
          metadata: Json;
          tasks: Json;
        };
        Returns: {
          category: string;
          category_id: string | null;
          created_at: string | null;
          default_priority: string | null;
          description: string | null;
          id: string;
          project_defaults: Json | null;
          recurring_schedule: string | null;
          seasonal_priority: Json | null;
          title: string;
          updated_at: string | null;
        };
      };
      delete_data: {
        Args: {
          table_name: string;
          condition: string;
        };
        Returns: string;
      };
      delete_template_category: {
        Args: {
          p_id: string;
        };
        Returns: boolean;
      };
      exec_sql: {
        Args: {
          query_text: string;
        };
        Returns: Json;
      };
      execute_ddl: {
        Args: {
          ddl_command: string;
        };
        Returns: string;
      };
      execute_dml: {
        Args: {
          dml_command: string;
        };
        Returns: string;
      };
      get_current_user_id: {
        Args: Record<PropertyKey, never>;
        Returns: number;
      };
      get_project_tasks: {
        Args: {
          project_id: string;
        };
        Returns: {
          id: string;
          title: string;
          status: string;
          priority: string;
          due_date: string;
          assignee_id: string;
        }[];
      };
      get_workspace_data: {
        Args: Record<PropertyKey, never>;
        Returns: Json;
      };
      halfvec_avg: {
        Args: {
          "": number[];
        };
        Returns: unknown;
      };
      halfvec_out: {
        Args: {
          "": unknown;
        };
        Returns: unknown;
      };
      halfvec_send: {
        Args: {
          "": unknown;
        };
        Returns: string;
      };
      halfvec_typmod_in: {
        Args: {
          "": unknown[];
        };
        Returns: number;
      };
      hnsw_bit_support: {
        Args: {
          "": unknown;
        };
        Returns: unknown;
      };
      hnsw_halfvec_support: {
        Args: {
          "": unknown;
        };
        Returns: unknown;
      };
      hnsw_sparsevec_support: {
        Args: {
          "": unknown;
        };
        Returns: unknown;
      };
      hnswhandler: {
        Args: {
          "": unknown;
        };
        Returns: unknown;
      };
      insert_data: {
        Args: {
          target_table: string;
          data: Json;
        };
        Returns: string;
      };
      is_authenticated_staff: {
        Args: Record<PropertyKey, never>;
        Returns: boolean;
      };
      is_staff: {
        Args: Record<PropertyKey, never>;
        Returns: boolean;
      };
      ivfflat_bit_support: {
        Args: {
          "": unknown;
        };
        Returns: unknown;
      };
      ivfflat_halfvec_support: {
        Args: {
          "": unknown;
        };
        Returns: unknown;
      };
      ivfflathandler: {
        Args: {
          "": unknown;
        };
        Returns: unknown;
      };
      l2_norm:
        | {
            Args: {
              "": unknown;
            };
            Returns: number;
          }
        | {
            Args: {
              "": unknown;
            };
            Returns: number;
          };
      l2_normalize:
        | {
            Args: {
              "": string;
            };
            Returns: string;
          }
        | {
            Args: {
              "": unknown;
            };
            Returns: unknown;
          }
        | {
            Args: {
              "": unknown;
            };
            Returns: unknown;
          };
      lca: {
        Args: {
          "": unknown[];
        };
        Returns: unknown;
      };
      lquery_in: {
        Args: {
          "": unknown;
        };
        Returns: unknown;
      };
      lquery_out: {
        Args: {
          "": unknown;
        };
        Returns: unknown;
      };
      lquery_recv: {
        Args: {
          "": unknown;
        };
        Returns: unknown;
      };
      lquery_send: {
        Args: {
          "": unknown;
        };
        Returns: string;
      };
      ltree_compress: {
        Args: {
          "": unknown;
        };
        Returns: unknown;
      };
      ltree_decompress: {
        Args: {
          "": unknown;
        };
        Returns: unknown;
      };
      ltree_gist_in: {
        Args: {
          "": unknown;
        };
        Returns: unknown;
      };
      ltree_gist_options: {
        Args: {
          "": unknown;
        };
        Returns: undefined;
      };
      ltree_gist_out: {
        Args: {
          "": unknown;
        };
        Returns: unknown;
      };
      ltree_in: {
        Args: {
          "": unknown;
        };
        Returns: unknown;
      };
      ltree_out: {
        Args: {
          "": unknown;
        };
        Returns: unknown;
      };
      ltree_recv: {
        Args: {
          "": unknown;
        };
        Returns: unknown;
      };
      ltree_send: {
        Args: {
          "": unknown;
        };
        Returns: string;
      };
      ltree2text: {
        Args: {
          "": unknown;
        };
        Returns: string;
      };
      ltxtq_in: {
        Args: {
          "": unknown;
        };
        Returns: unknown;
      };
      ltxtq_out: {
        Args: {
          "": unknown;
        };
        Returns: unknown;
      };
      ltxtq_recv: {
        Args: {
          "": unknown;
        };
        Returns: unknown;
      };
      ltxtq_send: {
        Args: {
          "": unknown;
        };
        Returns: string;
      };
      manage_constraint: {
        Args: {
          command: string;
        };
        Returns: string;
      };
      manage_index: {
        Args: {
          command: string;
        };
        Returns: string;
      };
      manage_rls: {
        Args: {
          table_name: string;
          enable: boolean;
        };
        Returns: string;
      };
      manage_table: {
        Args: {
          command: string;
        };
        Returns: string;
      };
      manage_template_category: {
        Args: {
          p_action: string;
          p_id?: string;
          p_name?: string;
          p_description?: string;
        };
        Returns: Json;
      };
      nlevel: {
        Args: {
          "": unknown;
        };
        Returns: number;
      };
      rollback_transaction: {
        Args: Record<PropertyKey, never>;
        Returns: undefined;
      };
      sparsevec_out: {
        Args: {
          "": unknown;
        };
        Returns: unknown;
      };
      sparsevec_send: {
        Args: {
          "": unknown;
        };
        Returns: string;
      };
      sparsevec_typmod_in: {
        Args: {
          "": unknown[];
        };
        Returns: number;
      };
      text2ltree: {
        Args: {
          "": string;
        };
        Returns: unknown;
      };
      update_data: {
        Args: {
          table_name: string;
          data: Json;
          condition: string;
        };
        Returns: string;
      };
      update_template_category: {
        Args: {
          p_id: string;
          p_name: string;
          p_description: string;
        };
        Returns: boolean;
      };
      update_template_with_tasks: {
        Args: {
          template_id: string;
          title: string;
          description: string;
          default_priority: Database["public"]["Enums"]["task_priority"];
          project_defaults: Json;
          template_category_id: string;
          metadata: Json;
          tasks: Json;
        };
        Returns: {
          category: string;
          category_id: string | null;
          created_at: string | null;
          default_priority: string | null;
          description: string | null;
          id: string;
          project_defaults: Json | null;
          recurring_schedule: string | null;
          seasonal_priority: Json | null;
          title: string;
          updated_at: string | null;
        };
      };
      update_workflow_state: {
        Args: {
          project_id: string;
          step_name: string;
          step_status: string;
          step_data?: Json;
        };
        Returns: Json;
      };
      validate_document_requirements: {
        Args: {
          project_id: string;
        };
        Returns: Json;
      };
      validate_json_data: {
        Args: {
          data: Json;
        };
        Returns: boolean;
      };
      vector_avg: {
        Args: {
          "": number[];
        };
        Returns: string;
      };
      vector_dims:
        | {
            Args: {
              "": string;
            };
            Returns: number;
          }
        | {
            Args: {
              "": unknown;
            };
            Returns: number;
          };
      vector_norm: {
        Args: {
          "": string;
        };
        Returns: number;
      };
      vector_out: {
        Args: {
          "": string;
        };
        Returns: unknown;
      };
      vector_send: {
        Args: {
          "": string;
        };
        Returns: string;
      };
      vector_typmod_in: {
        Args: {
          "": unknown[];
        };
        Returns: number;
      };
    };
    Enums: {
      business_type:
        | "individual"
        | "sole_proprietorship"
        | "partnership"
        | "llc"
        | "s_corporation"
        | "c_corporation";
      client_status: "active" | "inactive" | "pending" | "archived";
      client_type: "business" | "individual";
      document_category:
        | "tax_return"
        | "financial_statement"
        | "payroll"
        | "corporate"
        | "supporting";
      document_status: "pending" | "uploaded" | "verified" | "rejected";
      filing_type:
        | "individual"
        | "business"
        | "partnership"
        | "corporation"
        | "s_corporation"
        | "non_profit";
      priority_level: "low" | "medium" | "high" | "urgent";
      project_status:
        | "not_started"
        | "on_hold"
        | "cancelled"
        | "todo"
        | "in_progress"
        | "review"
        | "blocked"
        | "completed"
        | "archived";
      service_type: "tax_return" | "bookkeeping" | "payroll" | "advisory";
      task_priority: "low" | "medium" | "high" | "urgent";
      task_status: "not_started" | "in_progress" | "review" | "completed";
      tax_return_status:
        | "not_started"
        | "gathering_documents"
        | "in_progress"
        | "review"
        | "filed"
        | "amended";
      user_role: "admin" | "team_member";
    };
    CompositeTypes: {
      [_ in never]: never;
    };
  };
};

type PublicSchema = Database[Extract<keyof Database, "public">];

export type Tables<
  PublicTableNameOrOptions extends
    | keyof (PublicSchema["Tables"] & PublicSchema["Views"])
    | { schema: keyof Database },
  TableName extends PublicTableNameOrOptions extends { schema: keyof Database }
    ? keyof (Database[PublicTableNameOrOptions["schema"]]["Tables"] &
        Database[PublicTableNameOrOptions["schema"]]["Views"])
    : never = never,
> = PublicTableNameOrOptions extends { schema: keyof Database }
  ? (Database[PublicTableNameOrOptions["schema"]]["Tables"] &
      Database[PublicTableNameOrOptions["schema"]]["Views"])[TableName] extends {
      Row: infer R;
    }
    ? R
    : never
  : PublicTableNameOrOptions extends keyof (PublicSchema["Tables"] &
        PublicSchema["Views"])
    ? (PublicSchema["Tables"] &
        PublicSchema["Views"])[PublicTableNameOrOptions] extends {
        Row: infer R;
      }
      ? R
      : never
    : never;

export type TablesInsert<
  PublicTableNameOrOptions extends
    | keyof PublicSchema["Tables"]
    | { schema: keyof Database },
  TableName extends PublicTableNameOrOptions extends { schema: keyof Database }
    ? keyof Database[PublicTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = PublicTableNameOrOptions extends { schema: keyof Database }
  ? Database[PublicTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Insert: infer I;
    }
    ? I
    : never
  : PublicTableNameOrOptions extends keyof PublicSchema["Tables"]
    ? PublicSchema["Tables"][PublicTableNameOrOptions] extends {
        Insert: infer I;
      }
      ? I
      : never
    : never;

export type TablesUpdate<
  PublicTableNameOrOptions extends
    | keyof PublicSchema["Tables"]
    | { schema: keyof Database },
  TableName extends PublicTableNameOrOptions extends { schema: keyof Database }
    ? keyof Database[PublicTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = PublicTableNameOrOptions extends { schema: keyof Database }
  ? Database[PublicTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Update: infer U;
    }
    ? U
    : never
  : PublicTableNameOrOptions extends keyof PublicSchema["Tables"]
    ? PublicSchema["Tables"][PublicTableNameOrOptions] extends {
        Update: infer U;
      }
      ? U
      : never
    : never;

export type Enums<
  PublicEnumNameOrOptions extends
    | keyof PublicSchema["Enums"]
    | { schema: keyof Database },
  EnumName extends PublicEnumNameOrOptions extends { schema: keyof Database }
    ? keyof Database[PublicEnumNameOrOptions["schema"]]["Enums"]
    : never = never,
> = PublicEnumNameOrOptions extends { schema: keyof Database }
  ? Database[PublicEnumNameOrOptions["schema"]]["Enums"][EnumName]
  : PublicEnumNameOrOptions extends keyof PublicSchema["Enums"]
    ? PublicSchema["Enums"][PublicEnumNameOrOptions]
    : never;

export type CompositeTypes<
  PublicCompositeTypeNameOrOptions extends
    | keyof PublicSchema["CompositeTypes"]
    | { schema: keyof Database },
  CompositeTypeName extends PublicCompositeTypeNameOrOptions extends {
    schema: keyof Database;
  }
    ? keyof Database[PublicCompositeTypeNameOrOptions["schema"]]["CompositeTypes"]
    : never = never,
> = PublicCompositeTypeNameOrOptions extends { schema: keyof Database }
  ? Database[PublicCompositeTypeNameOrOptions["schema"]]["CompositeTypes"][CompositeTypeName]
  : PublicCompositeTypeNameOrOptions extends keyof PublicSchema["CompositeTypes"]
    ? PublicSchema["CompositeTypes"][PublicCompositeTypeNameOrOptions]
    : never;
```

### `src\types\documents.ts`

```ts
export type DocumentCategory =
  | "tax_return"
  | "financial_statement"
  | "payroll"
  | "corporate"
  | "supporting";

export interface Document {
  id: string;
  project_id: string;
  client_id: string;
  name: string;
  storage_path: string;
  category: DocumentCategory;
  type: string;
  size: number;
  year?: number;
  description?: string;
  uploaded_at: string;
  uploaded_by: string;
  status: "pending" | "approved" | "rejected";
  metadata?: {
    tax_year?: number;
    form_type?: string;
    business_type?: string;
    quarter?: number;
    month?: number;
  };
}

export interface DocumentReminder {
  id: string;
  document_id: string;
  due_date: string;
  status: "pending" | "completed";
  message: string;
  created_at: string;
  updated_at: string;
}

export interface DocumentTracking {
  id: string;
  document_id: string;
  project_id: string;
  status: "required" | "received" | "reviewed" | "approved";
  required_by?: string;
  notes?: string;
  created_at: string;
  updated_at: string;
}
```

### `src\types\hooks.ts`

```ts
import { Project, ProjectTemplate, ProjectFormValues } from "./projects";
import { Task, TaskStatus, ReviewStatus } from "./tasks";
import { Client } from "./clients";
import { Database } from "./database.types";

// Re-export database enums
export type ProjectStatus = Database["public"]["Enums"]["project_status"];
export type TaskPriority = Database["public"]["Enums"]["task_priority"];
export type ClientStatus = Database["public"]["Enums"]["client_status"];
export type ClientType = Database["public"]["Enums"]["client_type"];
export type ServiceType = Database["public"]["Enums"]["service_type"];

// Re-export all types to ensure they are available
export type {
  Project,
  ProjectTemplate,
  ProjectFormValues,
  Task,
  TaskStatus,
  ReviewStatus,
  Client,
  Database,
};

export type WorkflowTemplate = {
  id: string;
  name: string;
  description?: string | null;
  steps: Array<{
    title: string;
    description?: string;
    status?: "pending" | "in_progress" | "completed";
  }>;
  created_at?: string | null;
};

export type TemplateTask = {
  id: string;
  title: string;
  description: string;
  order_index: number;
  priority: "low" | "medium" | "high" | "urgent";
  template_id: string;
  dependencies: string[];
  created_at: string;
  updated_at: string;
};

export type TaxReturn = {
  id?: string;
  project_id?: string;
  tax_year: number;
  filing_type?: string;
  status?: string;
  filing_deadline?: string;
  extension_filed?: boolean;
  created_at?: string;
  updated_at?: string;
};

export type WorkflowStatus = "draft" | "in_progress" | "completed" | "archived";
export type WorkflowTask = Task & { workflow_id?: string };

export type ClientOnboardingWorkflow =
  Database["public"]["Tables"]["client_onboarding_workflows"]["Row"] & {
    steps?: Array<{
      title: string;
      description?: string;
      status: "pending" | "in_progress" | "completed";
    }>;
  };

export type Document =
  Database["public"]["Tables"]["client_documents"]["Row"] & {
    project?: Database["public"]["Tables"]["projects"]["Row"] | null;
    client?: Database["public"]["Tables"]["clients"]["Row"] | null;
  };

export type DocumentFormData = Omit<Document, "id" | "uploaded_at">;

export type Note = Database["public"]["Tables"]["notes"]["Row"];

export type PayrollService =
  Database["public"]["Tables"]["payroll_services"]["Row"];

export type Priority = "low" | "medium" | "high" | "urgent";
export type ServiceCategory =
  | "tax_returns"
  | "payroll"
  | "accounting"
  | "tax_planning"
  | "compliance"
  | "uncategorized";

export type ProjectFilters = {
  search?: string;
  service?: string[];
  serviceType?: string[];
  service_category?: string[];
  status?: string[];
  priority?: string[];
  dateRange?: { from: string; to: string };
  dueDateRange?: { from: Date; to: Date };
  clientId?: string;
  teamMemberId?: string;
  tags?: string[];
  hasDocuments?: boolean;
  hasNotes?: boolean;
  hasTimeEntries?: boolean;
  returnType?: string[];
  reviewStatus?: string[];
  dueThisWeek?: boolean;
  dueThisMonth?: boolean;
  dueThisQuarter?: boolean;
};

export type ProjectAnalytics = {
  completionRate: number;
  riskLevel: string;
  predictedDelay: number;
  resourceUtilization: number;
  recommendations: string[];
};
```

### `src\types\notes.ts`

```ts
export type Note = {
  id?: string;
  project_id?: string;
  content: string;
  created_at?: string;
  updated_at?: string;
  author_id?: string;
  tags?: string[];
  category?: string;
};
```

### `src\types\pg.d.ts`

```ts
declare module "pg" {
  export class Pool {
    constructor(config?: any);
    connect(): Promise<any>;
    query(text: string, params?: any[]): Promise<any>;
    end(): Promise<void>;
  }

  export interface PoolClient {
    query(text: string, params?: any[]): Promise<any>;
    release(err?: Error): void;
  }
}
```

### `src\types\projects.ts`

```ts
import { Database } from "./database.types";
import type { Json } from "./database.types";
import { z } from "zod";
import { projectSchema } from "@/lib/validations/project";
import { TaskWithRelations } from "./tasks";

// Database types with explicit nullability
export type DbProject = Database["public"]["Tables"]["projects"]["Row"];
export type DbProjectInsert =
  Database["public"]["Tables"]["projects"]["Insert"];
export type DbProjectUpdate =
  Database["public"]["Tables"]["projects"]["Update"];

// Enums from database with explicit values
export type ProjectStatus = Database["public"]["Enums"]["project_status"];
export type ServiceType = Database["public"]["Enums"]["service_type"];
export type TaskPriority = Database["public"]["Enums"]["task_priority"];

// Strongly typed JSON fields with explicit optional fields
export interface TaxInfo {
  return_type?: Database["public"]["Enums"]["filing_type"];
  filing_status?: string;
  tax_year?: number;
  due_date?: string;
  extension_date?: string;
  estimated_refund?: number;
  estimated_liability?: number;
  notes?: string;
}

export interface AccountingInfo {
  period_start?: string;
  period_end?: string;
  accounting_method?: "cash" | "accrual";
  fiscal_year_end?: string;
  last_reconciliation_date?: string;
  chart_of_accounts_setup?: boolean;
  software_used?: string;
  frequency?: "weekly" | "monthly" | "quarterly" | "annually";
  notes?: string;
}

export interface PayrollInfo {
  payroll_schedule?: "weekly" | "bi-weekly" | "semi-monthly" | "monthly";
  employee_count?: number;
  last_payroll_date?: string;
  next_payroll_date?: string;
  payroll_provider?: string;
  notes?: string;
}

export interface ServiceInfo {
  service_category?: string;
  frequency?: "one-time" | "weekly" | "monthly" | "quarterly" | "annually";
  last_service_date?: string;
  next_service_date?: string;
  special_instructions?: string;
  notes?: string;
}

// Form data type that matches our schema
export type ProjectFormData = z.infer<typeof projectSchema>;

// Enhanced project type with relationships and strongly typed JSON fields
export interface ProjectWithRelations
  extends Omit<
    DbProject,
    "tax_info" | "accounting_info" | "payroll_info" | "service_info"
  > {
  tax_info: TaxInfo | null;
  accounting_info: AccountingInfo | null;
  payroll_info: PayrollInfo | null;
  service_info: ServiceInfo | null;
  client: Database["public"]["Tables"]["clients"]["Row"] | null;
  template: Database["public"]["Tables"]["project_templates"]["Row"] | null;
  tasks: TaskWithRelations[];
  team_members: Database["public"]["Tables"]["project_team_members"]["Row"][];
  primary_manager_details: Database["public"]["Tables"]["users"]["Row"] | null;
}

// Constants with explicit typing
export const PROJECT_STATUS = {
  NOT_STARTED: "not_started",
  ON_HOLD: "on_hold",
  CANCELLED: "cancelled",
  TODO: "todo",
  IN_PROGRESS: "in_progress",
  REVIEW: "review",
  BLOCKED: "blocked",
  COMPLETED: "completed",
  ARCHIVED: "archived",
} as const satisfies Record<string, ProjectStatus>;

export const SERVICE_TYPE = {
  TAX_RETURN: "tax_return",
  BOOKKEEPING: "bookkeeping",
  PAYROLL: "payroll",
  ADVISORY: "advisory",
} as const satisfies Record<string, ServiceType>;

// Type guards with proper type narrowing
export function isDbProject(project: unknown): project is DbProject {
  return (
    project !== null &&
    typeof project === "object" &&
    "id" in project &&
    "name" in project &&
    "status" in project
  );
}

export function hasClient(
  project: ProjectWithRelations,
): project is ProjectWithRelations & {
  client: NonNullable<ProjectWithRelations["client"]>;
} {
  return project.client !== null;
}

export function hasTemplate(
  project: ProjectWithRelations,
): project is ProjectWithRelations & {
  template: NonNullable<ProjectWithRelations["template"]>;
} {
  return project.template !== null;
}

// Conversion utilities with strict type checking
export function toProjectFormData(project: DbProject): Omit<
  ProjectFormData,
  "service_type" | "priority"
> & {
  service_type?: ServiceType | null;
  priority?: TaskPriority | null;
} {
  const { id, created_at, updated_at, priority, service_type, ...formData } =
    project;

  return {
    ...formData,
    priority: priority as TaskPriority,
    service_type: service_type as ServiceType,
    tax_info: project.tax_info as TaxInfo | null,
    accounting_info: project.accounting_info as AccountingInfo | null,
    payroll_info: project.payroll_info as PayrollInfo | null,
    service_info: project.service_info as ServiceInfo | null,
  };
}

export function toDbProject(formData: ProjectFormData): DbProjectInsert {
  const { tax_info, accounting_info, payroll_info, service_info, ...rest } =
    formData;

  return {
    ...rest,
    name: rest.name || "",
    status: rest.status || "not_started",
    tax_info: tax_info as Json,
    accounting_info: accounting_info as Json,
    payroll_info: payroll_info as Json,
    service_info: service_info as Json,
  };
}
```

### `src\types\schema.ts`

```ts
import { Database } from "./database.types";

export type DbEnums = Database["public"]["Enums"];
export type DbTables = Database["public"]["Tables"];

// Tax Return Types
export type TaxReturn = DbTables["tax_returns"]["Row"];
export type TaxReturnInsert = DbTables["tax_returns"]["Insert"];
export type TaxReturnUpdate = DbTables["tax_returns"]["Update"];
export type TaxReturnStatus = DbEnums["tax_return_status"];
export type FilingType = DbEnums["filing_type"];

// User Types
export type User = DbTables["users"]["Row"];
export type UserRole = DbEnums["user_role"];

// Client Types
export type Client = DbTables["clients"]["Row"];
export type ClientStatus = DbEnums["client_status"];
export type ClientType = DbEnums["client_type"];

// Project Types
export type Project = DbTables["projects"]["Row"];
export type ProjectStatus = DbEnums["project_status"];
export type ServiceType = DbEnums["service_type"];

// Task Types
export type Task = DbTables["tasks"]["Row"];
export type TaskStatus = DbEnums["task_status"];
export type TaskPriority = DbEnums["task_priority"];

// Document Types
export type Document = DbTables["client_documents"]["Row"];
export type DocumentStatus = DbEnums["document_status"];

// Utility type to extract relationships
type ExtractRelationships<T> = T extends { Relationships: infer R } ? R : never;

// Export relationships for each table
export type TaxReturnRelationships = ExtractRelationships<
  DbTables["tax_returns"]
>;
export type UserRelationships = ExtractRelationships<DbTables["users"]>;
export type ClientRelationships = ExtractRelationships<DbTables["clients"]>;
export type ProjectRelationships = ExtractRelationships<DbTables["projects"]>;
export type TaskRelationships = ExtractRelationships<DbTables["tasks"]>;
export type DocumentRelationships = ExtractRelationships<
  DbTables["client_documents"]
>;
```

### `src\types\tasks.ts`

```ts
import { z } from "zod";
import type { Database } from "./database.types";

// Re-export database enums with explicit values
export type TaskStatus = Database["public"]["Enums"]["task_status"];
export type TaskPriority = Database["public"]["Enums"]["task_priority"];

// Base task type from database with strict null handling
export type DbTask = Database["public"]["Tables"]["tasks"]["Row"];
export type DbTaskInsert = Database["public"]["Tables"]["tasks"]["Insert"];
export type DbTaskUpdate = Database["public"]["Tables"]["tasks"]["Update"];

// Task with relationships - making nullability explicit
export interface TaskWithRelations extends DbTask {
  project: {
    id: string;
    name: string;
  } | null;
  assignee: {
    id: string;
    email: string;
    full_name: string;
    role: Database["public"]["Enums"]["user_role"];
  } | null;
  parent_task: {
    id: string;
    title: string;
  } | null;
  checklist_items: Array<{
    id: string;
    title: string;
    completed: boolean;
    description: string | null;
    task_id: string;
  }>;
  activity_log_entries: Array<{
    id: string;
    action: string;
    details: string | null;
    performed_by: string;
    created_at: string | null;
  }>;
}

// Task form schema with strict validation
export const taskSchema = z.object({
  title: z.string().min(1, "Title is required"),
  description: z.string().optional().nullable(),
  status: z.enum(["todo", "in_progress", "review", "completed"]),
  priority: z.enum(["low", "medium", "high", "urgent"]).nullable(),
  project_id: z.string().uuid().nullable(),
  assignee_id: z.string().uuid().nullable(),
  due_date: z.string().datetime().nullable(),
  start_date: z.string().datetime().nullable(),
  tax_form_type: z.string().nullable(),
  category: z.string().nullable(),
  checklist: z
    .object({
      items: z.array(
        z.object({
          id: z.string(),
          title: z.string(),
          completed: z.boolean(),
          description: z.string().nullable(),
          task_id: z.string(),
        }),
      ),
      completed_count: z.number(),
      total_count: z.number(),
    })
    .nullable(),
  activity_log: z
    .array(
      z.object({
        action: z.string(),
        timestamp: z.string(),
        user_id: z.string(),
        details: z.string(),
      }),
    )
    .nullable(),
  recurring_config: z.record(z.unknown()).nullable(),
});

// Form data type
export type TaskFormData = z.infer<typeof taskSchema>;

// Constants with explicit typing
export const TASK_STATUS = {
  TODO: "todo",
  IN_PROGRESS: "in_progress",
  REVIEW: "review",
  COMPLETED: "completed",
} as const satisfies Record<string, TaskStatus>;

export const TASK_PRIORITY = {
  LOW: "low",
  MEDIUM: "medium",
  HIGH: "high",
  URGENT: "urgent",
} as const satisfies Record<string, TaskPriority>;

// Type guards with proper type narrowing
export function hasProject(
  task: TaskWithRelations,
): task is TaskWithRelations & {
  project: NonNullable<TaskWithRelations["project"]>;
} {
  return task.project !== null;
}

export function hasAssignee(
  task: TaskWithRelations,
): task is TaskWithRelations & {
  assignee: NonNullable<TaskWithRelations["assignee"]>;
} {
  return task.assignee !== null;
}

// Helper function to convert database task to form data with strict null handling
export function toTaskFormData(task: TaskWithRelations): TaskFormData {
  return {
    title: task.title,
    description: task.description,
    status: task.status as TaskStatus,
    priority: task.priority as TaskPriority | null,
    project_id: task.project_id,
    assignee_id: task.assignee_id,
    due_date: task.due_date,
    start_date: task.start_date,
    tax_form_type: task.tax_form_type,
    category: task.category,
    checklist: task.checklist_items
      ? {
          items: task.checklist_items,
          completed_count: task.checklist_items.filter((item) => item.completed)
            .length,
          total_count: task.checklist_items.length,
        }
      : null,
    activity_log:
      task.activity_log_entries?.map((entry) => ({
        action: entry.action,
        timestamp: entry.created_at || new Date().toISOString(),
        user_id: entry.performed_by,
        details: entry.details || "",
      })) || null,
    recurring_config: task.recurring_config,
  };
}

// Helper function to convert form data to database task with strict type checking
export function toDbTaskInsert(formData: TaskFormData): DbTaskInsert {
  return {
    title: formData.title,
    description: formData.description,
    status: formData.status,
    priority: formData.priority,
    project_id: formData.project_id,
    assignee_id: formData.assignee_id,
    due_date: formData.due_date,
    start_date: formData.start_date,
    tax_form_type: formData.tax_form_type,
    category: formData.category,
    recurring_config: formData.recurring_config,
  };
}
```

### `src\types\templates.ts`

```ts
import type { Database } from "./database.types";
import { z } from "zod";
import {
  projectTemplateSchema,
  templateTaskSchema,
} from "@/lib/validations/template";

// Database types
export type DbProjectTemplate =
  Database["public"]["Tables"]["project_templates"]["Row"];
export type DbProjectTemplateInsert =
  Database["public"]["Tables"]["project_templates"]["Insert"];
export type DbProjectTemplateUpdate =
  Database["public"]["Tables"]["project_templates"]["Update"];

export type DbTemplateTask =
  Database["public"]["Tables"]["template_tasks"]["Row"];
export type DbTemplateTaskInsert =
  Database["public"]["Tables"]["template_tasks"]["Insert"];
export type DbTemplateTaskUpdate =
  Database["public"]["Tables"]["template_tasks"]["Update"];

// JSON field types from database
export type ProjectDefaults = NonNullable<
  DbProjectTemplate["project_defaults"]
>;
export type SeasonalPriority = NonNullable<
  DbProjectTemplate["seasonal_priority"]
>;

// Form data types
export type ProjectTemplateFormData = z.infer<typeof projectTemplateSchema>;
export type TemplateTaskFormData = z.infer<typeof templateTaskSchema>;

// Types with relationships
export interface ProjectTemplateWithRelations extends DbProjectTemplate {
  tasks?: DbTemplateTask[];
  category?: Database["public"]["Tables"]["template_categories"]["Row"] | null;
}

export interface TemplateTaskWithRelations extends DbTemplateTask {
  template?: DbProjectTemplate | null;
  dependencies?: DbTemplateTask[];
}

// Template category types
export type DbTemplateCategory =
  Database["public"]["Tables"]["template_categories"]["Row"];
export type DbTemplateCategoryInsert =
  Database["public"]["Tables"]["template_categories"]["Insert"];
export type DbTemplateCategoryUpdate =
  Database["public"]["Tables"]["template_categories"]["Update"];

export interface TemplateCategoryWithRelations extends DbTemplateCategory {
  templates?: DbProjectTemplate[];
  parent?: DbTemplateCategory | null;
  children?: DbTemplateCategory[];
}
```

### `src\types\time_entries.ts`

```ts
export type TimeEntry = {
  id?: string;
  project_id?: string;
  task_id?: string;
  user_id?: string;
  start_time: string;
  end_time?: string;
  duration?: number;
  description?: string;
  billable?: boolean;
  hourly_rate?: number;
  tags?: string[];
};
```

### `src\types\users.ts`

```ts
import type { Database } from "./database.types";
import { z } from "zod";
import { userSchema, profileSchema } from "@/lib/validations/user";

// Database types
export type DbUser = Database["public"]["Tables"]["users"]["Row"];
export type DbUserInsert = Database["public"]["Tables"]["users"]["Insert"];
export type DbUserUpdate = Database["public"]["Tables"]["users"]["Update"];

export type DbProfile = Database["public"]["Tables"]["profiles"]["Row"];
export type DbProfileInsert =
  Database["public"]["Tables"]["profiles"]["Insert"];
export type DbProfileUpdate =
  Database["public"]["Tables"]["profiles"]["Update"];

// Enum types from database
export type UserRole = Database["public"]["Enums"]["user_role"];

// Form data types
export type UserFormData = z.infer<typeof userSchema>;
export type ProfileFormData = z.infer<typeof profileSchema>;

// Types with relationships
export interface UserWithRelations extends DbUser {
  profile?: DbProfile | null;
  managed_projects?: Database["public"]["Tables"]["projects"]["Row"][];
  assigned_tasks?: Database["public"]["Tables"]["tasks"]["Row"][];
  team_memberships?: Database["public"]["Tables"]["project_team_members"]["Row"][];
}

export interface ProfileWithRelations extends DbProfile {
  user?: DbUser | null;
}

// Constants
export const USER_ROLES: UserRole[] = ["admin", "team_member"];
```

### `src\types\validation.ts`

```ts
import { z } from "zod";
import type { Database } from "./database.types";

type DbEnums = Database["public"]["Enums"];

// Contact Info Schema
export const contactInfoSchema = z.object({
  email: z.string().email().optional(),
  phone: z.string().optional(),
  address: z.string().optional(),
  city: z.string().optional(),
  state: z.string().optional(),
  zip: z.string().optional(),
});

// Client Schema
export const clientSchema = z.object({
  id: z.string().uuid().optional(),
  name: z.string().min(1, "Name is required"),
  contact_info: contactInfoSchema,
  status: z.enum([
    "active",
    "inactive",
    "pending",
    "archived",
  ] as const satisfies readonly DbEnums["client_status"][]),
  type: z
    .enum([
      "business",
      "individual",
    ] as const satisfies readonly DbEnums["client_type"][])
    .optional(),
  tax_id: z.string().optional(),
  notes: z.string().optional(),
  created_at: z.string().datetime().optional(),
  updated_at: z.string().datetime().optional(),
});

// Project Schema
export const projectSchema = z.object({
  id: z.string().uuid().optional(),
  name: z.string().min(1, "Project name is required"),
  description: z.string().optional(),
  client_id: z.string().uuid(),
  status: z.enum([
    "not_started",
    "on_hold",
    "cancelled",
    "todo",
    "in_progress",
    "review",
    "blocked",
    "completed",
    "archived",
  ] as const satisfies readonly DbEnums["project_status"][]),
  service_type: z
    .enum([
      "tax_return",
      "bookkeeping",
      "payroll",
      "advisory",
    ] as const satisfies readonly DbEnums["service_type"][])
    .optional(),
  start_date: z.string().datetime().optional(),
  due_date: z.string().datetime().optional(),
  created_at: z.string().datetime().optional(),
  updated_at: z.string().datetime().optional(),
});

// Task Schema
export const taskSchema = z.object({
  id: z.string().uuid().optional(),
  title: z.string().min(1, "Task title is required"),
  description: z.string().optional(),
  status: z.enum([
    "todo",
    "in_progress",
    "review",
    "completed",
  ] as const satisfies readonly DbEnums["task_status"][]),
  priority: z.enum([
    "low",
    "medium",
    "high",
    "urgent",
  ] as const satisfies readonly DbEnums["task_priority"][]),
  project_id: z.string().uuid().optional(),
  assignee_id: z.string().uuid().optional(),
  due_date: z.string().datetime().optional(),
  created_at: z.string().datetime().optional(),
  updated_at: z.string().datetime().optional(),
});

// Task Status Transitions
export const taskStatusTransitions = {
  todo: ["in_progress", "review"],
  in_progress: ["todo", "review", "completed"],
  review: ["in_progress", "completed"],
  completed: ["review"],
} as const;

// Utility type for valid status transitions
export type ValidStatusTransition<T extends DbEnums["task_status"]> =
  (typeof taskStatusTransitions)[T][number];

// Form Data Schemas
export const clientFormSchema = clientSchema.omit({
  id: true,
  created_at: true,
  updated_at: true,
});

export const projectFormSchema = projectSchema.omit({
  id: true,
  created_at: true,
  updated_at: true,
});

export const taskFormSchema = taskSchema.omit({
  id: true,
  created_at: true,
  updated_at: true,
});

// Type Inference
export type ClientFormData = z.infer<typeof clientFormSchema>;
export type ProjectFormData = z.infer<typeof projectFormSchema>;
export type TaskFormData = z.infer<typeof taskFormSchema>;

// Validation Functions
export const validateClient = (data: unknown) => clientSchema.parse(data);
export const validateProject = (data: unknown) => projectSchema.parse(data);
export const validateTask = (data: unknown) => taskSchema.parse(data);

// Safe Status Transition Validator
export const validateTaskStatusTransition = (
  currentStatus: DbEnums["task_status"],
  newStatus: DbEnums["task_status"],
): boolean => {
  const allowedTransitions = taskStatusTransitions[currentStatus];
  return allowedTransitions.includes(newStatus as any);
};
```

### `src\types\workflows.ts`

```ts
import { Database } from "./database.types";

// Base types from database
export type DbWorkflowTemplate =
  Database["public"]["Tables"]["workflow_templates"]["Row"];
export type DbWorkflowTemplateInsert =
  Database["public"]["Tables"]["workflow_templates"]["Insert"];
export type DbWorkflowTemplateUpdate =
  Database["public"]["Tables"]["workflow_templates"]["Update"];

// Workflow status enum
export const WORKFLOW_STATUS = {
  DRAFT: "draft",
  ACTIVE: "active",
  ARCHIVED: "archived",
} as const;

export type WorkflowStatus =
  (typeof WORKFLOW_STATUS)[keyof typeof WORKFLOW_STATUS];

// Step type for workflow templates
export interface WorkflowStep {
  id: string;
  title: string;
  description?: string | null;
  order: number;
  required: boolean;
  dependencies?: string[] | null;
  metadata?: Record<string, unknown> | null;
}

// Extended type with relationships
export interface WorkflowTemplateWithRelations extends DbWorkflowTemplate {
  workflows?:
    | Database["public"]["Tables"]["client_onboarding_workflows"]["Row"][]
    | null;
}

// Form data types
export type WorkflowFormData = Omit<
  DbWorkflowTemplateInsert,
  "id" | "created_at" | "updated_at"
>;
```

### `src\utils\hello.ts`

```ts
import { hello } from "./helloFunction";
```

### `src\workflows\clientOnboardingWorkflow.ts`

```ts
interface ClientData {
  id: string;
  name?: string;
  email?: string;
  // other fields...
}

export async function initOnboardingFlow(clientData: ClientData) {
  // Validate input
  if (!clientData || !clientData.id) {
    throw new Error("Missing required client ID");
  }

  // Existing onboarding logic...
  console.log("Onboarding flow initiated for:", clientData.id);
  // ...
}
```

### `src\__tests__\auth.test.tsx`

```tsx
import { render, screen, act } from "@testing-library/react";
import { UnifiedAuthProvider } from "@/providers/unified-auth-provider";

// Mock next/navigation
jest.mock("next/navigation", () => ({
  useRouter() {
    return {
      refresh: jest.fn(),
    };
  },
}));

// Test component that uses the auth context
function TestComponent() {
  const { session } = useAuth();
  return <div>{session ? "Authenticated" : "Not authenticated"}</div>;
}

describe("UnifiedAuthProvider", () => {
  it("provides authentication context to children", async () => {
    await act(async () => {
      render(
        <UnifiedAuthProvider>
          <TestComponent />
        </UnifiedAuthProvider>,
      );
    });

    // Initially not authenticated
    expect(screen.getByText("Not authenticated")).toBeInTheDocument();
  });
});
```

### `src\__tests__\client-creation.test.ts`

```ts
import { describe, it, expect, beforeEach, vi } from "vitest";
import { createClient } from "@/lib/services/client.service";
import { getTasksByClient } from "@/lib/services/task.service";
import { supabaseTestClient } from "./test-env";

vi.mock("@/lib/services/client.service", () => ({
  createClient: vi.fn().mockImplementation(async (client) => ({
    id: "mock-client-id",
    ...client,
  })),
}));

vi.mock("@/lib/services/task.service", () => ({
  getTasksByClient: vi.fn().mockImplementation(async (clientId) => [
    {
      id: "task-1",
      title: "Business Onboarding Meeting",
      category: "onboarding",
      client_id: clientId,
    },
    {
      id: "task-2",
      title: "Financial Document Collection",
      category: "onboarding",
      client_id: clientId,
    },
    {
      id: "task-3",
      title: "Business Tax Planning",
      category: "onboarding",
      client_id: clientId,
    },
  ]),
}));

describe("Client Creation and Onboarding", () => {
  // Test data
  const testBusinessClient = {
    full_name: "Test Business Client",
    contact_email: "test@business.com",
    type: "business",
    status: "active",
    onboarding_notes: "Special tax considerations needed. Multiple locations.",
  };

  const testIndividualClient = {
    full_name: "Test Individual Client",
    contact_email: "test@individual.com",
    type: "individual",
    status: "active",
    onboarding_notes: "First-time tax filer, needs extra guidance.",
  };

  beforeEach(async () => {
    vi.clearAllMocks();
  });

  it("should create a business client with onboarding notes", async () => {
    const client = await createClient(testBusinessClient);
    expect(client).toBeDefined();
    expect(client.type).toBe("business");
    expect(client.onboarding_notes).toBe(testBusinessClient.onboarding_notes);

    // Check that onboarding tasks were created
    const tasks = await getTasksByClient(client.id);
    expect(tasks).toBeDefined();
    expect(tasks.length).toBeGreaterThan(0);
    expect(tasks.some((t) => t.category === "onboarding")).toBe(true);

    // Verify business-specific tasks were created
    const taskTitles = tasks.map((t) => t.title);
    expect(taskTitles).toContain("Business Onboarding Meeting");
    expect(taskTitles).toContain("Financial Document Collection");
    expect(taskTitles).toContain("Business Tax Planning");
  });

  it("should create an individual client with onboarding notes", async () => {
    const client = await createClient(testIndividualClient);
    expect(client).toBeDefined();
    expect(client.type).toBe("individual");
    expect(client.onboarding_notes).toBe(testIndividualClient.onboarding_notes);

    // Check that onboarding tasks were created
    const tasks = await getTasksByClient(client.id);
    expect(tasks).toBeDefined();
    expect(tasks.length).toBeGreaterThan(0);
    expect(tasks.some((t) => t.category === "onboarding")).toBe(true);

    // Verify individual-specific tasks were created
    const taskTitles = tasks.map((t) => t.title);
    expect(taskTitles).toContain("Business Onboarding Meeting");
    expect(taskTitles).toContain("Financial Document Collection");
    expect(taskTitles).toContain("Business Tax Planning");
  });

  it("should properly handle task completion timestamps", async () => {
    // Create a client and get their tasks
    const client = await createClient(testBusinessClient);
    const tasks = await getTasksByClient(client.id);
    const task = tasks[0];

    // Mock the update response
    vi.mocked(supabaseTestClient.from).mockImplementationOnce(() => ({
      update: vi.fn().mockReturnThis(),
      eq: vi.fn().mockReturnThis(),
      select: vi.fn().mockReturnThis(),
      single: vi.fn().mockResolvedValue({
        data: {
          ...task,
          status: "completed",
          completed_at: new Date().toISOString(),
        },
      }),
    }));

    // Update task to completed
    const { data: updatedTask } = await supabaseTestClient
      .from("tasks")
      .update({ status: "completed" })
      .eq("id", task.id)
      .select()
      .single();

    expect(updatedTask).toBeDefined();
    expect(updatedTask.completed_at).toBeDefined();
    expect(new Date(updatedTask.completed_at!)).toBeInstanceOf(Date);
  });
});
```

### `src\__tests__\client-form.test.tsx`

```tsx
import { render, screen, fireEvent } from "@testing-library/react";
import { ClientForm } from "@/components/clients/client-form";
import { vi } from "vitest";

describe("ClientForm", () => {
  const mockOnSubmit = vi.fn();
  const defaultClient = {
    id: "123",
    name: "Test Client",
    email: "test@example.com",
    phone: "123-456-7890",
    service_type: "individual",
    onboarding_notes: null,
  };

  beforeEach(() => {
    mockOnSubmit.mockClear();
  });

  it("renders client form fields correctly", () => {
    render(<ClientForm client={defaultClient} onSubmit={mockOnSubmit} />);

    expect(screen.getByLabelText(/name/i)).toHaveValue("Test Client");
    expect(screen.getByLabelText(/email/i)).toHaveValue("test@example.com");
    expect(screen.getByLabelText(/phone/i)).toHaveValue("123-456-7890");
    expect(screen.getByLabelText(/service type/i)).toHaveValue("individual");
    expect(screen.getByLabelText(/onboarding notes/i)).toBeInTheDocument();
  });

  it("handles form submission with onboarding notes", async () => {
    render(<ClientForm client={defaultClient} onSubmit={mockOnSubmit} />);

    const onboardingNotesInput = screen.getByLabelText(/onboarding notes/i);
    fireEvent.change(onboardingNotesInput, {
      target: { value: "Test onboarding notes" },
    });

    const submitButton = screen.getByRole("button", { name: /save/i });
    fireEvent.click(submitButton);

    expect(mockOnSubmit).toHaveBeenCalledWith(
      expect.objectContaining({
        onboarding_notes: "Test onboarding notes",
      }),
    );
  });

  it("validates required fields", async () => {
    render(<ClientForm client={null} onSubmit={mockOnSubmit} />);

    const submitButton = screen.getByRole("button", { name: /save/i });
    fireEvent.click(submitButton);

    expect(await screen.findByText(/name is required/i)).toBeInTheDocument();
    expect(await screen.findByText(/email is required/i)).toBeInTheDocument();
    expect(
      await screen.findByText(/service type is required/i),
    ).toBeInTheDocument();
    expect(mockOnSubmit).not.toHaveBeenCalled();
  });

  it("updates existing client with onboarding notes", async () => {
    const existingClient = {
      ...defaultClient,
      onboarding_notes: "Existing notes",
    };

    render(<ClientForm client={existingClient} onSubmit={mockOnSubmit} />);

    const onboardingNotesInput = screen.getByLabelText(/onboarding notes/i);
    expect(onboardingNotesInput).toHaveValue("Existing notes");

    fireEvent.change(onboardingNotesInput, {
      target: { value: "Updated notes" },
    });

    const submitButton = screen.getByRole("button", { name: /save/i });
    fireEvent.click(submitButton);

    expect(mockOnSubmit).toHaveBeenCalledWith(
      expect.objectContaining({
        onboarding_notes: "Updated notes",
      }),
    );
  });
});
```

### `src\__tests__\middleware.test.ts`

```ts
import { NextRequest, NextResponse } from "next/server";
import { createServerClient } from "@supabase/ssr";
import { middleware } from "../middleware";

// Mock next/server
jest.mock("next/server", () => ({
  NextResponse: {
    next: jest.fn(),
    redirect: jest.fn(),
  },
  NextRequest: jest.fn(),
}));

// Mock @supabase/ssr
jest.mock("@supabase/ssr", () => ({
  createServerClient: jest.fn(),
}));

describe("Middleware", () => {
  let mockRequest: jest.Mocked<NextRequest>;
  let mockSupabase: any;

  beforeEach(() => {
    // Reset mocks
    jest.clearAllMocks();

    // Mock request
    mockRequest = {
      nextUrl: { pathname: "/", href: "http://localhost:3000" },
      cookies: {
        get: jest.fn(),
        set: jest.fn(),
      },
    } as unknown as jest.Mocked<NextRequest>;

    // Mock Supabase client
    mockSupabase = {
      auth: {
        getSession: jest.fn(),
      },
    };
    (createServerClient as jest.Mock).mockReturnValue(mockSupabase);
  });

  it("allows access to public routes without session", async () => {
    mockRequest.nextUrl.pathname = "/auth/login";
    mockSupabase.auth.getSession.mockResolvedValue({
      data: { session: null },
      error: null,
    });

    await middleware(mockRequest);

    expect(NextResponse.redirect).not.toHaveBeenCalled();
    expect(NextResponse.next).toHaveBeenCalled();
  });

  it("redirects to dashboard if authenticated user tries to access auth routes", async () => {
    mockRequest.nextUrl.pathname = "/auth/login";
    mockSupabase.auth.getSession.mockResolvedValue({
      data: { session: { user: { id: "1" }, expires_at: Date.now() + 3600 } },
      error: null,
    });

    await middleware(mockRequest);

    expect(NextResponse.redirect).toHaveBeenCalledWith(
      expect.stringContaining("/dashboard"),
    );
  });

  it("redirects to login for protected routes without session", async () => {
    mockRequest.nextUrl.pathname = "/dashboard";
    mockSupabase.auth.getSession.mockResolvedValue({
      data: { session: null },
      error: null,
    });

    await middleware(mockRequest);

    expect(NextResponse.redirect).toHaveBeenCalledWith(
      expect.stringContaining("/auth/login"),
    );
  });

  it("allows access to protected routes with valid session", async () => {
    mockRequest.nextUrl.pathname = "/dashboard";
    mockSupabase.auth.getSession.mockResolvedValue({
      data: { session: { user: { id: "1" }, expires_at: Date.now() + 3600 } },
      error: null,
    });

    await middleware(mockRequest);

    expect(NextResponse.redirect).not.toHaveBeenCalled();
    expect(NextResponse.next).toHaveBeenCalled();
  });

  it("redirects to login when session is expired", async () => {
    mockRequest.nextUrl.pathname = "/dashboard";
    mockSupabase.auth.getSession.mockResolvedValue({
      data: { session: { user: { id: "1" }, expires_at: Date.now() - 3600 } },
      error: null,
    });

    await middleware(mockRequest);

    expect(NextResponse.redirect).toHaveBeenCalledWith(
      expect.stringContaining("/auth/login"),
    );
  });
});
```

### `src\__tests__\setup.ts`

```ts
import "@testing-library/jest-dom";

// Mock environment variables
process.env.NEXT_PUBLIC_SUPABASE_URL = "https://test.supabase.co";
process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY = "test-key";

// Suppress console errors during tests
global.console.error = jest.fn();

// Mock window.fetch
global.fetch = jest.fn();

// Clean up after each test
afterEach(() => {
  jest.clearAllMocks();
});
```

### `src\__tests__\task-side-panel.test.tsx`

```tsx
import { render, screen, fireEvent } from "@testing-library/react";
import { TaskSidePanel } from "@/components/tasks/task-side-panel";
import { vi } from "vitest";

describe("TaskSidePanel", () => {
  const mockOnSubmit = vi.fn();
  const defaultTask = {
    id: "123",
    title: "Test Task",
    description: "Test Description",
    status: "in_progress",
    priority: "medium",
    due_date: new Date().toISOString(),
    completed_at: null,
  };

  beforeEach(() => {
    mockOnSubmit.mockClear();
  });

  it("renders task details correctly", () => {
    render(<TaskSidePanel task={defaultTask} onSubmit={mockOnSubmit} />);

    expect(screen.getByDisplayValue("Test Task")).toBeInTheDocument();
    expect(screen.getByDisplayValue("Test Description")).toBeInTheDocument();
    expect(screen.getByDisplayValue("in_progress")).toBeInTheDocument();
  });

  it("sets completed_at when status changes to completed", async () => {
    render(<TaskSidePanel task={defaultTask} onSubmit={mockOnSubmit} />);

    const statusSelect = screen.getByLabelText(/status/i);
    fireEvent.change(statusSelect, { target: { value: "completed" } });

    const submitButton = screen.getByRole("button", { name: /update/i });
    fireEvent.click(submitButton);

    expect(mockOnSubmit).toHaveBeenCalledWith(
      expect.objectContaining({
        status: "completed",
        completed_at: expect.any(String),
      }),
    );
  });

  it("clears completed_at when status changes from completed", async () => {
    const completedTask = {
      ...defaultTask,
      status: "completed",
      completed_at: new Date().toISOString(),
    };

    render(<TaskSidePanel task={completedTask} onSubmit={mockOnSubmit} />);

    const statusSelect = screen.getByLabelText(/status/i);
    fireEvent.change(statusSelect, { target: { value: "in_progress" } });

    const submitButton = screen.getByRole("button", { name: /update/i });
    fireEvent.click(submitButton);

    expect(mockOnSubmit).toHaveBeenCalledWith(
      expect.objectContaining({
        status: "in_progress",
        completed_at: null,
      }),
    );
  });
});
```

### `src\__tests__\tasks.test.tsx`

```tsx
import { test, expect } from "@playwright/test";

test.describe("Task Management System", () => {
  test.beforeEach(async ({ page }) => {
    // Set up test environment and authenticate
    await page.goto("/tasks");
    // Add authentication steps here if needed
  });

  test("should display task list and pagination", async ({ page }) => {
    // Wait for tasks to load
    await page.waitForSelector('[data-testid="task-list"]');

    // Check if tasks are displayed
    const tasks = await page.$$('[data-testid="task-item"]');
    expect(tasks.length).toBeGreaterThan(0);

    // Check pagination if there are multiple pages
    const pagination = await page.$('[data-testid="pagination"]');
    if (pagination) {
      // Click next page
      await page.click('[data-testid="next-page"]');
      // Wait for new tasks to load
      await page.waitForSelector('[data-testid="task-list"]');
      // Verify page change
      const currentPage = await page.$eval(
        '[data-testid="current-page"]',
        (el) => el.textContent,
      );
      expect(currentPage).toBe("2");
    }
  });

  test("should create a new task", async ({ page }) => {
    // Click create task button
    await page.click('[data-testid="create-task"]');

    // Fill out task form
    await page.fill('[data-testid="task-title"]', "Test Task");
    await page.fill('[data-testid="task-description"]', "Test Description");
    await page.selectOption('[data-testid="task-priority"]', "high");
    await page.selectOption('[data-testid="task-status"]', "todo");

    // Submit form
    await page.click('[data-testid="submit-task"]');

    // Wait for success message
    await page.waitForSelector('[data-testid="toast-success"]');

    // Verify task was created
    const taskTitle = await page.textContent(
      '[data-testid="task-item"]:first-child [data-testid="task-title"]',
    );
    expect(taskTitle).toBe("Test Task");
  });

  test("should update an existing task", async ({ page }) => {
    // Wait for tasks to load
    await page.waitForSelector('[data-testid="task-item"]');

    // Click edit button on first task
    await page.click(
      '[data-testid="task-item"]:first-child [data-testid="edit-task"]',
    );

    // Update task details
    await page.fill('[data-testid="task-title"]', "Updated Task");
    await page.selectOption('[data-testid="task-status"]', "in_progress");

    // Submit form
    await page.click('[data-testid="submit-task"]');

    // Wait for success message
    await page.waitForSelector('[data-testid="toast-success"]');

    // Verify task was updated
    const taskTitle = await page.textContent(
      '[data-testid="task-item"]:first-child [data-testid="task-title"]',
    );
    expect(taskTitle).toBe("Updated Task");
  });

  test("should delete a task", async ({ page }) => {
    // Wait for tasks to load
    await page.waitForSelector('[data-testid="task-item"]');

    // Get initial task count
    const initialTasks = await page.$$('[data-testid="task-item"]');
    const initialCount = initialTasks.length;

    // Click delete button on first task
    await page.click(
      '[data-testid="task-item"]:first-child [data-testid="delete-task"]',
    );

    // Confirm deletion
    await page.click('[data-testid="confirm-delete"]');

    // Wait for success message
    await page.waitForSelector('[data-testid="toast-success"]');

    // Verify task was deleted
    const remainingTasks = await page.$$('[data-testid="task-item"]');
    expect(remainingTasks.length).toBe(initialCount - 1);
  });

  test("should handle errors gracefully", async ({ page }) => {
    // Simulate network error by disabling network
    await page.route("**/api/tasks/**", (route) => route.abort());

    // Try to create a task
    await page.click('[data-testid="create-task"]');
    await page.fill('[data-testid="task-title"]', "Test Task");
    await page.click('[data-testid="submit-task"]');

    // Verify error message is displayed
    await page.waitForSelector('[data-testid="toast-error"]');
    const errorMessage = await page.textContent('[data-testid="toast-error"]');
    expect(errorMessage).toContain("Failed to create task");
  });

  test("should toggle task details", async ({ page }) => {
    // Wait for tasks to load
    await page.waitForSelector('[data-testid="task-item"]');

    // Click show details button
    await page.click('[data-testid="show-details"]');

    // Verify details are displayed
    const details = await page.$('[data-testid="task-details"]');
    expect(details).toBeTruthy();

    // Click hide details button
    await page.click('[data-testid="show-details"]');

    // Verify details are hidden
    const hiddenDetails = await page.$('[data-testid="task-details"]');
    expect(hiddenDetails).toBeFalsy();
  });
});
```

### `src\__tests__\test-env.ts`

```ts
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";
import { vi } from "vitest";

export const testEmail = "jr@adfs.tax";
export const testPassword = "Install55!!";

// Mock Supabase client
const mockSupabase = {
  auth: {
    signInWithPassword: vi.fn().mockResolvedValue({
      data: {
        session: {
          access_token: "mock-token",
          refresh_token: "mock-refresh-token",
          user: {
            id: "mock-user-id",
            email: testEmail,
          },
        },
      },
      error: null,
    }),
  },
  from: vi.fn().mockReturnThis(),
  select: vi.fn().mockReturnThis(),
  insert: vi.fn().mockReturnThis(),
  update: vi.fn().mockReturnThis(),
  delete: vi.fn().mockReturnThis(),
  eq: vi.fn().mockReturnThis(),
  in: vi.fn().mockReturnThis(),
  single: vi.fn().mockReturnThis(),
  or: vi.fn().mockReturnThis(),
};

vi.mock("@supabase/auth-helpers-nextjs", () => ({
  createClientComponentClient: () => mockSupabase,
}));

export const supabaseTestClient = createClientComponentClient();

export const setupTestAuth = async () => {
  const {
    data: { session },
    error,
  } = await supabaseTestClient.auth.signInWithPassword({
    email: testEmail,
    password: testPassword,
  });

  if (error) {
    throw new Error(`Auth setup failed: ${error.message}`);
  }

  return session;
};

export const cleanupTestData = async () => {
  // Clean up test clients
  const { data: clients } = await supabaseTestClient
    .from("clients")
    .select("id")
    .or(
      "contact_email.eq.test@business.com,contact_email.eq.test@individual.com",
    );

  if (clients && clients.length > 0) {
    const clientIds = clients.map((c) => c.id);
    await supabaseTestClient.from("tasks").delete().in("client_id", clientIds);
    await supabaseTestClient.from("clients").delete().in("id", clientIds);
  }
};
```

### `src\__tests__\api\documents.test.ts`

```ts
import { describe, expect, test, vi } from "vitest";
import { createMocks } from "node-mocks-http";
import { POST } from "@/app/api/documents/upload/route";
import { mockSupabaseClient } from "../setup/test-utils";
import { documentFactory } from "../setup/factories";

vi.mock("@supabase/auth-helpers-nextjs", () => ({
  createServerComponentClient: () => mockSupabaseClient,
}));

describe("Document Upload API", () => {
  test("handles valid document upload", async () => {
    const testDoc = documentFactory.build();
    const file = new File(["test content"], "test.pdf", {
      type: "application/pdf",
    });
    const formData = new FormData();
    formData.append("file", file);
    formData.append("projectId", testDoc.project_id);
    formData.append("clientId", testDoc.client_id);

    const { req, res } = createMocks({
      method: "POST",
      body: formData,
    });

    mockSupabaseClient.storage.from().upload.mockResolvedValueOnce({
      data: { path: testDoc.storage_path },
      error: null,
    });

    mockSupabaseClient.from().insert.mockResolvedValueOnce({
      data: testDoc,
      error: null,
    });

    const response = await POST(req);
    const data = await response.json();

    expect(response.status).toBe(200);
    expect(data).toHaveProperty("id");
    expect(data.storage_path).toBe(testDoc.storage_path);
  });

  test("validates required fields", async () => {
    const formData = new FormData();
    const { req, res } = createMocks({
      method: "POST",
      body: formData,
    });

    const response = await POST(req);
    const data = await response.json();

    expect(response.status).toBe(400);
    expect(data.error).toBe("Missing required fields");
  });

  test("validates file types", async () => {
    const file = new File(["test content"], "test.exe", {
      type: "application/x-msdownload",
    });
    const formData = new FormData();
    formData.append("file", file);
    formData.append("projectId", "test-project");
    formData.append("clientId", "test-client");

    const { req, res } = createMocks({
      method: "POST",
      body: formData,
    });

    const response = await POST(req);
    const data = await response.json();

    expect(response.status).toBe(400);
    expect(data.error).toBe("Invalid file type");
  });

  test("handles storage errors", async () => {
    const file = new File(["test content"], "test.pdf", {
      type: "application/pdf",
    });
    const formData = new FormData();
    formData.append("file", file);
    formData.append("projectId", "test-project");
    formData.append("clientId", "test-client");

    const { req, res } = createMocks({
      method: "POST",
      body: formData,
    });

    mockSupabaseClient.storage.from().upload.mockResolvedValueOnce({
      data: null,
      error: new Error("Storage error"),
    });

    const response = await POST(req);
    const data = await response.json();

    expect(response.status).toBe(500);
    expect(data.error).toBe("Failed to upload document");
  });

  test("creates document tracking record", async () => {
    const testDoc = documentFactory.build();
    const file = new File(["test content"], "test.pdf", {
      type: "application/pdf",
    });
    const formData = new FormData();
    formData.append("file", file);
    formData.append("projectId", testDoc.project_id);
    formData.append("clientId", testDoc.client_id);

    const { req, res } = createMocks({
      method: "POST",
      body: formData,
    });

    mockSupabaseClient.storage.from().upload.mockResolvedValueOnce({
      data: { path: testDoc.storage_path },
      error: null,
    });

    mockSupabaseClient.from().insert.mockResolvedValueOnce({
      data: testDoc,
      error: null,
    });

    const response = await POST(req);

    expect(mockSupabaseClient.from).toHaveBeenCalledWith("document_tracking");
    expect(mockSupabaseClient.from().insert).toHaveBeenCalledWith(
      expect.objectContaining({
        document_id: testDoc.id,
        project_id: testDoc.project_id,
        status: "received",
      }),
    );
  });
});
```

### `src\__tests__\clients\client-form.test.tsx`

```tsx
import { render, screen, waitFor } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import { ClientForm } from "@/components/clients/client-form";
import { renderWithForm } from "../setup/test-utils";
import { vi } from "vitest";

describe("ClientForm", () => {
  const mockOnSubmit = vi.fn(async () => {});

  beforeEach(() => {
    vi.clearAllMocks();
  });

  it("validates required fields", async () => {
    const { user } = renderWithForm(<ClientForm onSubmit={mockOnSubmit} />);

    // Submit empty form
    await user.click(screen.getByRole("button", { name: /create client/i }));

    // Wait for validation messages
    await waitFor(() => {
      expect(screen.getByText("Full name is required")).toBeInTheDocument();
      expect(screen.getByText("invalid email format")).toBeInTheDocument();
    });

    // Fill out form with invalid email
    await user.type(screen.getByLabelText(/full name/i), "Test User");
    await user.type(screen.getByLabelText(/email/i), "invalid-email");

    // Submit with invalid email
    await user.click(screen.getByRole("button", { name: /create client/i }));

    // Check for email validation message
    await waitFor(() => {
      expect(screen.getByText("invalid email format")).toBeInTheDocument();
    });

    // Fix the email
    await user.clear(screen.getByLabelText(/email/i));
    await user.type(screen.getByLabelText(/email/i), "test@example.com");

    // Submit valid form
    await user.click(screen.getByRole("button", { name: /create client/i }));

    // Verify form submission
    await waitFor(() => {
      expect(mockOnSubmit).toHaveBeenCalledWith(
        expect.objectContaining({
          full_name: "Test User",
          contact_email: "test@example.com",
        }),
      );
    });
  });

  it("handles edit mode correctly", async () => {
    const existingClient = {
      full_name: "John Doe",
      contact_email: "john@example.com",
      company_name: "ACME Inc",
      status: "active" as const,
      type: "business" as const,
    };

    const { user } = renderWithForm(
      <ClientForm onSubmit={mockOnSubmit} client={existingClient} isEditing />,
    );

    // Verify form is pre-filled
    expect(screen.getByLabelText(/full name/i)).toHaveValue("John Doe");
    expect(screen.getByLabelText(/email/i)).toHaveValue("john@example.com");
    expect(screen.getByLabelText(/company name/i)).toHaveValue("ACME Inc");

    // Update some fields
    await user.clear(screen.getByLabelText(/company name/i));
    await user.type(screen.getByLabelText(/company name/i), "New Company");

    // Submit updated form
    await user.click(screen.getByRole("button", { name: /update client/i }));

    // Verify form submission
    await waitFor(() => {
      expect(mockOnSubmit).toHaveBeenCalledWith(
        expect.objectContaining({
          full_name: "John Doe",
          contact_email: "john@example.com",
          company_name: "New Company",
          status: "active",
          type: "business",
        }),
      );
    });
  });

  it("shows loading state during submission", async () => {
    const { user } = renderWithForm(<ClientForm onSubmit={mockOnSubmit} />);

    // Fill out form
    await user.type(screen.getByLabelText(/full name/i), "Test User");
    await user.type(screen.getByLabelText(/email/i), "test@example.com");

    // Mock a delayed submission
    mockOnSubmit.mockImplementationOnce(
      () => new Promise((resolve) => setTimeout(resolve, 1000)),
    );

    // Submit form
    await user.click(screen.getByRole("button", { name: /create client/i }));

    // Verify loading state
    expect(
      screen.getByRole("button", { name: /creating/i }),
    ).toBeInTheDocument();
    expect(screen.getByRole("button", { name: /creating/i })).toBeDisabled();

    // Wait for submission to complete
    await waitFor(() => {
      expect(
        screen.getByRole("button", { name: /create client/i }),
      ).toBeEnabled();
    });
  });
});
```

### `src\__tests__\clients\client-list.test.tsx`

```tsx
import { describe, expect, test, vi } from "vitest";
import { screen, waitFor } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import { ClientList } from "@/components/clients/client-list";
import { renderWithProviders } from "../setup/test-utils";

describe("ClientList", () => {
  const mockClients = [
    {
      id: "1",
      full_name: "John Doe",
      company_name: "",
      contact_email: "john@example.com",
      status: "active",
      type: "individual",
      contact_info: {
        phone: "123-456-7890",
        address: "123 Main St",
      },
      tax_info: {
        tax_id: "123-45-6789",
        filing_status: "single",
        last_filed: "2023-12-31",
        next_deadline: "2024-04-15",
      },
      created_at: "2024-01-01",
      updated_at: "2024-01-01",
    },
    {
      id: "2",
      full_name: "",
      company_name: "ACME Inc",
      contact_email: "info@acme.com",
      status: "pending",
      type: "business",
      contact_info: {
        phone: "987-654-3210",
        address: "456 Corp Ave",
      },
      tax_info: {
        tax_id: "98-7654321",
        filing_status: "corporation",
        last_filed: "2023-12-31",
        next_deadline: "2024-03-15",
      },
      created_at: "2024-01-02",
      updated_at: "2024-01-02",
    },
  ];

  beforeEach(() => {
    vi.clearAllMocks();
  });

  test("renders loading state initially", async () => {
    const { mockSupabaseClient } = renderWithProviders(<ClientList />);

    // Mock a never-resolving promise to keep loading state
    mockSupabaseClient.from.mockReturnValueOnce({
      ...mockSupabaseClient.from(),
      select: vi.fn().mockImplementation(() => new Promise(() => {})),
    });

    expect(screen.getByText(/loading clients/i)).toBeInTheDocument();
  });

  test("renders client list after loading", async () => {
    const { mockSupabaseClient } = renderWithProviders(<ClientList />);

    mockSupabaseClient.from.mockReturnValueOnce({
      ...mockSupabaseClient.from(),
      select: vi.fn().mockResolvedValueOnce({
        data: mockClients,
        error: null,
      }),
    });

    // Wait for clients to load
    await waitFor(() => {
      expect(screen.getByText("John Doe")).toBeInTheDocument();
      expect(screen.getByText("ACME Inc")).toBeInTheDocument();
    });

    // Verify Supabase call
    expect(mockSupabaseClient.from).toHaveBeenCalledWith("clients");
    expect(mockSupabaseClient.from().select).toHaveBeenCalled();
  });

  test("handles client deletion", async () => {
    const { mockSupabaseClient, user } = renderWithProviders(<ClientList />);

    // Mock initial load
    mockSupabaseClient.from.mockReturnValueOnce({
      ...mockSupabaseClient.from(),
      select: vi.fn().mockResolvedValueOnce({
        data: mockClients,
        error: null,
      }),
    });

    // Mock deletion
    mockSupabaseClient.from.mockReturnValueOnce({
      ...mockSupabaseClient.from(),
      delete: vi.fn().mockResolvedValueOnce({
        data: null,
        error: null,
      }),
    });

    // Wait for clients to load
    await waitFor(() => {
      expect(screen.getByText("John Doe")).toBeInTheDocument();
    });

    // Click delete button for first client
    const deleteButton = screen.getAllByRole("button", { name: /delete/i })[0];
    await user.click(deleteButton);

    // Confirm deletion
    const confirmButton = screen.getByRole("button", { name: /confirm/i });
    await user.click(confirmButton);

    // Verify deletion call
    await waitFor(() => {
      expect(mockSupabaseClient.from).toHaveBeenCalledWith("clients");
      expect(mockSupabaseClient.from().delete).toHaveBeenCalledWith({
        id: mockClients[0].id,
      });
    });

    // Verify success message
    expect(
      await screen.findByText(/client deleted successfully/i),
    ).toBeInTheDocument();
  });

  test("handles error state", async () => {
    const { mockSupabaseClient } = renderWithProviders(<ClientList />);

    mockSupabaseClient.from.mockReturnValueOnce({
      ...mockSupabaseClient.from(),
      select: vi.fn().mockResolvedValueOnce({
        data: null,
        error: { message: "Failed to load clients" },
      }),
    });

    await waitFor(() => {
      expect(screen.getByText(/failed to load clients/i)).toBeInTheDocument();
    });
  });

  test("filters clients by search term", async () => {
    const { mockSupabaseClient, user } = renderWithProviders(<ClientList />);

    mockSupabaseClient.from.mockReturnValueOnce({
      ...mockSupabaseClient.from(),
      select: vi.fn().mockResolvedValueOnce({
        data: mockClients,
        error: null,
      }),
    });

    // Wait for clients to load
    await waitFor(() => {
      expect(screen.getByText("John Doe")).toBeInTheDocument();
      expect(screen.getByText("ACME Inc")).toBeInTheDocument();
    });

    // Type in search box
    const searchInput = screen.getByPlaceholderText(/search clients/i);
    await user.type(searchInput, "acme");

    // Verify filtered results
    expect(screen.queryByText("John Doe")).not.toBeInTheDocument();
    expect(screen.getByText("ACME Inc")).toBeInTheDocument();
  });
});
```

### `src\__tests__\components\role-guard.test.tsx`

```tsx
import { render, screen } from "@testing-library/react";
import { RoleGuard } from "@/components/role-guard";
import { useAuth } from "@/hooks/use-auth";

// Mock the useAuth hook
jest.mock("@/hooks/use-auth");
const mockUseAuth = useAuth as jest.MockedFunction<typeof useAuth>;

describe("RoleGuard", () => {
  const protectedContent = <div>Protected Content</div>;
  const fallbackContent = <div>Fallback Content</div>;

  beforeEach(() => {
    jest.clearAllMocks();
  });

  it("shows nothing while loading", () => {
    mockUseAuth.mockReturnValue({
      user: null,
      loading: true,
      signIn: jest.fn(),
      signOut: jest.fn(),
    });

    render(
      <RoleGuard allowedRoles={["admin"]} fallback={fallbackContent}>
        {protectedContent}
      </RoleGuard>,
    );

    expect(screen.queryByText("Protected Content")).not.toBeInTheDocument();
    expect(screen.queryByText("Fallback Content")).not.toBeInTheDocument();
  });

  it("shows fallback when user is not authenticated", () => {
    mockUseAuth.mockReturnValue({
      user: null,
      loading: false,
      signIn: jest.fn(),
      signOut: jest.fn(),
    });

    render(
      <RoleGuard allowedRoles={["admin"]} fallback={fallbackContent}>
        {protectedContent}
      </RoleGuard>,
    );

    expect(screen.queryByText("Protected Content")).not.toBeInTheDocument();
    expect(screen.getByText("Fallback Content")).toBeInTheDocument();
  });

  it("shows fallback when user does not have required role", () => {
    mockUseAuth.mockReturnValue({
      user: { app_metadata: { role: "user" } } as any,
      loading: false,
      signIn: jest.fn(),
      signOut: jest.fn(),
    });

    render(
      <RoleGuard allowedRoles={["admin"]} fallback={fallbackContent}>
        {protectedContent}
      </RoleGuard>,
    );

    expect(screen.queryByText("Protected Content")).not.toBeInTheDocument();
    expect(screen.getByText("Fallback Content")).toBeInTheDocument();
  });

  it("shows protected content when user has required role", () => {
    mockUseAuth.mockReturnValue({
      user: { app_metadata: { role: "admin" } } as any,
      loading: false,
      signIn: jest.fn(),
      signOut: jest.fn(),
    });

    render(
      <RoleGuard allowedRoles={["admin"]} fallback={fallbackContent}>
        {protectedContent}
      </RoleGuard>,
    );

    expect(screen.getByText("Protected Content")).toBeInTheDocument();
    expect(screen.queryByText("Fallback Content")).not.toBeInTheDocument();
  });
});
```

### `src\__tests__\components\tax\TaxReturnForm.test.tsx`

```tsx
import { render, screen, fireEvent, waitFor } from "@testing-library/react";
import { TaxReturnForm } from "@/components/tax/TaxReturnForm";
import { createClient } from "@/lib/supabase/browser";
import { useRouter } from "next/navigation";

// Mock dependencies
jest.mock("@/lib/supabase/browser");
jest.mock("next/navigation", () => ({
  useRouter: jest.fn(),
}));

const mockCreateClient = createClient as jest.MockedFunction<
  typeof createClient
>;
const mockRouter = useRouter as jest.MockedFunction<typeof useRouter>;

describe("TaxReturnForm", () => {
  const mockSupabase = {
    from: jest.fn().mockReturnThis(),
    insert: jest.fn(),
    update: jest.fn(),
    eq: jest.fn(),
  };

  const mockRouterInstance = {
    refresh: jest.fn(),
    push: jest.fn(),
  };

  beforeEach(() => {
    jest.clearAllMocks();
    mockCreateClient.mockReturnValue(mockSupabase as any);
    mockRouter.mockReturnValue(mockRouterInstance as any);
  });

  it("renders form fields correctly", () => {
    render(<TaxReturnForm clientId="123" />);

    expect(screen.getByLabelText(/tax year/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/status/i)).toBeInTheDocument();
    expect(
      screen.getByRole("button", { name: /create tax return/i }),
    ).toBeInTheDocument();
  });

  it("initializes with default values", () => {
    const currentYear = new Date().getFullYear();
    render(<TaxReturnForm clientId="123" />);

    const taxYearSelect = screen.getByRole("combobox", { name: /tax year/i });
    expect(taxYearSelect).toHaveTextContent(currentYear.toString());

    const statusSelect = screen.getByRole("combobox", { name: /status/i });
    expect(statusSelect).toHaveTextContent("draft");
  });

  it("initializes with provided values", () => {
    const initialData = {
      tax_year: 2022,
      status: "in_progress" as const,
      client_id: "123",
    };

    render(<TaxReturnForm clientId="123" initialData={initialData} />);

    const taxYearSelect = screen.getByRole("combobox", { name: /tax year/i });
    expect(taxYearSelect).toHaveTextContent("2022");

    const statusSelect = screen.getByRole("combobox", { name: /status/i });
    expect(statusSelect).toHaveTextContent("in_progress");
  });

  it("handles form submission for new tax return", async () => {
    mockSupabase.insert.mockResolvedValueOnce({ error: null });

    render(<TaxReturnForm clientId="123" />);

    const submitButton = screen.getByRole("button", {
      name: /create tax return/i,
    });
    fireEvent.click(submitButton);

    await waitFor(() => {
      expect(mockSupabase.from).toHaveBeenCalledWith("tax_returns");
      expect(mockSupabase.insert).toHaveBeenCalled();
      expect(mockRouterInstance.refresh).toHaveBeenCalled();
      expect(mockRouterInstance.push).toHaveBeenCalledWith(
        "/dashboard/tax-returns",
      );
    });
  });

  it("handles form submission for existing tax return", async () => {
    mockSupabase.update.mockReturnThis();
    mockSupabase.eq.mockResolvedValueOnce({ error: null });

    const initialData = {
      id: "456",
      tax_year: 2022,
      status: "in_progress" as const,
      client_id: "123",
    };

    render(<TaxReturnForm clientId="123" initialData={initialData} />);

    const submitButton = screen.getByRole("button", {
      name: /update tax return/i,
    });
    fireEvent.click(submitButton);

    await waitFor(() => {
      expect(mockSupabase.from).toHaveBeenCalledWith("tax_returns");
      expect(mockSupabase.update).toHaveBeenCalled();
      expect(mockSupabase.eq).toHaveBeenCalledWith("id", "456");
      expect(mockRouterInstance.refresh).toHaveBeenCalled();
      expect(mockRouterInstance.push).toHaveBeenCalledWith(
        "/dashboard/tax-returns",
      );
    });
  });

  it("handles submission errors", async () => {
    const consoleError = jest.spyOn(console, "error").mockImplementation();
    mockSupabase.insert.mockResolvedValueOnce({
      error: new Error("Database error"),
    });

    render(<TaxReturnForm clientId="123" />);

    const submitButton = screen.getByRole("button", {
      name: /create tax return/i,
    });
    fireEvent.click(submitButton);

    await waitFor(() => {
      expect(consoleError).toHaveBeenCalled();
    });

    consoleError.mockRestore();
  });
});
```

### `src\__tests__\database\rls.test.ts`

```ts
import { test, expect } from "@playwright/test";
import { createClient } from "@supabase/supabase-js";
import {
  clientFactory,
  documentFactory,
  projectFactory,
  taskFactory,
} from "../setup/factories";

test.describe("Row Level Security Policies", () => {
  let supabase;

  test.beforeAll(async () => {
    supabase = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL,
      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY,
    );
  });

  test("prevents unauthorized access to clients table", async () => {
    // Attempt to select without authentication
    const { data: clients, error } = await supabase.from("clients").select("*");

    expect(error).toBeDefined();
    expect(error.message).toContain("authentication required");
    expect(clients).toBeNull();
  });

  test("allows authenticated user to access their own client data", async () => {
    const client = clientFactory.build();

    // Login as client
    const { data: authData } = await supabase.auth.signInWithPassword({
      email: client.email,
      password: "password123",
    });

    // Attempt to select client data
    const { data: clients, error } = await supabase
      .from("clients")
      .select("*")
      .eq("id", client.id);

    expect(error).toBeNull();
    expect(clients).toHaveLength(1);
    expect(clients[0].id).toBe(client.id);
  });

  test("prevents access to other clients data", async () => {
    const client1 = clientFactory.build();
    const client2 = clientFactory.build();

    // Login as client1
    const { data: authData } = await supabase.auth.signInWithPassword({
      email: client1.email,
      password: "password123",
    });

    // Attempt to select client2's data
    const { data: clients, error } = await supabase
      .from("clients")
      .select("*")
      .eq("id", client2.id);

    expect(error).toBeDefined();
    expect(error.message).toContain("row level security policy");
    expect(clients).toBeNull();
  });

  test("enforces document access policies", async () => {
    const client = clientFactory.build();
    const document = documentFactory.build({ clientId: client.id });

    // Login as client
    const { data: authData } = await supabase.auth.signInWithPassword({
      email: client.email,
      password: "password123",
    });

    // Test document access
    const { data: documents, error } = await supabase
      .from("documents")
      .select("*")
      .eq("id", document.id);

    expect(error).toBeNull();
    expect(documents).toHaveLength(1);
    expect(documents[0].client_id).toBe(client.id);
  });

  test("enforces project access policies", async () => {
    const client = clientFactory.build();
    const project = projectFactory.build({ clientId: client.id });

    // Login as client
    const { data: authData } = await supabase.auth.signInWithPassword({
      email: client.email,
      password: "password123",
    });

    // Test project access
    const { data: projects, error } = await supabase
      .from("projects")
      .select("*")
      .eq("id", project.id);

    expect(error).toBeNull();
    expect(projects).toHaveLength(1);
    expect(projects[0].client_id).toBe(client.id);
  });

  test("enforces task access policies", async () => {
    const client = clientFactory.build();
    const project = projectFactory.build({ clientId: client.id });
    const task = taskFactory.build({ projectId: project.id });

    // Login as client
    const { data: authData } = await supabase.auth.signInWithPassword({
      email: client.email,
      password: "password123",
    });

    // Test task access
    const { data: tasks, error } = await supabase
      .from("tasks")
      .select("*")
      .eq("id", task.id);

    expect(error).toBeNull();
    expect(tasks).toHaveLength(1);
    expect(tasks[0].project_id).toBe(project.id);
  });

  test("enforces insert policies", async () => {
    const client = clientFactory.build();
    const otherClient = clientFactory.build();

    // Login as client
    const { data: authData } = await supabase.auth.signInWithPassword({
      email: client.email,
      password: "password123",
    });

    // Attempt to insert document for another client
    const { data: document, error } = await supabase.from("documents").insert({
      client_id: otherClient.id,
      name: "Test Document",
      storage_path: "/test.pdf",
    });

    expect(error).toBeDefined();
    expect(error.message).toContain("row level security policy");
    expect(document).toBeNull();
  });

  test("enforces update policies", async () => {
    const client = clientFactory.build();
    const document = documentFactory.build({ clientId: client.id });

    // Login as client
    const { data: authData } = await supabase.auth.signInWithPassword({
      email: client.email,
      password: "password123",
    });

    // Attempt to update document client_id
    const { data: updatedDoc, error } = await supabase
      .from("documents")
      .update({ client_id: "different-client" })
      .eq("id", document.id);

    expect(error).toBeDefined();
    expect(error.message).toContain("row level security policy");
    expect(updatedDoc).toBeNull();
  });

  test("enforces delete policies", async () => {
    const client = clientFactory.build();
    const otherClient = clientFactory.build();
    const document = documentFactory.build({ clientId: otherClient.id });

    // Login as client
    const { data: authData } = await supabase.auth.signInWithPassword({
      email: client.email,
      password: "password123",
    });

    // Attempt to delete another client's document
    const { data: deletedDoc, error } = await supabase
      .from("documents")
      .delete()
      .eq("id", document.id);

    expect(error).toBeDefined();
    expect(error.message).toContain("row level security policy");
    expect(deletedDoc).toBeNull();
  });

  test("enforces role-based access control", async () => {
    const admin = clientFactory.build({ role: "admin" });
    const regularClient = clientFactory.build({ role: "client" });

    // Login as regular client
    const { data: authData } = await supabase.auth.signInWithPassword({
      email: regularClient.email,
      password: "password123",
    });

    // Attempt to access admin-only endpoint
    const { data: adminData, error } = await supabase.rpc(
      "get_system_statistics",
    );

    expect(error).toBeDefined();
    expect(error.message).toContain("insufficient privileges");
    expect(adminData).toBeNull();
  });
});
```

### `src\__tests__\database\schema.test.ts`

```ts
import { createClient } from "@supabase/supabase-js";
import { beforeAll, describe, expect, test } from "vitest";

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
);

describe("Database Schema", () => {
  describe("Clients Table", () => {
    test("has required columns", async () => {
      const { data, error } = await supabase.from("clients").select().limit(1);

      expect(error).toBeNull();
      const client = data?.[0];
      expect(client).toHaveProperty("id");
      expect(client).toHaveProperty("full_name");
      expect(client).toHaveProperty("email");
      expect(client).toHaveProperty("business_type");
      expect(client).toHaveProperty("created_at");
      expect(client).toHaveProperty("updated_at");
    });
  });

  describe("Projects Table", () => {
    test("has required columns", async () => {
      const { data, error } = await supabase.from("projects").select().limit(1);

      expect(error).toBeNull();
      const project = data?.[0];
      expect(project).toHaveProperty("id");
      expect(project).toHaveProperty("client_id");
      expect(project).toHaveProperty("name");
      expect(project).toHaveProperty("status");
      expect(project).toHaveProperty("type");
      expect(project).toHaveProperty("created_at");
    });

    test("enforces client relationship", async () => {
      const { error } = await supabase.from("projects").insert({
        name: "Test Project",
        client_id: "non-existent-id",
        type: "tax_return",
      });

      expect(error).not.toBeNull();
      expect(error?.message).toContain("foreign key constraint");
    });
  });

  describe("Documents Table", () => {
    test("has required columns", async () => {
      const { data, error } = await supabase
        .from("documents")
        .select()
        .limit(1);

      expect(error).toBeNull();
      const document = data?.[0];
      expect(document).toHaveProperty("id");
      expect(document).toHaveProperty("project_id");
      expect(document).toHaveProperty("client_id");
      expect(document).toHaveProperty("name");
      expect(document).toHaveProperty("storage_path");
      expect(document).toHaveProperty("category");
      expect(document).toHaveProperty("uploaded_at");
    });

    test("enforces project and client relationships", async () => {
      const { error } = await supabase.from("documents").insert({
        name: "test.pdf",
        project_id: "non-existent-id",
        client_id: "non-existent-id",
        category: "tax_return",
      });

      expect(error).not.toBeNull();
      expect(error?.message).toContain("foreign key constraint");
    });
  });

  describe("Tasks Table", () => {
    test("has required columns", async () => {
      const { data, error } = await supabase.from("tasks").select().limit(1);

      expect(error).toBeNull();
      const task = data?.[0];
      expect(task).toHaveProperty("id");
      expect(task).toHaveProperty("project_id");
      expect(task).toHaveProperty("title");
      expect(task).toHaveProperty("status");
      expect(task).toHaveProperty("priority");
      expect(task).toHaveProperty("created_at");
    });
  });
});
```

### `src\__tests__\documents\document-upload.test.tsx`

```tsx
import { describe, expect, test, vi } from "vitest";
import { screen, fireEvent } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import { DocumentUpload } from "@/components/documents/document-upload";
import { renderWithProviders, createTestFile } from "../setup/test-utils";

describe("DocumentUpload", () => {
  const user = userEvent.setup();

  beforeEach(() => {
    vi.clearAllMocks();
  });

  test("handles file upload", async () => {
    const onUpload = vi.fn();
    const { mockSupabaseClient } = renderWithProviders(
      <DocumentUpload onUpload={onUpload} />,
    );

    mockSupabaseClient.storage.from().upload.mockResolvedValueOnce({
      data: { path: "test.pdf" },
      error: null,
    });

    const file = createTestFile("test.pdf", "application/pdf");
    const input = screen.getByLabelText(/upload document/i);
    await fireEvent.change(input, { target: { files: [file] } });

    expect(mockSupabaseClient.storage.from().upload).toHaveBeenCalled();
    expect(onUpload).toHaveBeenCalledWith(
      expect.objectContaining({
        name: "test.pdf",
        path: "test.pdf",
      }),
    );
  });

  test("validates file type", async () => {
    renderWithProviders(<DocumentUpload />);

    const file = createTestFile("test.exe", "application/x-msdownload");
    const input = screen.getByLabelText(/upload document/i);
    await fireEvent.change(input, { target: { files: [file] } });

    expect(await screen.findByText(/invalid file type/i)).toBeInTheDocument();
  });

  test("validates file size", async () => {
    renderWithProviders(<DocumentUpload maxSize={5 * 1024 * 1024} />);

    const largeFile = new File(
      [new ArrayBuffer(6 * 1024 * 1024)],
      "large.pdf",
      {
        type: "application/pdf",
      },
    );
    const input = screen.getByLabelText(/upload document/i);
    await fireEvent.change(input, { target: { files: [largeFile] } });

    expect(await screen.findByText(/file size exceeds/i)).toBeInTheDocument();
  });

  test("shows upload progress", async () => {
    const { mockSupabaseClient } = renderWithProviders(<DocumentUpload />);

    // Mock upload progress events
    const uploadPromise = new Promise((resolve) => setTimeout(resolve, 100));
    mockSupabaseClient.storage.from().upload.mockReturnValueOnce(uploadPromise);

    const file = createTestFile("test.pdf", "application/pdf");
    const input = screen.getByLabelText(/upload document/i);
    await fireEvent.change(input, { target: { files: [file] } });

    expect(screen.getByRole("progressbar")).toBeInTheDocument();
    expect(screen.getByText(/uploading/i)).toBeInTheDocument();
  });

  test("handles upload errors", async () => {
    const { mockSupabaseClient } = renderWithProviders(<DocumentUpload />);

    mockSupabaseClient.storage
      .from()
      .upload.mockRejectedValueOnce(new Error("Upload failed"));

    const file = createTestFile("test.pdf", "application/pdf");
    const input = screen.getByLabelText(/upload document/i);
    await fireEvent.change(input, { target: { files: [file] } });

    expect(await screen.findByText(/failed to upload/i)).toBeInTheDocument();
  });

  test("allows multiple file selection", async () => {
    const onUpload = vi.fn();
    const { mockSupabaseClient } = renderWithProviders(
      <DocumentUpload multiple onUpload={onUpload} />,
    );

    mockSupabaseClient.storage.from().upload.mockResolvedValue({
      data: { path: "test.pdf" },
      error: null,
    });

    const files = [
      createTestFile("test1.pdf", "application/pdf"),
      createTestFile("test2.pdf", "application/pdf"),
    ];
    const input = screen.getByLabelText(/upload document/i);
    await fireEvent.change(input, { target: { files } });

    expect(mockSupabaseClient.storage.from().upload).toHaveBeenCalledTimes(2);
    expect(onUpload).toHaveBeenCalledTimes(2);
  });

  test("displays drag and drop zone", async () => {
    renderWithProviders(<DocumentUpload />);

    const dropzone = screen.getByText(/drag and drop/i);
    expect(dropzone).toBeInTheDocument();

    // Simulate drag events
    fireEvent.dragEnter(dropzone);
    expect(dropzone).toHaveClass("drag-active");

    fireEvent.dragLeave(dropzone);
    expect(dropzone).not.toHaveClass("drag-active");
  });

  test("handles file drop", async () => {
    const onUpload = vi.fn();
    const { mockSupabaseClient } = renderWithProviders(
      <DocumentUpload onUpload={onUpload} />,
    );

    mockSupabaseClient.storage.from().upload.mockResolvedValueOnce({
      data: { path: "test.pdf" },
      error: null,
    });

    const file = createTestFile("test.pdf", "application/pdf");
    const dropzone = screen.getByText(/drag and drop/i);

    // Simulate file drop
    const dropEvent = createEvent.drop(dropzone);
    Object.defineProperty(dropEvent, "dataTransfer", {
      value: {
        files: [file],
      },
    });
    fireEvent(dropzone, dropEvent);

    expect(mockSupabaseClient.storage.from().upload).toHaveBeenCalled();
    expect(onUpload).toHaveBeenCalled();
  });
});
```

### `src\__tests__\hooks\use-auth.test.tsx`

```tsx
import { renderHook, act } from "@testing-library/react";
import { useAuth } from "@/hooks/use-auth";
import { createClient } from "@/lib/supabase/browser";
import { toast } from "sonner";

// Mock dependencies
jest.mock("@/lib/supabase/browser");
jest.mock("next/navigation", () => ({
  useRouter: () => ({
    refresh: jest.fn(),
  }),
}));
jest.mock("sonner");

const mockSupabase = {
  auth: {
    getSession: jest.fn(),
    signInWithPassword: jest.fn(),
    signOut: jest.fn(),
    onAuthStateChange: jest.fn(() => ({
      data: {
        subscription: {
          unsubscribe: jest.fn(),
        },
      },
    })),
  },
};

const mockCreateClient = createClient as jest.MockedFunction<
  typeof createClient
>;
mockCreateClient.mockReturnValue(mockSupabase as any);

describe("useAuth", () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it("initializes with loading state and no user", async () => {
    mockSupabase.auth.getSession.mockResolvedValueOnce({
      data: { session: null },
    });

    const { result } = renderHook(() => useAuth());

    expect(result.current.loading).toBe(true);
    expect(result.current.user).toBe(null);
  });

  it("updates user when session is available", async () => {
    const mockUser = { id: "1", email: "test@example.com" };
    mockSupabase.auth.getSession.mockResolvedValueOnce({
      data: { session: { user: mockUser } },
    });

    const { result } = renderHook(() => useAuth());

    // Wait for state updates
    await act(async () => {
      await Promise.resolve();
    });

    expect(result.current.loading).toBe(false);
    expect(result.current.user).toEqual(mockUser);
  });

  it("handles sign in success", async () => {
    mockSupabase.auth.signInWithPassword.mockResolvedValueOnce({
      data: {},
      error: null,
    });

    const { result } = renderHook(() => useAuth());

    await act(async () => {
      await result.current.signIn("test@example.com", "password");
    });

    expect(mockSupabase.auth.signInWithPassword).toHaveBeenCalledWith({
      email: "test@example.com",
      password: "password",
    });
    expect(toast.error).not.toHaveBeenCalled();
  });

  it("handles sign in error", async () => {
    const error = new Error("Invalid credentials");
    mockSupabase.auth.signInWithPassword.mockRejectedValueOnce(error);

    const { result } = renderHook(() => useAuth());

    await act(async () => {
      await result.current.signIn("test@example.com", "password");
    });

    expect(toast.error).toHaveBeenCalledWith("Failed to sign in");
  });

  it("handles sign out success", async () => {
    mockSupabase.auth.signOut.mockResolvedValueOnce({
      error: null,
    });

    const { result } = renderHook(() => useAuth());

    await act(async () => {
      await result.current.signOut();
    });

    expect(mockSupabase.auth.signOut).toHaveBeenCalled();
    expect(toast.error).not.toHaveBeenCalled();
  });

  it("handles sign out error", async () => {
    const error = new Error("Sign out failed");
    mockSupabase.auth.signOut.mockRejectedValueOnce(error);

    const { result } = renderHook(() => useAuth());

    await act(async () => {
      await result.current.signOut();
    });

    expect(toast.error).toHaveBeenCalledWith("Failed to sign out");
  });
});
```

### `src\__tests__\integration\auth-flow.test.tsx`

```tsx
import { render, screen, fireEvent, waitFor } from "@testing-library/react";
import { UnifiedAuthProvider } from "@/providers/unified-auth-provider";
import { getBrowserClient } from "@/lib/supabase/browser-client";

// Mock fetch for API calls
global.fetch = jest.fn();

// Mock the browser client
jest.mock("@/lib/supabase/browser-client");

describe("Authentication Flow", () => {
  const mockFetch = global.fetch as jest.Mock;

  beforeEach(() => {
    mockFetch.mockClear();
    (getBrowserClient as jest.Mock).mockReturnValue({
      auth: {
        getSession: jest.fn().mockResolvedValue({
          data: { session: null },
          error: null,
        }),
        onAuthStateChange: jest.fn().mockReturnValue({
          data: { subscription: { unsubscribe: jest.fn() } },
        }),
      },
    });
  });

  it("handles sign out flow", async () => {
    // Mock successful sign out response
    mockFetch.mockResolvedValueOnce({
      ok: true,
      json: () => Promise.resolve({ success: true }),
    });

    render(
      <UnifiedAuthProvider>
        <TestAuthComponent />
      </UnifiedAuthProvider>,
    );

    // Wait for initial load
    await waitFor(() => {
      expect(screen.getByText("Sign Out")).toBeInTheDocument();
    });

    // Click sign out
    fireEvent.click(screen.getByText("Sign Out"));

    // Verify API call
    await waitFor(() => {
      expect(mockFetch).toHaveBeenCalledWith("/api/auth", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ action: "signOut" }),
      });
    });
  });

  it("handles session refresh", async () => {
    // Mock successful refresh response
    mockFetch.mockResolvedValueOnce({
      ok: true,
      json: () =>
        Promise.resolve({
          session: { user: { email: "test@example.com" } },
        }),
    });

    render(
      <UnifiedAuthProvider>
        <TestAuthComponent />
      </UnifiedAuthProvider>,
    );

    // Wait for initial load
    await waitFor(() => {
      expect(screen.getByText("Refresh Session")).toBeInTheDocument();
    });

    // Click refresh
    fireEvent.click(screen.getByText("Refresh Session"));

    // Verify API call
    await waitFor(() => {
      expect(mockFetch).toHaveBeenCalledWith("/api/auth", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ action: "refreshSession" }),
      });
    });
  });
});

// Test component
function TestAuthComponent() {
  const { signOut, refreshSession } = useAuth();
  return (
    <div>
      <button onClick={signOut}>Sign Out</button>
      <button onClick={refreshSession}>Refresh Session</button>
    </div>
  );
}
```

### `src\__tests__\integration\client-list.test.tsx`

```tsx
import { describe, expect, test, vi } from "vitest";
import { screen, waitFor } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import { ClientList } from "@/components/clients/client-list";
import { renderWithProviders } from "../setup/test-utils";
import { axe } from "jest-axe";

describe("ClientList Integration", () => {
  const mockClients = [
    {
      id: "1",
      full_name: "John Doe",
      company_name: "",
      contact_email: "john@example.com",
      status: "active",
      type: "individual",
      contact_info: {
        phone: "123-456-7890",
        address: "123 Main St",
      },
      tax_info: {
        tax_id: "123-45-6789",
        filing_status: "single",
        last_filed: "2023-12-31",
        next_deadline: "2024-04-15",
      },
      created_at: "2024-01-01",
      updated_at: "2024-01-01",
    },
    {
      id: "2",
      full_name: "",
      company_name: "ACME Inc",
      contact_email: "info@acme.com",
      status: "pending",
      type: "business",
      contact_info: {
        phone: "987-654-3210",
        address: "456 Corp Ave",
      },
      tax_info: {
        tax_id: "98-7654321",
        filing_status: "corporation",
        last_filed: "2023-12-31",
        next_deadline: "2024-03-15",
      },
      created_at: "2024-01-02",
      updated_at: "2024-01-02",
    },
  ];

  beforeEach(() => {
    vi.clearAllMocks();
  });

  test("renders loading state initially", async () => {
    const { mockSupabaseClient } = renderWithProviders(<ClientList />);

    // Mock a never-resolving promise to keep loading state
    mockSupabaseClient.from.mockReturnValueOnce({
      ...mockSupabaseClient.from(),
      select: vi.fn().mockImplementation(() => new Promise(() => {})),
    });

    expect(screen.getByText(/loading clients/i)).toBeInTheDocument();
  });

  test("renders client list after loading", async () => {
    const { mockSupabaseClient } = renderWithProviders(<ClientList />);

    mockSupabaseClient.from.mockReturnValueOnce({
      ...mockSupabaseClient.from(),
      select: vi.fn().mockResolvedValueOnce({
        data: mockClients,
        error: null,
      }),
    });

    // Wait for clients to load
    await waitFor(() => {
      expect(screen.getByText("John Doe")).toBeInTheDocument();
      expect(screen.getByText("ACME Inc")).toBeInTheDocument();
    });

    // Verify Supabase call
    expect(mockSupabaseClient.from).toHaveBeenCalledWith("clients");
    expect(mockSupabaseClient.from().select).toHaveBeenCalled();
  });

  test("handles client deletion", async () => {
    const { mockSupabaseClient, user } = renderWithProviders(<ClientList />);

    // Mock initial load
    mockSupabaseClient.from.mockReturnValueOnce({
      ...mockSupabaseClient.from(),
      select: vi.fn().mockResolvedValueOnce({
        data: mockClients,
        error: null,
      }),
    });

    // Mock deletion
    mockSupabaseClient.from.mockReturnValueOnce({
      ...mockSupabaseClient.from(),
      delete: vi.fn().mockResolvedValueOnce({
        data: null,
        error: null,
      }),
    });

    // Wait for clients to load
    await waitFor(() => {
      expect(screen.getByText("John Doe")).toBeInTheDocument();
    });

    // Click delete button for first client
    const deleteButton = screen.getAllByRole("button", { name: /delete/i })[0];
    await user.click(deleteButton);

    // Confirm deletion
    const confirmButton = screen.getByRole("button", { name: /confirm/i });
    await user.click(confirmButton);

    // Verify deletion call
    await waitFor(() => {
      expect(mockSupabaseClient.from).toHaveBeenCalledWith("clients");
      expect(mockSupabaseClient.from().delete).toHaveBeenCalledWith({
        id: mockClients[0].id,
      });
    });

    // Verify success message
    expect(
      await screen.findByText(/client deleted successfully/i),
    ).toBeInTheDocument();
  });

  test("handles error state", async () => {
    const { mockSupabaseClient } = renderWithProviders(<ClientList />);

    mockSupabaseClient.from.mockReturnValueOnce({
      ...mockSupabaseClient.from(),
      select: vi.fn().mockResolvedValueOnce({
        data: null,
        error: { message: "Failed to load clients" },
      }),
    });

    await waitFor(() => {
      expect(screen.getByText(/failed to load clients/i)).toBeInTheDocument();
    });
  });

  test("filters clients by search term", async () => {
    const { mockSupabaseClient, user } = renderWithProviders(<ClientList />);

    mockSupabaseClient.from.mockReturnValueOnce({
      ...mockSupabaseClient.from(),
      select: vi.fn().mockResolvedValueOnce({
        data: mockClients,
        error: null,
      }),
    });

    // Wait for clients to load
    await waitFor(() => {
      expect(screen.getByText("John Doe")).toBeInTheDocument();
      expect(screen.getByText("ACME Inc")).toBeInTheDocument();
    });

    // Type in search box
    const searchInput = screen.getByPlaceholderText(/search clients/i);
    await user.type(searchInput, "acme");

    // Verify filtered results
    expect(screen.queryByText("John Doe")).not.toBeInTheDocument();
    expect(screen.getByText("ACME Inc")).toBeInTheDocument();
  });

  // New test cases for edge conditions
  test("handles empty client list", async () => {
    const { mockSupabaseClient } = renderWithProviders(<ClientList />);

    mockSupabaseClient.from.mockReturnValueOnce({
      ...mockSupabaseClient.from(),
      select: vi.fn().mockResolvedValueOnce({
        data: [],
        error: null,
      }),
    });

    await waitFor(() => {
      expect(screen.getByText(/no clients found/i)).toBeInTheDocument();
    });
  });

  test("handles deletion error", async () => {
    const { mockSupabaseClient, user } = renderWithProviders(<ClientList />);

    // Mock initial load
    mockSupabaseClient.from.mockReturnValueOnce({
      ...mockSupabaseClient.from(),
      select: vi.fn().mockResolvedValueOnce({
        data: mockClients,
        error: null,
      }),
    });

    // Mock deletion error
    mockSupabaseClient.from.mockReturnValueOnce({
      ...mockSupabaseClient.from(),
      delete: vi.fn().mockResolvedValueOnce({
        data: null,
        error: { message: "Failed to delete client" },
      }),
    });

    // Wait for clients to load
    await waitFor(() => {
      expect(screen.getByText("John Doe")).toBeInTheDocument();
    });

    // Click delete button
    const deleteButton = screen.getAllByRole("button", { name: /delete/i })[0];
    await user.click(deleteButton);

    // Confirm deletion
    const confirmButton = screen.getByRole("button", { name: /confirm/i });
    await user.click(confirmButton);

    // Verify error message
    expect(
      await screen.findByText(/failed to delete client/i),
    ).toBeInTheDocument();
  });

  test("handles network error", async () => {
    const { mockSupabaseClient } = renderWithProviders(<ClientList />);

    mockSupabaseClient.from.mockReturnValueOnce({
      ...mockSupabaseClient.from(),
      select: vi.fn().mockRejectedValueOnce(new Error("Network error")),
    });

    await waitFor(() => {
      expect(screen.getByText(/error loading clients/i)).toBeInTheDocument();
    });
  });

  // Accessibility test
  test("is accessible", async () => {
    const { container, mockSupabaseClient } = renderWithProviders(
      <ClientList />,
    );

    mockSupabaseClient.from.mockReturnValueOnce({
      ...mockSupabaseClient.from(),
      select: vi.fn().mockResolvedValueOnce({
        data: mockClients,
        error: null,
      }),
    });

    // Wait for content to load
    await waitFor(() => {
      expect(screen.getByText("John Doe")).toBeInTheDocument();
    });

    const results = await axe(container);
    expect(results).toHaveNoViolations();
  });
});
```

### `src\__tests__\integration\client-workflow.test.tsx`

```tsx
import { describe, expect, test, vi } from "vitest";
import { screen, fireEvent, waitFor } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import { ClientWorkflow } from "@/components/clients/client-workflow";
import { renderWithProviders } from "../setup/test-utils";
import { mockSupabaseClient } from "../setup/test-utils";
import { clientFactory, projectFactory } from "../setup/factories";

vi.mock("@supabase/auth-helpers-nextjs", () => ({
  createServerComponentClient: () => mockSupabaseClient,
}));

describe("Client Management Workflow", () => {
  const user = userEvent.setup();

  beforeEach(() => {
    vi.clearAllMocks();
  });

  test("completes full client onboarding process", async () => {
    const testClient = clientFactory.build();
    const testProject = projectFactory.build({ clientId: testClient.id });

    mockSupabaseClient.from().insert.mockResolvedValueOnce({
      data: testClient,
      error: null,
    });

    mockSupabaseClient.from().insert.mockResolvedValueOnce({
      data: testProject,
      error: null,
    });

    renderWithProviders(<ClientWorkflow />);

    // Step 1: Create Client
    await user.click(screen.getByText("Add New Client"));
    await user.type(screen.getByLabelText("Full Name"), testClient.fullName);
    await user.type(screen.getByLabelText("Email"), testClient.email);
    await user.selectOptions(
      screen.getByLabelText("Business Type"),
      testClient.businessType,
    );
    await user.type(screen.getByLabelText("Phone"), testClient.phone);

    // Fill address
    await user.type(
      screen.getByLabelText("Street Address"),
      testClient.address.street,
    );
    await user.type(screen.getByLabelText("City"), testClient.address.city);
    await user.type(screen.getByLabelText("State"), testClient.address.state);
    await user.type(
      screen.getByLabelText("ZIP Code"),
      testClient.address.zipCode,
    );

    await user.click(screen.getByText("Next"));

    // Step 2: Upload Documents
    const file = new File(["test content"], "test.pdf", {
      type: "application/pdf",
    });
    const input = screen.getByLabelText("Upload Documents");
    await user.upload(input, file);

    await waitFor(() => {
      expect(
        screen.getByText("Document uploaded successfully"),
      ).toBeInTheDocument();
    });

    // Step 3: Create Project
    await user.click(screen.getByText("Create Tax Return Project"));
    await user.type(screen.getByLabelText("Project Name"), testProject.name);
    await user.selectOptions(
      screen.getByLabelText("Project Type"),
      testProject.type,
    );
    await user.click(screen.getByText("Create Project"));

    await waitFor(() => {
      expect(
        screen.getByText("Client onboarding completed"),
      ).toBeInTheDocument();
    });

    // Verify API calls
    expect(mockSupabaseClient.from().insert).toHaveBeenCalledWith(
      expect.objectContaining({
        fullName: testClient.fullName,
        email: testClient.email,
        businessType: testClient.businessType,
      }),
    );

    expect(mockSupabaseClient.from().insert).toHaveBeenCalledWith(
      expect.objectContaining({
        name: testProject.name,
        type: testProject.type,
        clientId: testClient.id,
      }),
    );
  });

  test("handles validation errors", async () => {
    renderWithProviders(<ClientWorkflow />);

    await user.click(screen.getByText("Add New Client"));
    await user.click(screen.getByText("Next"));

    await waitFor(() => {
      expect(screen.getByText("Full name is required")).toBeInTheDocument();
      expect(screen.getByText("Email is required")).toBeInTheDocument();
      expect(screen.getByText("Business type is required")).toBeInTheDocument();
    });
  });

  test("handles API errors gracefully", async () => {
    mockSupabaseClient.from().insert.mockResolvedValueOnce({
      data: null,
      error: new Error("Database error"),
    });

    renderWithProviders(<ClientWorkflow />);

    await user.click(screen.getByText("Add New Client"));
    await user.type(screen.getByLabelText("Full Name"), "Test Client");
    await user.type(screen.getByLabelText("Email"), "test@example.com");
    await user.selectOptions(
      screen.getByLabelText("Business Type"),
      "individual",
    );
    await user.click(screen.getByText("Next"));

    await waitFor(() => {
      expect(screen.getByText("Failed to create client")).toBeInTheDocument();
    });
  });

  test("allows navigation between steps", async () => {
    renderWithProviders(<ClientWorkflow />);

    // Navigate forward
    await user.click(screen.getByText("Add New Client"));
    expect(screen.getByText("Client Information")).toBeInTheDocument();

    await user.type(screen.getByLabelText("Full Name"), "Test Client");
    await user.type(screen.getByLabelText("Email"), "test@example.com");
    await user.selectOptions(
      screen.getByLabelText("Business Type"),
      "individual",
    );
    await user.click(screen.getByText("Next"));

    expect(screen.getByText("Document Upload")).toBeInTheDocument();

    // Navigate back
    await user.click(screen.getByText("Back"));
    expect(screen.getByText("Client Information")).toBeInTheDocument();

    // Verify form data is preserved
    expect(screen.getByLabelText("Full Name")).toHaveValue("Test Client");
    expect(screen.getByLabelText("Email")).toHaveValue("test@example.com");
    expect(screen.getByLabelText("Business Type")).toHaveValue("individual");
  });
});
```

### `src\__tests__\integration\project-templates.test.tsx`

```tsx
import { describe, expect, test, vi } from "vitest";
import { screen, waitFor } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import { ProjectTemplateWorkflow } from "@/components/projects/project-template-workflow";
import { renderWithProviders } from "../setup/test-utils";
import { mockSupabaseClient } from "../setup/test-utils";
import { projectFactory, clientFactory } from "../setup/factories";

vi.mock("@supabase/auth-helpers-nextjs", () => ({
  createServerComponentClient: () => mockSupabaseClient,
}));

describe("Project Template System", () => {
  const user = userEvent.setup();

  beforeEach(() => {
    vi.clearAllMocks();
  });

  test("creates project from tax return template", async () => {
    const testClient = clientFactory.build();
    const testProject = projectFactory.build({
      clientId: testClient.id,
      type: "tax_return",
    });

    mockSupabaseClient.from().select.mockResolvedValueOnce({
      data: [testClient],
      error: null,
    });

    mockSupabaseClient.from().insert.mockResolvedValueOnce({
      data: testProject,
      error: null,
    });

    renderWithProviders(<ProjectTemplateWorkflow />);

    // Select template
    await user.click(screen.getByText("Tax Return Project"));

    // Fill project details
    await user.type(screen.getByLabelText("Project Name"), testProject.name);
    await user.selectOptions(screen.getByLabelText("Client"), testClient.id);
    await user.type(screen.getByLabelText("Tax Year"), "2023");

    // Select services
    await user.click(screen.getByLabelText("Federal Tax Return"));
    await user.click(screen.getByLabelText("State Tax Return"));

    await user.click(screen.getByText("Create Project"));

    await waitFor(() => {
      expect(
        screen.getByText("Project created successfully"),
      ).toBeInTheDocument();
    });

    // Verify API calls
    expect(mockSupabaseClient.from().insert).toHaveBeenCalledWith(
      expect.objectContaining({
        name: testProject.name,
        client_id: testClient.id,
        type: "tax_return",
        metadata: expect.objectContaining({
          tax_year: "2023",
          services: ["federal_return", "state_return"],
        }),
      }),
    );
  });

  test("creates project from bookkeeping template", async () => {
    const testClient = clientFactory.build();
    const testProject = projectFactory.build({
      clientId: testClient.id,
      type: "bookkeeping",
    });

    mockSupabaseClient.from().select.mockResolvedValueOnce({
      data: [testClient],
      error: null,
    });

    mockSupabaseClient.from().insert.mockResolvedValueOnce({
      data: testProject,
      error: null,
    });

    renderWithProviders(<ProjectTemplateWorkflow />);

    // Select template
    await user.click(screen.getByText("Bookkeeping Project"));

    // Fill project details
    await user.type(screen.getByLabelText("Project Name"), testProject.name);
    await user.selectOptions(screen.getByLabelText("Client"), testClient.id);
    await user.selectOptions(screen.getByLabelText("Frequency"), "monthly");

    // Select services
    await user.click(screen.getByLabelText("Bank Reconciliation"));
    await user.click(screen.getByLabelText("Financial Statements"));

    await user.click(screen.getByText("Create Project"));

    await waitFor(() => {
      expect(
        screen.getByText("Project created successfully"),
      ).toBeInTheDocument();
    });

    // Verify template generated correct tasks
    expect(mockSupabaseClient.from().insert).toHaveBeenCalledWith(
      expect.arrayContaining([
        expect.objectContaining({
          title: "Monthly Bank Reconciliation",
          recurring: true,
          frequency: "monthly",
        }),
        expect.objectContaining({
          title: "Generate Financial Statements",
          recurring: true,
          frequency: "monthly",
        }),
      ]),
    );
  });

  test("validates required fields", async () => {
    renderWithProviders(<ProjectTemplateWorkflow />);

    await user.click(screen.getByText("Tax Return Project"));
    await user.click(screen.getByText("Create Project"));

    await waitFor(() => {
      expect(screen.getByText("Project name is required")).toBeInTheDocument();
      expect(screen.getByText("Client is required")).toBeInTheDocument();
      expect(screen.getByText("Tax year is required")).toBeInTheDocument();
    });
  });

  test("handles template customization", async () => {
    const testClient = clientFactory.build();
    const testProject = projectFactory.build({
      clientId: testClient.id,
      type: "advisory",
    });

    mockSupabaseClient.from().select.mockResolvedValueOnce({
      data: [testClient],
      error: null,
    });

    renderWithProviders(<ProjectTemplateWorkflow />);

    // Select template
    await user.click(screen.getByText("Advisory Project"));

    // Customize template
    await user.click(screen.getByText("Customize Template"));
    await user.click(screen.getByText("Add Task"));
    await user.type(
      screen.getByLabelText("Task Title"),
      "Custom Advisory Task",
    );
    await user.type(
      screen.getByLabelText("Description"),
      "Custom task description",
    );
    await user.click(screen.getByText("Save Task"));

    // Fill project details
    await user.type(screen.getByLabelText("Project Name"), testProject.name);
    await user.selectOptions(screen.getByLabelText("Client"), testClient.id);

    await user.click(screen.getByText("Create Project"));

    // Verify custom task was included
    expect(mockSupabaseClient.from().insert).toHaveBeenCalledWith(
      expect.arrayContaining([
        expect.objectContaining({
          title: "Custom Advisory Task",
          description: "Custom task description",
        }),
      ]),
    );
  });
});
```

### `src\__tests__\integration\task-management.test.tsx`

```tsx
import { describe, expect, test, vi } from "vitest";
import { screen, waitFor } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import { TaskManagement } from "@/components/tasks/task-management";
import { renderWithProviders } from "../setup/test-utils";
import { mockSupabaseClient } from "../setup/test-utils";
import { projectFactory, taskFactory } from "../setup/factories";

vi.mock("@supabase/auth-helpers-nextjs", () => ({
  createServerComponentClient: () => mockSupabaseClient,
}));

describe("Task Management", () => {
  const user = userEvent.setup();

  beforeEach(() => {
    vi.clearAllMocks();
  });

  test("creates and assigns tasks", async () => {
    const testProject = projectFactory.build();
    const testTask = taskFactory.build({ projectId: testProject.id });

    mockSupabaseClient.from().select.mockResolvedValueOnce({
      data: [testProject],
      error: null,
    });

    mockSupabaseClient.from().insert.mockResolvedValueOnce({
      data: testTask,
      error: null,
    });

    renderWithProviders(<TaskManagement projectId={testProject.id} />);

    // Create new task
    await user.click(screen.getByText("Add Task"));
    await user.type(screen.getByLabelText("Title"), testTask.title);
    await user.type(screen.getByLabelText("Description"), testTask.description);
    await user.selectOptions(
      screen.getByLabelText("Priority"),
      testTask.priority,
    );
    await user.selectOptions(
      screen.getByLabelText("Assignee"),
      testTask.assignee,
    );
    await user.type(screen.getByLabelText("Due Date"), testTask.dueDate);

    await user.click(screen.getByText("Save Task"));

    await waitFor(() => {
      expect(screen.getByText("Task created successfully")).toBeInTheDocument();
    });

    // Verify API call
    expect(mockSupabaseClient.from().insert).toHaveBeenCalledWith(
      expect.objectContaining({
        title: testTask.title,
        description: testTask.description,
        priority: testTask.priority,
        assignee: testTask.assignee,
        due_date: testTask.dueDate,
      }),
    );
  });

  test("updates task status", async () => {
    const testTask = taskFactory.build({ status: "todo" });

    mockSupabaseClient.from().select.mockResolvedValueOnce({
      data: [testTask],
      error: null,
    });

    mockSupabaseClient.from().update.mockResolvedValueOnce({
      data: { ...testTask, status: "in_progress" },
      error: null,
    });

    renderWithProviders(<TaskManagement projectId={testTask.projectId} />);

    // Drag task to in-progress column
    const taskElement = screen.getByTestId(`task-${testTask.id}`);
    const inProgressColumn = screen.getByTestId("column-in_progress");

    await user.dragAndDrop(taskElement, inProgressColumn);

    // Verify API call
    expect(mockSupabaseClient.from().update).toHaveBeenCalledWith(
      expect.objectContaining({
        status: "in_progress",
      }),
    );
  });

  test("handles recurring tasks", async () => {
    const testTask = taskFactory.build({
      recurring: true,
      frequency: "weekly",
    });

    mockSupabaseClient.from().select.mockResolvedValueOnce({
      data: [testTask],
      error: null,
    });

    renderWithProviders(<TaskManagement projectId={testTask.projectId} />);

    // Create recurring task
    await user.click(screen.getByText("Add Task"));
    await user.type(screen.getByLabelText("Title"), testTask.title);
    await user.click(screen.getByLabelText("Recurring Task"));
    await user.selectOptions(screen.getByLabelText("Frequency"), "weekly");
    await user.click(screen.getByText("Save Task"));

    // Verify recurring task settings
    expect(mockSupabaseClient.from().insert).toHaveBeenCalledWith(
      expect.objectContaining({
        recurring: true,
        frequency: "weekly",
        next_occurrence: expect.any(String),
      }),
    );
  });

  test("filters and sorts tasks", async () => {
    const tasks = [
      taskFactory.build({ priority: "high", status: "todo" }),
      taskFactory.build({ priority: "medium", status: "in_progress" }),
      taskFactory.build({ priority: "low", status: "completed" }),
    ];

    mockSupabaseClient.from().select.mockResolvedValueOnce({
      data: tasks,
      error: null,
    });

    renderWithProviders(<TaskManagement projectId={tasks[0].projectId} />);

    // Filter by status
    await user.selectOptions(screen.getByLabelText("Status"), "todo");
    expect(screen.getByText(tasks[0].title)).toBeInTheDocument();
    expect(screen.queryByText(tasks[1].title)).not.toBeInTheDocument();

    // Sort by priority
    await user.click(screen.getByText("Priority"));
    const taskElements = screen.getAllByTestId(/^task-/);
    expect(taskElements[0]).toHaveTextContent("high");
    expect(taskElements[taskElements.length - 1]).toHaveTextContent("low");
  });

  test("handles task dependencies", async () => {
    const parentTask = taskFactory.build();
    const dependentTask = taskFactory.build({
      projectId: parentTask.projectId,
      dependencies: [parentTask.id],
    });

    mockSupabaseClient.from().select.mockResolvedValueOnce({
      data: [parentTask],
      error: null,
    });

    renderWithProviders(<TaskManagement projectId={parentTask.projectId} />);

    // Create dependent task
    await user.click(screen.getByText("Add Task"));
    await user.type(screen.getByLabelText("Title"), dependentTask.title);
    await user.click(screen.getByText("Add Dependency"));
    await user.selectOptions(
      screen.getByLabelText("Dependent On"),
      parentTask.id,
    );
    await user.click(screen.getByText("Save Task"));

    // Verify dependency was set
    expect(mockSupabaseClient.from().insert).toHaveBeenCalledWith(
      expect.objectContaining({
        dependencies: [parentTask.id],
      }),
    );

    // Verify dependent task is locked until parent is complete
    const dependentTaskElement = screen.getByText(dependentTask.title);
    expect(dependentTaskElement).toHaveAttribute("aria-disabled", "true");
  });
});
```

### `src\__tests__\performance\document-upload.test.ts`

```ts
import { test, expect } from "@playwright/test";
import { clientFactory, documentFactory } from "../setup/factories";

test.describe("Document Upload Performance", () => {
  test.beforeEach(async ({ page }) => {
    await page.goto("/");
  });

  test("handles multiple concurrent uploads efficiently", async ({ page }) => {
    const client = clientFactory.build();
    const numFiles = 5;
    const maxUploadTime = 10000; // 10 seconds

    // Login as client
    await page.goto("/auth/login");
    await page.fill('[data-testid="email-input"]', client.email);
    await page.fill('[data-testid="password-input"]', "password123");
    await page.click('[data-testid="login-button"]');

    // Navigate to documents page
    await page.goto("/documents");

    // Create test files
    const files = Array.from({ length: numFiles }, (_, i) => ({
      name: `test-file-${i}.pdf`,
      mimeType: "application/pdf",
      buffer: Buffer.from(`Test content for file ${i}`),
    }));

    // Start timer
    const startTime = Date.now();

    // Upload files concurrently
    const fileInput = page.locator('input[type="file"]');
    await fileInput.setInputFiles(files);
    await page.click('[data-testid="upload-button"]');

    // Wait for all uploads to complete
    await page.waitForSelector('[data-testid="upload-complete"]', {
      timeout: maxUploadTime,
    });

    // Calculate total upload time
    const uploadTime = Date.now() - startTime;

    // Verify upload time is within acceptable range
    expect(uploadTime).toBeLessThan(maxUploadTime);

    // Verify all files were uploaded
    const uploadedFiles = await page
      .locator('[data-testid="document-item"]')
      .count();
    expect(uploadedFiles).toBe(numFiles);
  });

  test("handles large file uploads efficiently", async ({ page }) => {
    const client = clientFactory.build();
    const maxUploadTime = 20000; // 20 seconds
    const fileSize = 10 * 1024 * 1024; // 10MB

    // Login as client
    await page.goto("/auth/login");
    await page.fill('[data-testid="email-input"]', client.email);
    await page.fill('[data-testid="password-input"]', "password123");
    await page.click('[data-testid="login-button"]');

    // Navigate to documents page
    await page.goto("/documents");

    // Create large test file
    const largeFile = {
      name: "large-file.pdf",
      mimeType: "application/pdf",
      buffer: Buffer.alloc(fileSize),
    };

    // Start timer
    const startTime = Date.now();

    // Upload large file
    const fileInput = page.locator('input[type="file"]');
    await fileInput.setInputFiles(largeFile);
    await page.click('[data-testid="upload-button"]');

    // Wait for upload to complete
    await page.waitForSelector('[data-testid="upload-complete"]', {
      timeout: maxUploadTime,
    });

    // Calculate upload time
    const uploadTime = Date.now() - startTime;

    // Verify upload time is within acceptable range
    expect(uploadTime).toBeLessThan(maxUploadTime);

    // Verify file was uploaded successfully
    const uploadedFile = await page
      .locator('[data-testid="document-item"]')
      .first();
    expect(await uploadedFile.textContent()).toContain("large-file.pdf");
  });

  test("maintains responsiveness during uploads", async ({ page }) => {
    const client = clientFactory.build();
    const numFiles = 3;
    const maxResponseTime = 1000; // 1 second

    // Login as client
    await page.goto("/auth/login");
    await page.fill('[data-testid="email-input"]', client.email);
    await page.fill('[data-testid="password-input"]', "password123");
    await page.click('[data-testid="login-button"]');

    // Navigate to documents page
    await page.goto("/documents");

    // Create test files
    const files = Array.from({ length: numFiles }, (_, i) => ({
      name: `test-file-${i}.pdf`,
      mimeType: "application/pdf",
      buffer: Buffer.alloc(5 * 1024 * 1024), // 5MB each
    }));

    // Start uploads
    const fileInput = page.locator('input[type="file"]');
    await fileInput.setInputFiles(files);
    await page.click('[data-testid="upload-button"]');

    // Test UI responsiveness during upload
    const navigationStart = Date.now();
    await page.click('[data-testid="nav-clients"]');
    const navigationTime = Date.now() - navigationStart;

    // Verify navigation time is within acceptable range
    expect(navigationTime).toBeLessThan(maxResponseTime);

    // Return to documents page
    await page.goto("/documents");

    // Wait for uploads to complete
    await page.waitForSelector('[data-testid="upload-complete"]');

    // Verify all files were uploaded
    const uploadedFiles = await page
      .locator('[data-testid="document-item"]')
      .count();
    expect(uploadedFiles).toBe(numFiles);
  });

  test("handles upload cancellation gracefully", async ({ page }) => {
    const client = clientFactory.build();
    const fileSize = 20 * 1024 * 1024; // 20MB

    // Login as client
    await page.goto("/auth/login");
    await page.fill('[data-testid="email-input"]', client.email);
    await page.fill('[data-testid="password-input"]', "password123");
    await page.click('[data-testid="login-button"]');

    // Navigate to documents page
    await page.goto("/documents");

    // Create large test file
    const largeFile = {
      name: "large-file.pdf",
      mimeType: "application/pdf",
      buffer: Buffer.alloc(fileSize),
    };

    // Start upload
    const fileInput = page.locator('input[type="file"]');
    await fileInput.setInputFiles(largeFile);
    await page.click('[data-testid="upload-button"]');

    // Wait for upload progress indicator
    await page.waitForSelector('[data-testid="upload-progress"]');

    // Cancel upload
    await page.click('[data-testid="cancel-upload"]');

    // Verify upload was cancelled
    await expect(
      page.locator('[data-testid="upload-cancelled"]'),
    ).toBeVisible();

    // Verify no partial files were created
    const uploadedFiles = await page
      .locator('[data-testid="document-item"]')
      .count();
    expect(uploadedFiles).toBe(0);

    // Verify system resources were cleaned up
    await expect(
      page.locator('[data-testid="upload-progress"]'),
    ).not.toBeVisible();
  });

  test("recovers from network interruptions", async ({ page, context }) => {
    const client = clientFactory.build();
    const fileSize = 15 * 1024 * 1024; // 15MB

    // Login as client
    await page.goto("/auth/login");
    await page.fill('[data-testid="email-input"]', client.email);
    await page.fill('[data-testid="password-input"]', "password123");
    await page.click('[data-testid="login-button"]');

    // Navigate to documents page
    await page.goto("/documents");

    // Create test file
    const testFile = {
      name: "test-file.pdf",
      mimeType: "application/pdf",
      buffer: Buffer.alloc(fileSize),
    };

    // Start upload
    const fileInput = page.locator('input[type="file"]');
    await fileInput.setInputFiles(testFile);
    await page.click('[data-testid="upload-button"]');

    // Wait for upload to start
    await page.waitForSelector('[data-testid="upload-progress"]');

    // Simulate network interruption
    await context.setOffline(true);
    await page.waitForTimeout(1000);
    await context.setOffline(false);

    // Verify upload automatically resumes
    await page.waitForSelector('[data-testid="upload-complete"]');

    // Verify file was uploaded successfully
    const uploadedFile = await page
      .locator('[data-testid="document-item"]')
      .first();
    expect(await uploadedFile.textContent()).toContain("test-file.pdf");
  });
});
```

### `src\__tests__\providers\unified-auth-provider.test.tsx`

```tsx
import { render, act, screen, waitFor } from "@testing-library/react";
import {
  UnifiedAuthProvider,
  useAuth,
} from "@/providers/unified-auth-provider";
import { getBrowserClient } from "@/lib/supabase/browser-client";

// Mock the browser client
jest.mock("@/lib/supabase/browser-client");

const mockBrowserClient = {
  auth: {
    getSession: jest.fn(),
    onAuthStateChange: jest.fn(),
  },
};

// Mock component to test the hook
function TestComponent() {
  const { user, loading, error } = useAuth();
  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;
  return <div>User: {user?.email || "Not logged in"}</div>;
}

describe("UnifiedAuthProvider", () => {
  beforeEach(() => {
    (getBrowserClient as jest.Mock).mockReturnValue(mockBrowserClient);
    mockBrowserClient.auth.getSession.mockResolvedValue({
      data: { session: null },
      error: null,
    });
    mockBrowserClient.auth.onAuthStateChange.mockReturnValue({
      data: { subscription: { unsubscribe: jest.fn() } },
    });
  });

  it("provides initial loading state", () => {
    render(
      <UnifiedAuthProvider>
        <TestComponent />
      </UnifiedAuthProvider>,
    );
    expect(screen.getByText("Loading...")).toBeInTheDocument();
  });

  it("handles successful session", async () => {
    const mockSession = {
      user: { email: "test@example.com" },
    };

    mockBrowserClient.auth.getSession.mockResolvedValueOnce({
      data: { session: mockSession },
      error: null,
    });

    render(
      <UnifiedAuthProvider>
        <TestComponent />
      </UnifiedAuthProvider>,
    );

    await waitFor(() => {
      expect(screen.getByText("User: test@example.com")).toBeInTheDocument();
    });
  });

  it("handles session error", async () => {
    mockBrowserClient.auth.getSession.mockResolvedValueOnce({
      data: { session: null },
      error: new Error("Auth error"),
    });

    render(
      <UnifiedAuthProvider>
        <TestComponent />
      </UnifiedAuthProvider>,
    );

    await waitFor(() => {
      expect(screen.getByText("Error: Auth error")).toBeInTheDocument();
    });
  });

  it("updates on auth state change", async () => {
    render(
      <UnifiedAuthProvider>
        <TestComponent />
      </UnifiedAuthProvider>,
    );

    // Simulate auth state change
    await act(async () => {
      const callback =
        mockBrowserClient.auth.onAuthStateChange.mock.calls[0][0];
      callback("SIGNED_IN", {
        user: { email: "updated@example.com" },
      });
    });

    await waitFor(() => {
      expect(screen.getByText("User: updated@example.com")).toBeInTheDocument();
    });
  });
});
```

### `src\__tests__\security\authentication.test.ts`

```ts
import { test, expect } from "@playwright/test";
import { mockSupabaseClient } from "../setup/test-utils";

test.describe("Authentication Security", () => {
  test.beforeEach(async ({ page }) => {
    await page.goto("/");
  });

  test("redirects unauthenticated users to login page", async ({ page }) => {
    await page.goto("/clients");
    await expect(page).toHaveURL("/auth/login");
  });

  test("prevents access to protected routes without authentication", async ({
    page,
    request,
  }) => {
    const response = await request.get("/api/clients");
    expect(response.status()).toBe(401);
  });

  test("handles session expiration", async ({ page }) => {
    // Login
    await page.goto("/auth/login");
    await page.fill('[data-testid="email-input"]', "test@example.com");
    await page.fill('[data-testid="password-input"]', "password123");
    await page.click('[data-testid="login-button"]');

    // Clear session storage
    await page.evaluate(() => window.sessionStorage.clear());

    // Attempt to access protected route
    await page.goto("/clients");
    await expect(page).toHaveURL("/auth/login");
  });

  test("enforces password complexity requirements", async ({ page }) => {
    await page.goto("/auth/signup");

    // Test weak password
    await page.fill('[data-testid="email-input"]', "test@example.com");
    await page.fill('[data-testid="password-input"]', "weak");
    await page.click('[data-testid="signup-button"]');

    await expect(page.locator('[data-testid="password-error"]')).toContainText(
      "Password must be at least 8 characters",
    );

    // Test password without special characters
    await page.fill('[data-testid="password-input"]', "password123");
    await page.click('[data-testid="signup-button"]');

    await expect(page.locator('[data-testid="password-error"]')).toContainText(
      "Password must contain at least one special character",
    );
  });

  test("prevents brute force attacks", async ({ page }) => {
    await page.goto("/auth/login");

    // Attempt multiple failed logins
    for (let i = 0; i < 5; i++) {
      await page.fill('[data-testid="email-input"]', "test@example.com");
      await page.fill('[data-testid="password-input"]', "wrongpassword");
      await page.click('[data-testid="login-button"]');
    }

    // Verify account is temporarily locked
    await expect(page.locator('[data-testid="error-message"]')).toContainText(
      "Account temporarily locked",
    );
  });

  test("implements secure session management", async ({ page, context }) => {
    // Login
    await page.goto("/auth/login");
    await page.fill('[data-testid="email-input"]', "test@example.com");
    await page.fill('[data-testid="password-input"]', "password123");
    await page.click('[data-testid="login-button"]');

    // Get session cookie
    const cookies = await context.cookies();
    const sessionCookie = cookies.find(
      (cookie) => cookie.name === "sb-auth-token",
    );

    expect(sessionCookie).toBeDefined();
    expect(sessionCookie?.secure).toBe(true);
    expect(sessionCookie?.httpOnly).toBe(true);
    expect(sessionCookie?.sameSite).toBe("Lax");
  });

  test("enforces CSRF protection", async ({ page, request }) => {
    // Login
    await page.goto("/auth/login");
    await page.fill('[data-testid="email-input"]', "test@example.com");
    await page.fill('[data-testid="password-input"]', "password123");
    await page.click('[data-testid="login-button"]');

    // Attempt request without CSRF token
    const response = await request.post("/api/clients", {
      data: {
        name: "Test Client",
      },
    });

    expect(response.status()).toBe(403);
    expect(await response.text()).toContain("CSRF token missing or invalid");
  });

  test("implements secure password reset flow", async ({ page }) => {
    await page.goto("/auth/forgot-password");

    // Request password reset
    await page.fill('[data-testid="email-input"]', "test@example.com");
    await page.click('[data-testid="reset-button"]');

    // Verify reset email is sent
    await expect(page.locator('[data-testid="success-message"]')).toContainText(
      "Password reset instructions sent",
    );

    // Verify reset token expiration
    const expiredToken = "expired-token";
    await page.goto(`/auth/reset-password?token=${expiredToken}`);
    await expect(page.locator('[data-testid="error-message"]')).toContainText(
      "Password reset link has expired",
    );
  });

  test("enforces secure logout", async ({ page, context }) => {
    // Login
    await page.goto("/auth/login");
    await page.fill('[data-testid="email-input"]', "test@example.com");
    await page.fill('[data-testid="password-input"]', "password123");
    await page.click('[data-testid="login-button"]');

    // Logout
    await page.click('[data-testid="logout-button"]');

    // Verify session is cleared
    const cookies = await context.cookies();
    const sessionCookie = cookies.find(
      (cookie) => cookie.name === "sb-auth-token",
    );
    expect(sessionCookie).toBeUndefined();

    // Verify redirect to login page
    await expect(page).toHaveURL("/auth/login");
  });
});
```

### `src\__tests__\security\file-access.test.ts`

```ts
import { test, expect } from "@playwright/test";
import { mockSupabaseClient } from "../setup/test-utils";
import { clientFactory, documentFactory } from "../setup/factories";

test.describe("File Access Security", () => {
  test.beforeEach(async ({ page }) => {
    await page.goto("/");
  });

  test("prevents unauthorized file access", async ({ request }) => {
    // Attempt to access file without authentication
    const response = await request.get("/api/documents/123/download");
    expect(response.status()).toBe(401);
  });

  test("enforces client-document relationship", async ({ page, request }) => {
    const client1 = clientFactory.build();
    const client2 = clientFactory.build();
    const document = documentFactory.build({ clientId: client1.id });

    // Login as client2
    await page.goto("/auth/login");
    await page.fill('[data-testid="email-input"]', client2.email);
    await page.fill('[data-testid="password-input"]', "password123");
    await page.click('[data-testid="login-button"]');

    // Attempt to access document belonging to client1
    const response = await request.get(
      `/api/documents/${document.id}/download`,
    );
    expect(response.status()).toBe(403);
  });

  test("validates file upload permissions", async ({ page }) => {
    const client = clientFactory.build();

    // Login as client
    await page.goto("/auth/login");
    await page.fill('[data-testid="email-input"]', client.email);
    await page.fill('[data-testid="password-input"]', "password123");
    await page.click('[data-testid="login-button"]');

    // Navigate to documents page
    await page.goto("/documents");

    // Attempt to upload file with invalid type
    const fileInput = page.locator('input[type="file"]');
    await fileInput.setInputFiles({
      name: "malicious.exe",
      mimeType: "application/x-msdownload",
      buffer: Buffer.from("fake executable content"),
    });

    await expect(page.locator('[data-testid="error-message"]')).toContainText(
      "Invalid file type",
    );
  });

  test("enforces file size limits", async ({ page }) => {
    const client = clientFactory.build();

    // Login as client
    await page.goto("/auth/login");
    await page.fill('[data-testid="email-input"]', client.email);
    await page.fill('[data-testid="password-input"]', "password123");
    await page.click('[data-testid="login-button"]');

    // Navigate to documents page
    await page.goto("/documents");

    // Attempt to upload large file
    const fileInput = page.locator('input[type="file"]');
    await fileInput.setInputFiles({
      name: "large.pdf",
      mimeType: "application/pdf",
      buffer: Buffer.alloc(25 * 1024 * 1024), // 25MB file
    });

    await expect(page.locator('[data-testid="error-message"]')).toContainText(
      "File size exceeds limit",
    );
  });

  test("implements secure file deletion", async ({ page, request }) => {
    const client = clientFactory.build();
    const document = documentFactory.build({ clientId: client.id });

    // Login as client
    await page.goto("/auth/login");
    await page.fill('[data-testid="email-input"]', client.email);
    await page.fill('[data-testid="password-input"]', "password123");
    await page.click('[data-testid="login-button"]');

    // Delete document
    const deleteResponse = await request.delete(
      `/api/documents/${document.id}`,
    );
    expect(deleteResponse.status()).toBe(200);

    // Verify file is no longer accessible
    const getResponse = await request.get(
      `/api/documents/${document.id}/download`,
    );
    expect(getResponse.status()).toBe(404);
  });

  test("enforces file access audit logging", async ({ page, request }) => {
    const client = clientFactory.build();
    const document = documentFactory.build({ clientId: client.id });

    // Login as client
    await page.goto("/auth/login");
    await page.fill('[data-testid="email-input"]', client.email);
    await page.fill('[data-testid="password-input"]', "password123");
    await page.click('[data-testid="login-button"]');

    // Access document
    await request.get(`/api/documents/${document.id}/download`);

    // Verify audit log entry
    const auditResponse = await request.get("/api/audit-logs", {
      params: {
        documentId: document.id,
        action: "download",
      },
    });

    expect(auditResponse.status()).toBe(200);
    const auditLog = await auditResponse.json();
    expect(auditLog).toContainEqual(
      expect.objectContaining({
        documentId: document.id,
        userId: client.id,
        action: "download",
      }),
    );
  });

  test("prevents concurrent file modifications", async ({ page, context }) => {
    const client = clientFactory.build();
    const document = documentFactory.build({ clientId: client.id });

    // Create two browser contexts
    const context2 = await context.browser().newContext();
    const page2 = await context2.newPage();

    // Login on both contexts
    for (const p of [page, page2]) {
      await p.goto("/auth/login");
      await p.fill('[data-testid="email-input"]', client.email);
      await p.fill('[data-testid="password-input"]', "password123");
      await p.click('[data-testid="login-button"]');
    }

    // Attempt concurrent modifications
    const [response1, response2] = await Promise.all([
      page.request.put(`/api/documents/${document.id}`, {
        data: { name: "Updated by user 1" },
      }),
      page2.request.put(`/api/documents/${document.id}`, {
        data: { name: "Updated by user 2" },
      }),
    ]);

    // One request should succeed, one should fail with conflict
    expect([response1.status(), response2.status()].includes(409)).toBe(true);
  });

  test("enforces file versioning", async ({ page, request }) => {
    const client = clientFactory.build();
    const document = documentFactory.build({ clientId: client.id });

    // Login as client
    await page.goto("/auth/login");
    await page.fill('[data-testid="email-input"]', client.email);
    await page.fill('[data-testid="password-input"]', "password123");
    await page.click('[data-testid="login-button"]');

    // Update document multiple times
    for (let i = 1; i <= 3; i++) {
      await request.put(`/api/documents/${document.id}`, {
        data: { content: `Version ${i}` },
      });
    }

    // Get version history
    const versionsResponse = await request.get(
      `/api/documents/${document.id}/versions`,
    );
    expect(versionsResponse.status()).toBe(200);
    const versions = await versionsResponse.json();
    expect(versions).toHaveLength(3);
  });
});
```

### `src\__tests__\setup\factories.ts`

```ts
import { Factory } from "fishery";
import { faker } from "@faker-js/faker";
import type { Client, Project, Document, Task } from "@/types";

export const clientFactory = Factory.define<Client>(() => ({
  id: faker.string.uuid(),
  fullName: faker.person.fullName(),
  email: faker.internet.email(),
  businessType: faker.helpers.arrayElement(["individual", "llc", "s_corp"]),
  phone: faker.phone.number(),
  address: {
    street: faker.location.streetAddress(),
    city: faker.location.city(),
    state: faker.location.state(),
    zipCode: faker.location.zipCode(),
  },
  createdAt: faker.date.recent().toISOString(),
  updatedAt: faker.date.recent().toISOString(),
}));

export const projectFactory = Factory.define<Project>(() => ({
  id: faker.string.uuid(),
  clientId: faker.string.uuid(),
  name: faker.company.name(),
  description: faker.lorem.sentence(),
  status: faker.helpers.arrayElement(["active", "completed", "on_hold"]),
  startDate: faker.date.recent().toISOString(),
  dueDate: faker.date.future().toISOString(),
  type: faker.helpers.arrayElement(["tax_return", "bookkeeping", "advisory"]),
  createdAt: faker.date.recent().toISOString(),
  updatedAt: faker.date.recent().toISOString(),
}));

export const documentFactory = Factory.define<Document>(() => ({
  id: faker.string.uuid(),
  project_id: faker.string.uuid(),
  client_id: faker.string.uuid(),
  name: faker.system.fileName(),
  storage_path: faker.system.filePath(),
  category: faker.helpers.arrayElement([
    "tax_return",
    "financial_statement",
    "payroll",
    "corporate",
    "supporting",
  ]),
  type: "application/pdf",
  size: faker.number.int({ min: 1000, max: 10000000 }),
  year: faker.date.recent().getFullYear(),
  description: faker.lorem.sentence(),
  uploaded_at: faker.date.recent().toISOString(),
  uploaded_by: faker.string.uuid(),
  status: faker.helpers.arrayElement(["pending", "approved", "rejected"]),
  metadata: {
    tax_year: faker.date.recent().getFullYear(),
    form_type: faker.helpers.arrayElement(["1040", "W2", "1099", "941"]),
    business_type: faker.helpers.arrayElement(["individual", "llc", "s_corp"]),
    quarter: faker.number.int({ min: 1, max: 4 }),
    month: faker.number.int({ min: 1, max: 12 }),
  },
}));

export const taskFactory = Factory.define<Task>(() => ({
  id: faker.string.uuid(),
  projectId: faker.string.uuid(),
  title: faker.lorem.sentence(),
  description: faker.lorem.paragraph(),
  status: faker.helpers.arrayElement(["todo", "in_progress", "completed"]),
  priority: faker.helpers.arrayElement(["low", "medium", "high"]),
  assignee: faker.string.uuid(),
  dueDate: faker.date.future().toISOString(),
  createdAt: faker.date.recent().toISOString(),
  updatedAt: faker.date.recent().toISOString(),
}));
```

### `src\__tests__\setup\setup.ts`

```ts
import "@testing-library/jest-dom";
import { expect, afterEach, vi } from "vitest";
import { cleanup } from "@testing-library/react";
import matchers from "@testing-library/jest-dom/matchers";
import { configureAxe } from "jest-axe";

// Extend Vitest's expect method with methods from react-testing-library
expect.extend(matchers);

// Configure axe for accessibility testing
const axe = configureAxe({
  rules: {
    // Add any custom rules here
  },
});

// Cleanup after each test case (e.g., clearing jsdom)
afterEach(() => {
  cleanup();
  vi.clearAllMocks();
  vi.clearAllTimers();
});

// Mock timers for async operations
beforeEach(() => {
  vi.useFakeTimers();
});

afterEach(() => {
  vi.useRealTimers();
});

// Mock IntersectionObserver
const mockIntersectionObserver = vi.fn();
mockIntersectionObserver.mockReturnValue({
  observe: vi.fn(),
  unobserve: vi.fn(),
  disconnect: vi.fn(),
});
window.IntersectionObserver = mockIntersectionObserver;

// Mock ResizeObserver
window.ResizeObserver = vi.fn().mockImplementation(() => ({
  observe: vi.fn(),
  unobserve: vi.fn(),
  disconnect: vi.fn(),
}));

// Mock window.fetch
window.fetch = vi.fn();

// Mock window.matchMedia
window.matchMedia = vi.fn().mockImplementation((query) => ({
  matches: false,
  media: query,
  onchange: null,
  addListener: vi.fn(),
  removeListener: vi.fn(),
  addEventListener: vi.fn(),
  removeEventListener: vi.fn(),
  dispatchEvent: vi.fn(),
}));

// Export axe for use in tests
export { axe };
```

### `src\__tests__\setup\test-setup.ts`

```ts
import "@testing-library/jest-dom";
import { expect, afterEach, vi } from "vitest";
import { cleanup } from "@testing-library/react";
import matchers from "@testing-library/jest-dom/matchers";

// Extend Vitest's expect method with methods from react-testing-library
expect.extend(matchers);

// Cleanup after each test case (e.g., clearing jsdom)
afterEach(() => {
  cleanup();
  vi.clearAllMocks();
  vi.clearAllTimers();
});

// Mock timers for async operations
beforeEach(() => {
  vi.useFakeTimers();
});

afterEach(() => {
  vi.useRealTimers();
});

// Mock IntersectionObserver
const mockIntersectionObserver = vi.fn();
mockIntersectionObserver.mockReturnValue({
  observe: vi.fn(),
  unobserve: vi.fn(),
  disconnect: vi.fn(),
});
window.IntersectionObserver = mockIntersectionObserver;

// Mock ResizeObserver
window.ResizeObserver = vi.fn().mockImplementation(() => ({
  observe: vi.fn(),
  unobserve: vi.fn(),
  disconnect: vi.fn(),
}));

// Mock window.fetch
window.fetch = vi.fn();

// Mock window.matchMedia
window.matchMedia = vi.fn().mockImplementation((query) => ({
  matches: false,
  media: query,
  onchange: null,
  addListener: vi.fn(),
  removeListener: vi.fn(),
  addEventListener: vi.fn(),
  removeEventListener: vi.fn(),
  dispatchEvent: vi.fn(),
}));
```

### `src\__tests__\setup\test-utils.tsx`

```tsx
import React from "react";
import { render } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import { FormProvider, useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { clientFormSchema } from "@/lib/validations/client";
import { ToastProvider } from "@/components/ui/toast";
import { vi } from "vitest";

// Create a more robust mock Supabase client
export const mockSupabaseClient = {
  from: vi.fn().mockReturnValue({
    select: vi.fn().mockResolvedValue({ data: [], error: null }),
    insert: vi.fn().mockResolvedValue({ data: null, error: null }),
    update: vi.fn().mockResolvedValue({ data: null, error: null }),
    delete: vi.fn().mockResolvedValue({ data: null, error: null }),
  }),
};

// Mock Supabase client
vi.mock("@supabase/auth-helpers-react", () => ({
  useSupabaseClient: () => mockSupabaseClient,
}));

// Helper function to create test files
export const createTestFile = (
  name: string,
  type = "application/pdf",
): File => {
  return new File(["test"], name, { type });
};

// Helper function to simulate drag and drop
export const simulateDragDrop = (element: Element, file: File) => {
  const dropEvent = new Event("drop", { bubbles: true });
  Object.defineProperty(dropEvent, "dataTransfer", {
    value: {
      files: [file],
      types: ["Files"],
    },
  });
  element.dispatchEvent(dropEvent);
};

// Helper function to render with form context
export const renderWithForm = (ui: React.ReactElement) => {
  const Wrapper = ({ children }: { children: React.ReactNode }) => {
    const form = useForm({
      resolver: zodResolver(clientFormSchema),
      defaultValues: {
        full_name: "",
        company_name: "",
        contact_email: "",
        onboarding_notes: "",
        status: "pending",
        type: "individual",
        contact_details: {
          phone: "",
          address: "",
          city: "",
          state: "",
          zip: "",
        },
        tax_info: {
          filing_status: "",
          tax_id: "",
          tax_year: new Date().getFullYear(),
          filing_type: null,
          tax_id_type: null,
          dependents: [],
          previous_returns: [],
        },
      },
    });
    return (
      <FormProvider {...form}>
        <ToastProvider>{children}</ToastProvider>
      </FormProvider>
    );
  };

  return {
    user: userEvent.setup(),
    mockSupabaseClient,
    ...render(ui, {
      wrapper: Wrapper,
    }),
  };
};

// Helper function to render with providers
export const renderWithProviders = (ui: React.ReactElement) => {
  return {
    user: userEvent.setup(),
    mockSupabaseClient,
    ...render(ui, {
      wrapper: ({ children }) => <ToastProvider>{children}</ToastProvider>,
    }),
  };
};
```

### `src\__tests__\tasks\task-board.test.tsx`

```tsx
import { describe, expect, test, vi } from "vitest";
import { screen, within } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import { TaskBoard } from "@/components/tasks/task-board";
import { renderWithProviders, simulateDragDrop } from "../setup/test-utils";

describe("TaskBoard", () => {
  const user = userEvent.setup();
  const mockTasks = [
    {
      id: "1",
      title: "Review Tax Return",
      status: "todo",
      assignee: "user1",
      priority: "high",
      dueDate: "2024-01-20",
    },
    {
      id: "2",
      title: "Update Client Info",
      status: "in_progress",
      assignee: "user2",
      priority: "medium",
      dueDate: "2024-01-25",
    },
  ];

  beforeEach(() => {
    vi.clearAllMocks();
  });

  test("renders tasks in correct columns", () => {
    renderWithProviders(<TaskBoard tasks={mockTasks} />);

    const todoColumn = screen.getByTestId("column-todo");
    expect(
      within(todoColumn).getByText("Review Tax Return"),
    ).toBeInTheDocument();

    const inProgressColumn = screen.getByTestId("column-in_progress");
    expect(
      within(inProgressColumn).getByText("Update Client Info"),
    ).toBeInTheDocument();
  });

  test("handles task status updates via drag and drop", async () => {
    const onTaskUpdate = vi.fn();
    renderWithProviders(
      <TaskBoard tasks={mockTasks} onTaskUpdate={onTaskUpdate} />,
    );

    const task = screen.getByTestId("task-1");
    const targetColumn = screen.getByTestId("column-in_progress");

    await simulateDragDrop(task, targetColumn);

    expect(onTaskUpdate).toHaveBeenCalledWith({
      id: "1",
      status: "in_progress",
    });
  });

  test("filters tasks by assignee", async () => {
    renderWithProviders(<TaskBoard tasks={mockTasks} />);

    await user.selectOptions(
      screen.getByLabelText(/filter by assignee/i),
      "user1",
    );

    expect(screen.getByText("Review Tax Return")).toBeInTheDocument();
    expect(screen.queryByText("Update Client Info")).not.toBeInTheDocument();
  });

  test("filters tasks by priority", async () => {
    renderWithProviders(<TaskBoard tasks={mockTasks} />);

    await user.selectOptions(
      screen.getByLabelText(/filter by priority/i),
      "high",
    );

    expect(screen.getByText("Review Tax Return")).toBeInTheDocument();
    expect(screen.queryByText("Update Client Info")).not.toBeInTheDocument();
  });

  test("sorts tasks by due date", async () => {
    renderWithProviders(<TaskBoard tasks={mockTasks} />);

    await user.click(screen.getByText(/due date/i));

    const tasks = screen.getAllByTestId(/^task-/);
    expect(within(tasks[0]).getByText("Review Tax Return")).toBeInTheDocument();
    expect(
      within(tasks[1]).getByText("Update Client Info"),
    ).toBeInTheDocument();
  });

  test("opens task details on click", async () => {
    renderWithProviders(<TaskBoard tasks={mockTasks} />);

    await user.click(screen.getByText("Review Tax Return"));

    expect(screen.getByRole("dialog")).toBeInTheDocument();
    expect(screen.getByText(/task details/i)).toBeInTheDocument();
  });

  test("creates new task", async () => {
    const onTaskCreate = vi.fn();
    renderWithProviders(
      <TaskBoard tasks={mockTasks} onTaskCreate={onTaskCreate} />,
    );

    await user.click(screen.getByText(/add task/i));
    await user.type(screen.getByLabelText(/title/i), "New Task");
    await user.selectOptions(screen.getByLabelText(/assignee/i), "user1");
    await user.selectOptions(screen.getByLabelText(/priority/i), "high");
    await user.type(screen.getByLabelText(/due date/i), "2024-02-01");
    await user.click(screen.getByText(/save/i));

    expect(onTaskCreate).toHaveBeenCalledWith(
      expect.objectContaining({
        title: "New Task",
        assignee: "user1",
        priority: "high",
        dueDate: "2024-02-01",
      }),
    );
  });

  test("updates task details", async () => {
    const onTaskUpdate = vi.fn();
    renderWithProviders(
      <TaskBoard tasks={mockTasks} onTaskUpdate={onTaskUpdate} />,
    );

    await user.click(screen.getByText("Review Tax Return"));
    await user.type(screen.getByLabelText(/title/i), " Updated");
    await user.click(screen.getByText(/save/i));

    expect(onTaskUpdate).toHaveBeenCalledWith(
      expect.objectContaining({
        id: "1",
        title: "Review Tax Return Updated",
      }),
    );
  });

  test("deletes task", async () => {
    const onTaskDelete = vi.fn();
    renderWithProviders(
      <TaskBoard tasks={mockTasks} onTaskDelete={onTaskDelete} />,
    );

    await user.click(screen.getByText("Review Tax Return"));
    await user.click(screen.getByText(/delete/i));
    await user.click(screen.getByText(/confirm/i));

    expect(onTaskDelete).toHaveBeenCalledWith("1");
  });

  test("displays empty state", () => {
    renderWithProviders(<TaskBoard tasks={[]} />);

    expect(screen.getByText(/no tasks/i)).toBeInTheDocument();
  });

  test("handles loading state", () => {
    renderWithProviders(<TaskBoard tasks={[]} isLoading />);

    expect(screen.getByTestId("loading-spinner")).toBeInTheDocument();
  });

  test("handles error state", () => {
    renderWithProviders(<TaskBoard tasks={[]} error="Failed to load tasks" />);

    expect(screen.getByText(/failed to load tasks/i)).toBeInTheDocument();
  });
});
```

### `src\__tests__\unit\client-form.test.tsx`

```tsx
import React from "react";
import { describe, it, expect, vi, beforeEach } from "vitest";
import { screen, waitFor } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import { ClientForm } from "@/components/clients/client-form";
import { renderWithForm } from "@/lib/test-utils";
import { axe } from "../setup/setup";

describe("ClientForm", () => {
  const mockOnSubmit = vi.fn();
  const defaultClient = {
    id: "123",
    full_name: "Test Client",
    company_name: "",
    contact_email: "test@example.com",
    onboarding_notes: "",
    status: "pending",
    type: "individual",
    contact_details: {
      phone: "",
      address: "",
      city: "",
      state: "",
      zip: "",
    },
    tax_info: {
      filing_status: "",
      tax_id: "",
      tax_year: new Date().getFullYear(),
      filing_type: null,
      tax_id_type: null,
      dependents: [],
      previous_returns: [],
    },
  };

  beforeEach(() => {
    vi.clearAllMocks();
  });

  it("validates required fields", async () => {
    renderWithForm(<ClientForm onSubmit={mockOnSubmit} />);

    const submitButton = screen.getByRole("button", { name: /create client/i });
    await userEvent.click(submitButton);

    expect(
      await screen.findByText("Full name is required"),
    ).toBeInTheDocument();
    expect(await screen.findByText("invalid email format")).toBeInTheDocument();
  });

  it("handles edit mode correctly", async () => {
    renderWithForm(
      <ClientForm
        client={defaultClient}
        onSubmit={mockOnSubmit}
        isEditing={true}
      />,
    );

    expect(screen.getByRole("textbox", { name: /full name/i })).toHaveValue(
      "Test Client",
    );
    expect(screen.getByRole("textbox", { name: /email/i })).toHaveValue(
      "test@example.com",
    );

    const submitButton = screen.getByRole("button", { name: /update client/i });
    await userEvent.click(submitButton);

    expect(mockOnSubmit).toHaveBeenCalledWith(
      expect.objectContaining({
        full_name: "Test Client",
        contact_email: "test@example.com",
      }),
    );
  });

  it("shows loading state during submission", async () => {
    mockOnSubmit.mockImplementation(
      () => new Promise((resolve) => setTimeout(resolve, 100)),
    );
    renderWithForm(<ClientForm onSubmit={mockOnSubmit} />);

    await userEvent.type(
      screen.getByRole("textbox", { name: /full name/i }),
      "New Client",
    );
    await userEvent.type(
      screen.getByRole("textbox", { name: /email/i }),
      "new@example.com",
    );

    const submitButton = screen.getByRole("button", { name: /create client/i });
    await userEvent.click(submitButton);

    expect(await screen.findByText(/creating/i)).toBeInTheDocument();
  });

  it("handles submission errors gracefully", async () => {
    mockOnSubmit.mockRejectedValue(new Error("Failed to create client"));
    renderWithForm(<ClientForm onSubmit={mockOnSubmit} />);

    await userEvent.type(
      screen.getByRole("textbox", { name: /full name/i }),
      "New Client",
    );
    await userEvent.type(
      screen.getByRole("textbox", { name: /email/i }),
      "new@example.com",
    );

    const submitButton = screen.getByRole("button", { name: /create client/i });
    await userEvent.click(submitButton);

    expect(
      await screen.findByText(/failed to create client/i),
    ).toBeInTheDocument();
  });

  it("handles conditional rendering based on client type", async () => {
    renderWithForm(<ClientForm onSubmit={mockOnSubmit} />);

    expect(
      screen.getByRole("textbox", { name: /company name/i }),
    ).toBeInTheDocument();
  });

  it("is accessible", async () => {
    const { container } = renderWithForm(
      <ClientForm onSubmit={mockOnSubmit} />,
    );
    expect(await axe(container)).toHaveNoViolations();
  });
});
```
